var documenterSearchIndex = {"docs":
[{"location":"development/condition-profiles/#Condition-Profiles","page":"Condition Profiles","title":"Condition Profiles","text":"","category":"section"},{"location":"tutorials/logging/#logging_page","page":"Logging","title":"Logging","text":"","category":"section"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"Kinetica makes use of multiple logging functions from the JuliaLogging organisation to handle writing logs of varying detail levels to the console and to file, as well as to handle various optional progress bars for tracking ODE solution progress.","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"By default, running Kinetica functions such as explore_network will output a text stream containing important information about the task at hand to stdout. An example of this can be seen in the 'Running the Simulation' section of Getting Started. This will always log at the Info level, so detailed debugging messages will not be present.","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"To log to a file and/or enable Debug-level logging, Kinetica provides a shorthand function for setting up the correct logger, start_log:","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"using Kinetica\nusing Logging: with_logger, Debug, Info\nlogger = start_log(\"./\"; min_level=Info, label=\"MyLog\")","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"This creates a nicely formatted logger of the requested level at the path ./MyLog_yymmdd-HHMMSS.log, inserting the date and time of creation into the yymmdd and HHMMSS fields respectively. If debug logging is required, min_level=Debug should be set instead.","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"To use this logger on a set of expressions, correctly formatting log messages and sending them to the requested log file, it needs to wrap the expressions in a with_logger function:","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"with_logger(logger) do\n    global res = explore_network(exploremethod, solvemethod, \"./my_CRN_out\")\nend","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"Note the use of the global keyword here - if this is a top-level script, the with_logger function will create a new scope that contains the variable res, which will be lost to the global (script-level) scope once it is exited. By making this variable global, it ensures we don't lose simulation results while logging!","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"Once you've finished logging within a script, call end_log to safely close the log file:","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"end_log(logger)","category":"page"},{"location":"tutorials/logging/#Progress-Bars","page":"Logging","title":"Progress Bars","text":"","category":"section"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"When solving ODEs, Kinetica can both make use of DifferentialEquations.jls native progress bar implementation and set up its own, depending on the solve type requested. Both depend on TerminalLoggers.jl in the background, but if we were to wrap a progress bar into a text log, we'd get a bit of a mess!","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"Kinetica works around this by always passing progress bars within ODE solution calls to the global logger. While the logger variable we defined above is a local logger that needs to be called within a with_logger wrapper, the global logger is specified over the entire session and can be accessed from anywhere in the code. It is therefore enough to define the global logger at the start of a Kinetica script, and the solvers will handle the rest. As in DifferentialEquations.jl, this is done by specifying the following:","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"using Logging: global_logger\nusing TerminalLoggers: TerminalLogger\nglobal_logger(TerminalLogger())","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"To enable progress bars during ODE solution, the progress parameter of ODESimulationParams needs to be set to true.","category":"page"},{"location":"api/kinetica/exploration/#Kinetica.jl-API","page":"Exploration","title":"Kinetica.jl API","text":"","category":"section"},{"location":"api/kinetica/exploration/#CRN-Representation","page":"Exploration","title":"CRN Representation","text":"","category":"section"},{"location":"api/kinetica/exploration/#Representing-Chemical-Species","page":"Exploration","title":"Representing Chemical Species","text":"","category":"section"},{"location":"api/kinetica/exploration/","page":"Exploration","title":"Exploration","text":"SpeciesData\nBase.push!(::SpeciesData, ::String, ::Dict{String, Any})\nBase.push!(::SpeciesData, ::Vector{String}, ::Vector{Any})\nBase.push!(::SpeciesData, ::String)\npush_unique!","category":"page"},{"location":"api/kinetica/exploration/#Kinetica.SpeciesData","page":"Exploration","title":"Kinetica.SpeciesData","text":"Bidirectional String-Int dictionary for chemical species.\n\nContains fields for:\n\nSMILES string -> integer ID dictionary (toInt)\nInteger ID -> SMILES string dictionary (toStr)\nNumber of species (n)\nExtXYZ structures of species (xyz)\nDictionary of per-species cached values (cache)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/exploration/#Base.push!-Tuple{SpeciesData, String, Dict{String, Any}}","page":"Exploration","title":"Base.push!","text":"push!(sd, smi, xyz)\n\nAdd a species to SpeciesData.\n\nDoes not account for smi already existing within sd. To ensure no overlap, use push_unique!.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/exploration/#Base.push!-Tuple{SpeciesData, Vector{String}, Vector{Any}}","page":"Exploration","title":"Base.push!","text":"push!(sd, smis, xyzs)\n\nAdd an array of species to SpeciesData.\n\nDoes not account for smi already existing within sd. To ensure no overlap, use push_unique!.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/exploration/#Base.push!-Tuple{SpeciesData, String}","page":"Exploration","title":"Base.push!","text":"push!(sd, xyz_file[, fix_radicals])\n\nAdd all species in xyz_file to sd.\n\nDoes not account for smi already existing within sd. To ensure no overlap, use push_unique!.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/exploration/#Kinetica.push_unique!","page":"Exploration","title":"Kinetica.push_unique!","text":"push_unique!(sd, smi, xyz)\n\nAdd a species SMILES to a SpeciesData, as long as it does not already exist there.\n\n\n\n\n\npush_unique!(sd, xyz_file[, fix_radicals])\n\nAdd species in xyz_file to sd, as long as they do not already exist there.\n\n\n\n\n\npush_unique!(sd, smis, xyzs)\n\nAdd an array of species to SpeciesData, as long as each does not already exist there.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Representing-Reactions","page":"Exploration","title":"Representing Reactions","text":"","category":"section"},{"location":"api/kinetica/exploration/","page":"Exploration","title":"Exploration","text":"RxData\nBase.push!(::RxData{iType, fType}, ::SpeciesData, ::Vector{Vector{String}}, ::Vector{Vector{String}}, ::Vector{Dict{String, Any}}, ::Vector{Dict{String, Any}}, ::Vector{fType}) where {iType, fType <: AbstractFloat}\nBase.splice!(::RxData, ::Vector{Int})","category":"page"},{"location":"api/kinetica/exploration/#Kinetica.RxData","page":"Exploration","title":"Kinetica.RxData","text":"Data container for reactions.\n\nShould be constructed alongside a SpeciesData for mapping species IDs to SMILES strings.\n\nContains fields for:\n\nNumber of reactions encountered (nr)\nAtom-mapped reaction SMILES for unambiguous linking of atom indices in reactants and products (mapped_rxns)\nUnique IDs of reactants for each reaction (id_reacs)\nUnique IDs of products for each reaction (id_prods)\nStoichiometries of reactants for each reaction (stoic_reacs)\nStoichiometries of products for each reaction (stoic_prods)\nReaction enthalpies (dH)\nReaction hashes, used for unique identification (rhash)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/exploration/#Base.push!-Union{Tuple{fType}, Tuple{iType}, Tuple{RxData{iType, fType}, SpeciesData, Vector{Vector{String}}, Vector{Vector{String}}, Vector{Dict{String, Any}}, Vector{Dict{String, Any}}, Vector{fType}}} where {iType, fType<:AbstractFloat}","page":"Exploration","title":"Base.push!","text":"push!(rd, sd, reacs, prods, rsys, psys, dH[, unique_rxns, max_molecularity])\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/exploration/#Base.splice!-Tuple{RxData, Vector{Int64}}","page":"Exploration","title":"Base.splice!","text":"splice!(rd, rids)\n\nRemoves reactions at indeces rids from rd.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/exploration/#CRN-Initialisation","page":"Exploration","title":"CRN Initialisation","text":"","category":"section"},{"location":"api/kinetica/exploration/","page":"Exploration","title":"Exploration","text":"init_network","category":"page"},{"location":"api/kinetica/exploration/#Kinetica.init_network","page":"Exploration","title":"Kinetica.init_network","text":"sd, rd = init_network([iType, fType])\n\nInitialises an empty reaction network.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#CDE-Interface","page":"Exploration","title":"CDE Interface","text":"","category":"section"},{"location":"api/kinetica/exploration/","page":"Exploration","title":"Exploration","text":"CDE\nKinetica.ingest_cde_run","category":"page"},{"location":"api/kinetica/exploration/#Kinetica.CDE","page":"Exploration","title":"Kinetica.CDE","text":"cde = CDE(rdir, template_dir, init_xyz, env[, sampling_seed, radius])\n\nCDE runner. Initialised through struct, run through functor.\n\nStruct contains fields for:\n\nCDE template directory (template_dir)\nEnvironmental multithreading number of threads (Optional, defaults to 1 thread; env_threads)\nPath to CDE executable (Optional, defaults to CDE packaged within CDEjll; `cdeexec`)\nSeed for CDE's RNG (Optional, setting to 0 indicates seed should be random; sampling_seed)\nRadius for exploration of breakdown space (Optional, Default = 50; radius)\nNumber of mechanisms to generate within a single CDE run (Optional, Default = 1; nrxn)\nNumber of parallel CDE runs to execute (Optional, Default = 1; parallel_runs)\nMaximum number of parallel CDE executables to run at any time (Optional, Default = 1; parallel_exes)\nWhether to write CDE's stdout to file (Optional, Default = false; write_stdout)\nWhether to write CDE's stderr to file (Optional, Default = false; write_stderr)\nWhether to allow functions to continue running if CDE errors are detected (Optional, Default = false; allow_errors)\n\nAdditionally, some fields are usually modified within Kinetica, and are not intended to be changed by users.\n\nMain reaction directory (rdir)\nXYZ file of starting molecule/material (init_xyz)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/exploration/#Kinetica.ingest_cde_run","page":"Exploration","title":"Kinetica.ingest_cde_run","text":"reac_smis, reac_xyzs, reac_systems, prod_smis, prod_xyzs, prod_systems, dH = ingest_cde_run(rdir, rcount[, fix_radicals])\n\nReads in the results from a CDE run.\n\nSeparates out fragment species from each available reaction's reactants and products, forming arrays of their SMILES strings and ExtXYZ geometries.\n\nOBCanonicalRadicals can be enabled to tidy up radical SMILES using the fix_radicals parameter.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Exploration","page":"Exploration","title":"Exploration","text":"","category":"section"},{"location":"api/kinetica/exploration/","page":"Exploration","title":"Exploration","text":"DirectExplore\nIterativeExplore\nexplore_network","category":"page"},{"location":"api/kinetica/exploration/#Kinetica.DirectExplore","page":"Exploration","title":"Kinetica.DirectExplore","text":"Container for parameters used in direct CRN exploration.\n\nContains fields for:\n\nTop level of CRN exploration directory (rdir_head)\nSMILES string(s) of main breakdown reactant(s) being studied (reac_smiles)\nCDE instance (cde)\nMaximum number of iterations to perform (maxiters)\nNumber of iterations with no change in reactions to consider as converged (rxn_convergence_threshold)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/exploration/#Kinetica.IterativeExplore","page":"Exploration","title":"Kinetica.IterativeExplore","text":"Container for parameters used in iterative kinetics-based CRN exploration.\n\nContains fields for:\n\nTop level of CRN exploration directory (rdir_head)\nSMILES string(s) of main breakdown reactant(s) being studied (reac_smiles)\nCDE instance (cde)\nMaximum number of iterations to perform (maxiters)\nNumber of subspace iterations with no change in reactions to consider a subspace converged (rxn_convergence_threshold)\nNumber of level iterations with no change in seeds to consider the network converged (seed_convergence_threshold)\nConcentration above which species will be selected as seeds each level (seed_conc)\nBlacklist of species to avoid doing independent subspace explorations on (independent_blacklist)\nInert species that should not be considered for reaction (inert_species)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/exploration/#Kinetica.explore_network","page":"Exploration","title":"Kinetica.explore_network","text":"res = explore_network(exploremethod::Union{DirectExplore, IterativeExplore}, solvemethod[, savedir])\n\nRuns network exploration with one of the available methods.\n\nIf exploremethod isa DirectExplore, runs a single-level network exploration to attempt to locate all relevant reactions in a radius of exploremethod.cde.radius species from the starting system.\n\nIf exploremethod isa IterativeExplore, runs a multi-level iterative network exploration using kinetic simulations to identify seed species for successive levels, in order to fully characterise the reaction space relevant to the conditions in solvemethod.conditions.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Molecule-System","page":"Exploration","title":"Molecule System","text":"","category":"section"},{"location":"api/kinetica/exploration/","page":"Exploration","title":"Exploration","text":"system_from_smiles\nsystem_from_mols\nKinetica.molsys_opt","category":"page"},{"location":"api/kinetica/exploration/#Kinetica.system_from_smiles","page":"Exploration","title":"Kinetica.system_from_smiles","text":"system_from_smiles(smiles[, saveto, dmin])\n\nForms a single XYZ system out of the molecules in smiles.\n\nUseful for making unified molecular systems with no overlap for feeding into CDE. dmin represents the minimum  molecule-molecule distance that should be allowed.\n\nIf the argument saveto is provided, outputs the optimised system to a file at this path. If not, returns the optimised system as a single ExtXYZ dict.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Kinetica.system_from_mols","page":"Exploration","title":"Kinetica.system_from_mols","text":"\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Kinetica.molsys_opt","page":"Exploration","title":"Kinetica.molsys_opt","text":"tmols = molsys_opt(mols, dmin, maxiters)\n\nOptimises positions of molecules in mols to ensure they are all at least dmin Angstroms apart.\n\nCreates and solves an N-body spring-driven particle system and transforms molecular coordinates to these particles to check for proximity.\n\n\n\n\n\n","category":"function"},{"location":"development/crn-representation/#crn_representation_page","page":"CRN Representation","title":"CRN Representation","text":"","category":"section"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"note: In Progress\nThis page is still under construction. Check back later!","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"When adding new reactions to a CRN, Kinetica performs a few checks. Reactions are discarded if they:","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"Only contain conformational changes. Species are internally represented by SMILES, so any changes not representable by SMILES (e.g. single bond rotations) lead to species being classed as the same. Note that E/Z isomers and enantiomers are distinct from one another in SMILES.\nExceed the maximum molecularity. By default this is 2, so only unimolecular and bimolecular reactions are allowed to enter a CRN. This is controllable by the max_molecularity argument when constructing or pushing to RxData.\nAlready exist in the RxData they are being added to. This is checked by comparing a reaction's unique hash to those currently in the CRN.","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"<!– Need to mention how reverse reactions are automatically added during CDE ingest somewhere. –>","category":"page"},{"location":"tutorials/saving-loading/#Saving-and-Loading","page":"Saving & Loading","title":"Saving & Loading","text":"","category":"section"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"Kinetica allows for saving and loading ODESolveOutput objects (see Results Analysis) in a binary JSON (BSON) format using the BSON.jl package. This allows for generated CRNs and the parameters and results of kinetic simulations to be serialised and efficiently stored, while also being usable in new Julia sessions and retaining the analysis tools detailed in Results Analysis.","category":"page"},{"location":"tutorials/saving-loading/#Saving","page":"Saving & Loading","title":"Saving","text":"","category":"section"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"When performing a CRN exploration, saving is handled automatically by passing a directory to the savedir keyword argument of explore_network, as was demonstrated in Getting Started. However, ODESolveOutputs can also be saved manually using the save_output function:","category":"page"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"# res = solve_network(solvemethod, sd, rd)\nsave_output(res, \"/path/to/saved_output.bson\")","category":"page"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"note: Save Path\nUnlike the savedir argument of explore_network, the path provided to save_output should be to a file ending in .bson, rather than to a directory, since only a single CRN is being saved (rather than the multiple checkpoints saved by iterative CRN explorations).","category":"page"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"Saving simulation outputs this way destructures them into core Julia objects only - mostly Vectors, Dicts and Arrays. This allow them to be loaded back in under any Julia environment, even those where Kinetica or DifferentialEquations.jl (which ODESolveOutputs makes heavy use of types from) are not loaded. However, this does necessitate discarding some of the internals of objects such as ConditionSets and DiffEq's ODESolutions which are not easily serialised.","category":"page"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"warning: Unsaved Fields\nAmong the data that will be lost on saving are:Anything in ODESolveOutput.sd.cache, as the contents of this cache are intentionally undefined and therefore difficult to serialise correctly. This will be replaced with an empty Dict upon loading.\nAny Julia functions within variable condition profiles, i.e. the f field within AbstractDirectProfiles and the grad field within AbstractGradientProfiles. Functions are not directly serialisable within BSON.\nThe exact ODE solver used within ODESolveOutput.pars.solver, as this is always an external type. This will be replaced with a Symbol representing the type of solver for reference of what was used within the attached simulation.\nAny DiffEq ODESolutions such as ODESolveOutput.sol will lose their underlying ModelingToolkit representations, as only the sol.u and sol.t fields will be saved. These are reconstructed as DiffEqArrays when loaded back in.Note that no information about the kinetic calculator used within the simulation is saved either. Calculator implementation varies too much to be consistently serialised so it is intentionally left out of ODESolveOutput. It can be very useful to save some of the information stored within calculators and this is entirely possible with BSON.jl, but this is left to the user.","category":"page"},{"location":"tutorials/saving-loading/#Loading","page":"Saving & Loading","title":"Loading","text":"","category":"section"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"Saved CRN results can be loaded back in to Julia through two methods. If loaded back in using Kinetica's load_output function, the serialised BSON gets reconstructed into a new ODESolveOutput. Taking the CRN we generated and simulated in Getting Started as an example:","category":"page"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"using Kinetica\n\nres = load_output(\"../my_CRN_out/direct_network_final.bson\");\nnothing # hide","category":"page"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"note: Suppressing Output\nWhen called in an interactive session, load_output will produce a lot of output detailing the ODESolveOutput object. To suppress this, the load call can be ended with a semicolon, like above.","category":"page"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"While every effort is made to maintain compatibility between saved outputs between Kinetica versions, we cannot guarantee that the internal structure of ODESolveOutputs will never change. If this happens in a way that cannot be worked around when reconstructing within load_output, or if you wish to load the data in an environment without Kinetica, the output can still be loaded in as a raw BSON Dict tree:","category":"page"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"using BSON\nout_raw = BSON.load(\"../my_CRN_out/direct_network_final.bson\")","category":"page"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"This allows users to flexibly access generated CRNs and kinetic simulation results, even when Kinetica is unavailable.","category":"page"},{"location":"development/implementation-details/#Implementation-Details","page":"Implementation Details","title":"Implementation Details","text":"","category":"section"},{"location":"development/implementation-details/#implementation_chunkwise_time","page":"Implementation Details","title":"Chunkwise Time","text":"","category":"section"},{"location":"development/implementation-details/#implementation_adaptive_tolerance","page":"Implementation Details","title":"Adaptive Solver Tolerance","text":"","category":"section"},{"location":"development/implementation-details/#implementation_low_rate","page":"Implementation Details","title":"Removing Low-Rate Reactions","text":"","category":"section"},{"location":"api/kinetica/analysis/#Kinetica.jl-API","page":"Analysis","title":"Kinetica.jl API","text":"","category":"section"},{"location":"api/kinetica/analysis/#Analysis","page":"Analysis","title":"Analysis","text":"","category":"section"},{"location":"api/kinetica/analysis/#CRN-I/O","page":"Analysis","title":"CRN I/O","text":"","category":"section"},{"location":"api/kinetica/analysis/","page":"Analysis","title":"Analysis","text":"ODESolveOutput\nsave_output\nload_output","category":"page"},{"location":"api/kinetica/analysis/#Kinetica.ODESolveOutput","page":"Analysis","title":"Kinetica.ODESolveOutput","text":"Data container for output of network ODE solutions.\n\nBinds together all data required for analysis of network ODE solution results. Used as an input for many of the automated plotting functions in KineticaCore.\n\nAlso used for results IO, can be completely deconstructed into a package-independent dictionary tree for saving as binary JSON (BSON) with save_output. Can be reconstructed from such a BSON file with load_output.\n\nContains fields for:\n\nCRN SpeciesData after simulation (sd)\nCRN RxData after simulation (rd)\nKinetic simulation solution, usually a DiffEq ODESolution o/e (sol)\nDiffEqArray of precalculated rate constants, if discrete rate update method was used (sol_k)\nDict of DiffEqArrays for variable conditions, if solved simultaneously with species concentrations (sol_vcs)\nODESimulationsParams used for kinetic simulation (pars)\nConditionSet used for kinetic simulation (conditions)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/analysis/#Kinetica.save_output","page":"Analysis","title":"Kinetica.save_output","text":"save_output(out, saveto)\n\nSaves the output of a network ODE solution to BSON file.\n\nAvoids massive file sizes and attempts to maintain forward compatibility by breaking down large structs into their base arrays and values, such that they can be reconstructed when loaded back in.\n\nThe resulting BSON file is therefore a dictionary tree, which can be read in using only Julia's base library and OrderedCollections if all else fails using BSON.load directly.\n\nHowever, the original ODESolveOutput can be mostly reconstructed by instead calling load_output(). Some data is necessarily lost or converted to a Symbol for reference - mostly data concerning the internals of ODESolutions. \n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/analysis/#Kinetica.load_output","page":"Analysis","title":"Kinetica.load_output","text":"load_output(outfile)\n\nLoads in the results generated by save_output from a network ODE solution.\n\nReconstructs an ODESolveOutput from a dictionary tree in the BSON file outfile. Note that some data is lost in the serialisation process, see the documentation of save_output for details.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Here we will demonstrate how to perform a simple CRN exploration using Kinetica. Simulations within Kinetica are designed to be run as a script, consisting of the following elements:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Parameter blocks,\nSimulation,\nAnalysis.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"We will begin by going through a basic example of each of these elements. Further details can be found in the Tutorials section of this documentation. ","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If you are attempting to recreate this tutorial for yourself, it relies on a few input files that are separate to any of the main code repositories. These files can be found in the examples directory of this documentation's repository, which can be accessed by cloning this repository:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"git clone https://github.com/Kinetica-jl/KineticaDocs.jl.git\ncd KineticaDocs.jl/examples","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"To start with the tutorial, load the main Kinetica.jl package:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using Kinetica","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"We'll also set a seed for Julia's random number generation, to ensure that this tutorial is fully reproducible. This can be ignored in regular use, but is useful here if you want to compare your results to those obtained here.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using Random\nRandom.seed!(12345)\nnothing # hide","category":"page"},{"location":"getting-started/#Parameter-Blocks","page":"Getting Started","title":"Parameter Blocks","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The initial part of Kinetica simulation scripts usually consist of 3-4 blocks of parameters, depending on whether or not the simulation consists of only a kinetic calculation on a pre-existing CRN or if it also requires a CRN exploration before such a calculation can take place.","category":"page"},{"location":"getting-started/#Simulation-Conditions","page":"Getting Started","title":"Simulation Conditions","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The first parameter block should be a ConditionSet, which defines the experimental conditions a kinetic calculation should take place under. This block is usually defined first as later parameters often depend on it.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"ConditionSet blocks allow for flexible definitions of any number of arbitrary conditions, each of which can be static (constant) or variable (time-dependent). For this simple CRN exploration, we will define a ConditionSet that specifies a linear temperature increase, from 300 K at time t = 0.0 to 1000 K at a rate of 50 K/s. Kinetica comes with a library of variable condition profiles, allowing this ConditionSet to be simply defined as follows:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"conditions = ConditionSet(Dict(\n    :T => LinearGradientProfile(;\n        rate = 50.0,\n        X_start = 500.0,\n        X_end = 1200.0\n    )\n))","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This generates a LinearDirectProfile for the linear temperature increase we are interested in, and binds it to the symbol :T for use within kinetic calculators. Further information on the types of condition profiles implemented in Kinetica can be found in the tutorial on Arbitrary Simulation Conditions.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"We will be able to visualise this condition profile shortly, but we must first define a parameter block of ODE solution parameters.","category":"page"},{"location":"getting-started/#Kinetic-Simulation-Parameters","page":"Getting Started","title":"Kinetic Simulation Parameters","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The ODESimulationParams block defines all of the parameters needed when converting a CRN to a system of ODEs and integrating it in time. This includes parameters such as the simulation timespan, initial concentrations of reactants and the ODE solver being used.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For the purposes of this tutorial, we will construct the following ODESimulationParams block:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using OrdinaryDiffEq\nusing Sundials\n\npars = ODESimulationParams(\n    tspan = (0.0, get_t_final(conditions)),\n    u0 = Dict(\"C\" => 1.0),\n    solver = CVODE_BDF(; linear_solver=:KLU)\n)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This block details the three essential parameters for any simulation in Kinetica:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"tspan: Simulation timespan (in seconds, unless otherwise specified within kinetic calculator). Must be a tuple of (start_time, end_time). Here, we fetch the end time directly from the ConditionSet defined above using get_t_final(conditions), which calculates the time at which all defined conditions have reached their final state.\nu0: Dictionary of initial concentrations. Here we define that kinetic simulations should start with 1.0 mol dm^-3 of methane (C in SMILES notation), and no other reactants.\nsolver: ODE solution algorithm to use, from those available in DifferentialEquations.jl. Here we load in the CVODE_BDF solver from the Sundials.jl library, as this has been the best general-purpose solver in our testing. The KLU linear solver allows this ODE solver to work with sparse arrays, which are enabled by default.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Further details of the parameters available in this block can be found in the ODE Solution section.","category":"page"},{"location":"getting-started/#CRN-Exploration-Parameters","page":"Getting Started","title":"CRN Exploration Parameters","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"In order to perform a CRN exploration, an exploration method must be chosen. Kinetica currently provides two: DirectExplore and IterativeExplore. For now we will use the former, as it is simpler.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"DirectExplore explores all chemical reactions within a given radius of the starting reactants, irrespective of whether or not they will occur within a later kinetic simulation under the selected environmental conditions. This method is best suited to small CRNs under kinetically slow conditions, where few reactions are possible and complete sampling of all available reactions is easy.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Reactions are sampled using CDE, an external code for graph-droven sampling of reactions that is included with Kinetica.jl. CDE has its own parameters which must be set, but these are usually very similar for most CRN explorations. As such, a directory of template inputs must be provided for CDE to function. We provide such a template directory with this documentation, which can be used to run this tutorial. If you have cloned this documentation's repository, as suggested at the start of this tutorial, these files are in KineticaDocs.jl/examples/cde_template.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Once this is done, the exploration parameters can be set up as follows:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"crn_dir = \"./my_CRN\"\n\nexploremethod = DirectExplore(\n    rdir_head = crn_dir,\n    reac_smiles = [\"C\"],\n    rxn_convergence_threshold = 5,\n    cde = CDE(\n        template_dir = \"../../examples/cde_template\",\n        radius = 5,\n        sampling_seed = 1\n    )\n)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The parameters defined in this block are as follows:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"rdir_head : This is the directory in which the raw CRN exploration files will be stored. We have defined crn_dir above because it will be useful to reference later. ","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"warning: I/O intensity\nMany CDE runs can be quite I/O-heavy, so it is useful to place this directory on a fast, directly-attached drive. Running the CRN exploration out of a network-attached spinning hard drive will probably be a bad time.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"reac_smiles: Array of SMILES strings representing reactants in the initial reactant system. These will be fed to CDE to generate reactions. In this case, we will generate all reactions that can occur between two methane molecules.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"note: The Iterative method works differently!\nWatch out for the meaning of these parameters changing slightly between DirectExplore and IterativeExplore. They can serve the same purpose, but methodologically do different things under the hood. See the tutorial on Iterative CRN Exploration for more information.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"rxn_convergence_threshold: How many CDE iterations to perform with no new reactions discovered before considering the CRN converged.\ncde: CDE parameter block using the example input templates (change this path to the directory you saved yours into). This defines a reactive radius of 5, meaning that all reactions within 5 steps of the reactant system will be generated. The sampling_seed parameter is usually not set, but we will set it here to make this tutorial reproducible. More information on this sub-block is also given in the Iterative CRN Exploration tutorial.","category":"page"},{"location":"getting-started/#Kinetic-Calculator","page":"Getting Started","title":"Kinetic Calculator","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The final parameter block to set up is the simulation's kinetic calculator. This is an object capable of calculating rate constants for every reaction in a CRN under a given set of conditions. Kinetic calculators are one of the core points of modularity in Kinetica, with extension packages like KineticaKPM.jl extending the functionality of the main code by adding in more calculators for different requirements.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The main Kinetica.jl package only includes one kinetic calculator, the PrecalculatedArrheniusCalculator. This calculator calculates temperature-dependent rate constants using the Arrhenius equation:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"k = Ae^-dfracE_aRT","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The PrecalculatedArrheniusCalculator requires vectors of Arrhenius prefactors A and activation energies Ea for all reactions before the code is executed, and as such is typically only used when a CRN has been generated and these values have been determined outside Kinetica. However, for the purposes of this tutorial (where the random seed for CDE's reaction generation has been set, see above), we know the reactions that are going to be generated in advance, so we have provided approximate values to input into this calculator. These values are in KineticaDocs.jl/examples/getting_started/arrhenius_params.bson, and can be loaded in with:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using BSON\ncalc_pars = BSON.load(\"../../examples/getting_started/arrhenius_params.bson\")","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"again, replacing this path with the equivalent path on your computer. The calculator for this CRN can now be constructed:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"calc = PrecalculatedArrheniusCalculator(calc_pars[:Ea], calc_pars[:A]; k_max=1e12)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For more advanced calculators that allow on-the-fly calculation of rate constants as reactions are generated, see the tutorial on Kinetic Calculators.","category":"page"},{"location":"getting-started/#Simulation","page":"Getting Started","title":"Simulation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Now that all of the parameter blocks have been constructed, we can start generating and simulating CRNs!","category":"page"},{"location":"getting-started/#Visualising-Condition-Profiles","page":"Getting Started","title":"Visualising Condition Profiles","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"First, now that we have both a ConditionSet and a ODESimulationParams block, we can have a look at the variable temperature profile that we created. To begin, we need to construct a DifferentialEquations ODESolution for this profile. Kinetica provides a shortcut for this, with a one-liner that constructs ODEProblems and solves them for every variable condition in a ConditionSet:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"solve_variable_conditions!(conditions, pars)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"note: Not neccessary in regular use!\nWe are manually triggering the solution of the ConditionSet here to visualise how the constructed temperature profile will look in the final simulation. However, calling solve_variable_conditions! as above is not neccessary in all Kinetica scripts. This function is normally run automatically before integrating the CRN ODEs, and does not typically need to be called like this.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"With this in place, we can now plot our temperature profile's ODESolution to see how the simulation temperature is going to vary with time:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"mkpath(\"assets/getting-started\") # hide\nusing Plots\nplot(get_profile(conditions, :T).sol)\nsavefig(\"assets/getting-started/Tprofile.svg\"); nothing # hide","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"As expected, the temperature profile we constructed goes from 300 K to 1000 K at a rate of 50 K/s. Provided we are happy with this, we can continue to perform a CRN exploration and a kinetic simulation.","category":"page"},{"location":"getting-started/#Running-the-Simulation","page":"Getting Started","title":"Running the Simulation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"CRN exploration and kinetic simulation are wrapped under a single function call: explore_network. This takes the exploration parameters, the simulation parameters and calculator (which we will wrap under a single variable), and optionally a directory to save the finished results to. These results will additionally be returned by the function. To run the entire simulation, we simply call the following:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"solvemethod = VariableODESolve(pars, conditions, calc)\nmkdir(\"./my_CRN_out\") # hide\nres = explore_network(exploremethod, solvemethod; savedir=\"./my_CRN_out\")\nnothing # hide","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"note: Checkpoints and Restarts\nIn the event that a Kinetica CRN exploration fails before completion, all is not lost! As long as you still have the original head directory that the CRN was being explored in (crn_dir in this tutorial), both of Kinetica's exploration algorithms will detect where you left off and restart from there seamlessly. In the iterative exploration algorithm, Kinetica also creates checkpoint files with current CRN state and kinetic simulation results, which are saved under the savedir keyword argument specified above along with the final simulation output.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The resulting ODESolveOutput object contains the explored CRN, the kinetic simulation results, and all of the parameters and conditions that went into it. These can be easily and efficiently saved and loaded as needed (see Saving & Loading).","category":"page"},{"location":"getting-started/#Analysis","page":"Getting Started","title":"Analysis","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The ODESolveOutput object has plot recipes defined for easy plotting using Plots.jl, allowing complex figures and statistics to be shown with a single line of code. To begin, we can look at how the concentrations of all of the species found during CRN generation vary over time under the variable temperature profile we specified. This is achieved by simply running","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"plot(res)\nsavefig(\"assets/getting-started/kinetics_plot.svg\"); nothing # hide","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This CRN presents some interesting results! Accoding to the kinetics enforced by the calculator we have used, methane will not start breaking down into any of the free radical species discovered within this CRN until t approx 5 text s. We could check the temperature that this occurs at by referencing the temperature profile we plotted above but this is also accessible from res by running","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"conditionsplot(res, :T)\nsavefig(\"assets/getting-started/Tprofile_2.svg\"); nothing # hide","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Notice how, because we used the conditionsplot() function, the correct symbolically-indexed condition profile was obtained and axis labels were set accordingly.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If we want to obtain the numeric value of the temperature at t approx 5 text s, we can interpolate this directly:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Tprofile = get_profile(res.conditions, :T)\nTprofile.sol(5.0)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If we had multiple variable condition profiles, the above could also be done for them by simply passing in their bound symbols.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Similarly, we can also obtain the concentrations of all of the species in the reaction mixture at any time in the simulation through interpolation:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"res.sol(5.0)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"It is also very useful to analyse the final concentrations of species at the end of a kinetic simulation. Kinetica defines another plot recipe for this:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"finalconcplot(res)\nsavefig(\"assets/getting-started/concs_plot.svg\"); nothing # hide","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"getting-started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Now you're familiar with the basics of network exploration and kinetic simulation within Kinetica, you can learn more by looking through the other tutorials! ","category":"page"},{"location":"development/calculator-interface/#Calculator-Interface","page":"Calculator Interface","title":"Calculator Interface","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/#Kinetic-Calculators","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"Kinetica allows for any and all rate constant expressions to be used within kinetic simulations through its modular kinetic calculator interface. This allows users and developers alike to quickly define a set of functions which are dependent on a CRN (through a SpeciesData and an RxData) and some arbitrary experimental conditions which the simulation takes place under, such as temperature and pressure, and to calculate rate constants. For more information on how kinetic calculators are implemented, see Calculator Interface.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"Kinetica features a single base calculator, the PrecalculatedArrheniusCalculator. This calculator relies on having Arrhenius prefactors and activation energies precalculated for every reaction in a CRN, and serves mostly as a test calculator and an implementation example. ","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"Other more useful calculators are provided as modular addon packages that extend Kinetica.jl (e.g. KineticaKPM.jl). Some calculators have extensive dependencies, so this modularisation allows for picking and choosing only the calculators required for a specific project rather than having every available calculator in one bloated Julia/Python environment.","category":"page"},{"location":"tutorials/kinetic-calculators/#Manually-Calling-Calculators","page":"Kinetic Calculators","title":"Manually Calling Calculators","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"The examples below all show how calculators can be manually called to calculate rate constants. This is useful when these values are required, e.g. for analysis, but is not required during kinetic simulations. Passing a calculator into explore_network or solve_network via a VariableODESolve struct (see the 'Running the Simulation' section of Getting Started) is enough to set up the calculator and evaluate rate constants as many times as is required by the simulation.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"In the event that a calculator is required to be called manually, the process is very simple. Once the calculator has been instantiated, it should be passed to its setup_network! method. All kinetic calculators implement such a function, which checks the values provided to the calculator are compatible with a given SpeciesData and RxData and does any necessary pre-calculation such that the calculator can perform the minimum computation when rate constants are requested. Once setup, the calculator object can be called as a functor with its implemented experimental conditions as keyword arguments to evaluate the rate constants of all reactions in the given CRN at the provided values of the conditions. Examples of this process can be found below.","category":"page"},{"location":"tutorials/kinetic-calculators/#Calculator-Showcase","page":"Kinetic Calculators","title":"Calculator Showcase","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"In all of the examples below, sd and rd refer to instances of SpeciesData and RxData respectively. These are the internal representations of species and reactions within Kinetica, see the page on CRN Representation for further information.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"note: This section is growing!\nKinetica currently has only a handful of kinetic calculators available. We are adding more as we need them, but if you require a specific implementation then please let us know on our Issues page. Alternatively, calculators aren't too hard to implement yourself, and custom calculators can be dropped into kinetic simulations just like the ones presented here. See Calculator Interface for details.","category":"page"},{"location":"tutorials/kinetic-calculators/#Kinetica.jl","page":"Kinetic Calculators","title":"Kinetica.jl","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/#[PrecalculatedArrheniusCalculator](@ref)","page":"Kinetic Calculators","title":"PrecalculatedArrheniusCalculator","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"This calculator is dependent on temperature as an experimental condition, and takes a vector of Arrhenius prefactors and a vector of activation energies, each with an entry for each reaction in a given CRN, and calculates rate constants with the Arrhenius equation. It also accepts an optional maximum rate constant k_max which takes over through partial diffusion control. The calculated rate constant for reaction i is therefore: ","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"k_i = dfrac1dfrac1k_textmax + dfrac1A_ie^-dfracE_iRT","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"where A_i is the ith Arrhenius prefactor, E_i is the ith activation energy, R is the ideal gas constant and T is the temperature, which must be passed in as a parameter.","category":"page"},{"location":"tutorials/kinetic-calculators/#Example:","page":"Kinetic Calculators","title":"Example:","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"# Get Arrhenius prefactors A and activation energies Ea from elsewhere...\n# Length of A and Ea should match rd.nr.\ncalc = PrecalculatedArrheniusCalculator(Ea, A; k_max = 1e12)\nsetup_network!(sd, rd, calc)\nk = calc(; T = 300.0)","category":"page"},{"location":"tutorials/kinetic-calculators/#KineticaKPM.jl","page":"Kinetic Calculators","title":"KineticaKPM.jl","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"The calculators in KineticaKPM all use KineticPredictorModel (KPM), a Python code for predicting activation energies using a simple neural network, as a driver for rate constant calculation using the Arrhenius equation. Arrhenius prefactors are estimated through a variety of methods depending on the calculator used.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"The calculators in this package require an instance of KPMRun, which acts as an interface to the KPM package and handles conversion of the current CRN into reactions which it can predict activation energies for. This is simply constructed by calling the following:","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"kpm = KPMRun(\"/path/to/kpm_model.npz\")","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"where the KPM model .npz file should be obtained separately through training a model with the main Python package.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"All calculators in this package accept an optional maximum rate constant k_max which takes over through partial diffusion control. They are also all capable of returning rate constants with Measurements.jl uncertainties, derived from the standard deviation between activation energy predictions within an ensemble of neural networks. While these can be used manually, they are not currently supported within any of the ODE solution methods in Kinetica.","category":"page"},{"location":"tutorials/kinetic-calculators/#[KPMBasicCalculator](@ref)","page":"Kinetic Calculators","title":"KPMBasicCalculator","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"This calculator is dependent on temperature as an experimental condition. It estimates Arrhenius prefactors as","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"A = dfracRTh","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"for all reactions, where R is the ideal gas constant, T is the temperature, which must be passed as a parameter, and h is the Planck constant. The resulting rate constant for reaction i is therefore:","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"k_i = dfrac1dfrac1k_textmax + dfrac1dfracRThe^-dfracE_iRT","category":"page"},{"location":"tutorials/kinetic-calculators/#Example:-2","page":"Kinetic Calculators","title":"Example:","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"# Set up KPMRun object before this...\ncalc = KPMBasicCalculator(kpm; uncertainty = false, k_max = 1e12)\nsetup_network!(sd, rd, calc)\nk = calc(; T = 300.0)","category":"page"},{"location":"tutorials/kinetic-calculators/#[KPMCollisionCalculator](@ref)","page":"Kinetic Calculators","title":"KPMCollisionCalculator","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"This calculator is dependent on temperature as an experimental condition. It estimates Arrhenius prefactors using collision theory, a hard-sphere approximation of collision frequency. All unimolecular reactions therefore require a collision partner for reactions to occur, which can be passed through the inert_species argument. If this is given, setup_network! will modify all unimolecular reactions to become bimolecular with the provided collision partners. Otherwise, an average collision partner will be calculated from the species in the CRN and rates will be calculated assuming a concentration of 1 mol dm^-3 of this 'species'.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"The calculator computes two properties for each reaction: the reduced mass mu and the collision cross section sigma. For collision partners A and B, these are defined as","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"mu = dfracm_A m_Bm_A + m_B \nsigma = pi left( r_A + r_B right)^2","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"where m_A and m_B are the masses of A and B respectively and r_A and r_B are the hard sphere radii of A and B respectively.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"The calculator optionally allows for specification of a 'steric factor' rho. Collision theory is known to overestimate rate constants, but there is no perfect mathematical relationship that can calculate how much this overestimate is by. The steric factors implemented here attempt to establish an empirical correction to the collision theory rate constant based on a variety of information about each species. See KineticaKPM.calc_steric_factors for further information.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"The resulting rate constant for reaction i is therefore:","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"k_i = dfrac1dfrac1k_textmax + dfrac1sigma_i rho_i N_A sqrtdfrac8 k_b Tpi mu_ie^-dfracE_iRT","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"where N_A is Avogadro's number, k_b is the Boltzmann constant, T is the temperature, which is passed as a parameter, E_i is the activation energy and R is the ideal gas constant.","category":"page"},{"location":"tutorials/kinetic-calculators/#Example:-3","page":"Kinetic Calculators","title":"Example:","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"# If using inert species, these need an initial concentration.\npars = ODESimulationParams(\n    tspan = (0.0, 10.0)\n    u0 = Dict(\n        \"CC\" => 1.0,\n        \"N#N\" => 1.0\n    ),\n    solver = ...\n)\n# Set up KPMRun object before this...\ncalc = KPMCollisionCalculator(\n    kpm,\n    inert_species = [\"N#N\"],\n    steric_factor = :basic,\n    uncertainty = false,\n    k_max = 1e12\n)\nsetup_network!(sd, rd, calc)\nk = calc(; T = 300.0)","category":"page"},{"location":"tutorials/ode-solution/#ODE-Solution","page":"ODE Solution","title":"ODE Solution","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"mkpath(\"../assets/tutorials/ode_solution\")","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Kinetic simulations of generated CRNs are a key part of the Kinetica workflow. Aside from enabling computational insight into long-timescale chemical degradation processes through integration of species concentrations with time, they also allow for directed exploration of chemical reaction space (see Iterative CRN Exploration).","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"As such, the efficiency of these simulations is paramount within Kinetica. Aside from building the infrastructure for these simulations on top of extensible, performant Julia packages such as Catalyst.jl, ModelingToolkit.jl and DifferentialEquations.jl, we implement a number of optimisations that make repeated long-timescale simulations possible.","category":"page"},{"location":"tutorials/ode-solution/#Kinetic-Simulation-Basics","page":"ODE Solution","title":"Kinetic Simulation Basics","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Within Kinetica, what we refer to as a 'kinetic simulation' broadly consists of 3 steps:","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"A calculator setup stage, where the chosen kinetic calculator (see section on Kinetic Calculators for further information) is prepared to calculate rate constants on the given CRN.\nConversion of a Kinetica CRN into a system of ODEs that can be integrated with time by the selected ODE solver.\nIntegration of species concentrations over the selected timespan. Depending on how the simulation is formulated, this may include simulataneous integration of experimental conditions and reaction rate constants with time.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"This tutorial will focus on steps 2-3, as Kinetica presents many methods of creating symbolic systems of ODEs and integrating them with time which can be more or less effective given the simulation problem at hand.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"In order to demonstrate how these methods work, we start by considering a simple CRN:","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"A undersetk_-1stackrelk_1rightleftharpoons B + C \nB undersetk_-2stackrelk_2rightleftharpoons D \nC + D undersetk_-3stackrelk_3rightleftharpoons E","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"where A, B, C, D and E are chemical species, and k_1, k_-1 etc. are forward and reverse rate constants for the 3 reactions connecting them.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Assuming these rate constants are static parameters for the duration of a kinetic simulation, Catalyst.jl can be used to convert this CRN into a symbolic ModelingToolkit.jl ODESystem containing the following ODEs:","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"beginsplit\n    fracmathrmd Aleft( t right)mathrmdt  = - k_1 Aleft( t right) + k_- 1 Bleft( t right) Cleft( t right) \n    fracmathrmd Bleft( t right)mathrmdt  = k_1 Aleft( t right) + k_- 2 Dleft( t right) - k_2 Bleft( t right) - k_- 1 Bleft( t right) Cleft( t right) \n    fracmathrmd Cleft( t right)mathrmdt  = k_1 Aleft( t right) + k_- 3 Eleft( t right) - k_- 1 Bleft( t right) Cleft( t right) - k_3 Cleft( t right) Dleft( t right) \n    fracmathrmd Dleft( t right)mathrmdt  = k_2 Bleft( t right) + k_- 3 Eleft( t right) - k_- 2 Dleft( t right) - k_3 Cleft( t right) Dleft( t right) \n    fracmathrmd Eleft( t right)mathrmdt  = - k_- 3 Eleft( t right) + k_3 Cleft( t right) Dleft( t right)\nendsplit","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"This ODESystem can be passed to DifferentialEquations.jl to be integrated over a given timespan. For many CRNs under static experimental conditions, this process is made simple by these packages. ","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"However, when experimental conditions need to vary - almost a certainty over long real-world timescales - this process becomes more difficult as reaction rate constants must also vary with these experimental conditions. The rate constants in the above system of ODEs therefore become symbolic variables rather than parameters and the variable conditions must also be included, forming a much larger system of differential algebraic equations (DAEs):","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"beginsplit\n    fracmathrmd Aleft( t right)mathrmdt  = - k_1left( T right) Aleft( t right) + k_- 1left( T right) Bleft( t right) Cleft( t right) \n    fracmathrmd Bleft( t right)mathrmdt  = k_1left( T right) Aleft( t right) + k_- 2left( T right) Dleft( t right) - k_2left( T right) Bleft( t right) - k_- 1left( T right) Bleft( t right) Cleft( t right) \n    fracmathrmd Cleft( t right)mathrmdt  = k_1left( T right) Aleft( t right) + k_- 3left( T right) Eleft( t right) - k_- 1left( T right) Bleft( t right) Cleft( t right) - k_3left( T right) Cleft( t right) Dleft( t right) \n    fracmathrmd Dleft( t right)mathrmdt  = k_2left( T right) Bleft( t right) + k_- 3left( T right) Eleft( t right) - k_- 2left( T right) Dleft( t right) - k_3left( T right) Cleft( t right) Dleft( t right) \n    fracmathrmd Eleft( t right)mathrmdt  = - k_- 3left( T right) Eleft( t right) + k_3left( T right) Cleft( t right) Dleft( t right) \n    fracmathrmd Tleft( t right)mathrmdt  = textttget_profile(conditions T) \n    fracmathrmd Pleft( t right)mathrmdt  = textttget_profile(conditions P) \n    k_1left( T right)  = A_1 expleft  -fracE_a 1k_BTleft(tright) right  \n    k_-1left( T right)  = A_-1 expleft  -fracE_a -1k_BTleft(tright) right  \n    k_2left( T right)  = A_2 expleft  -fracE_a 2k_BTleft(tright) right  \n    k_-2left( T right)  = A_-2 expleft  -fracE_a -2k_BTleft(tright) right  \n    k_3left( T right)  = A_3 expleft  -fracE_a 3k_BTleft(tright) right  \n    k_-3left( T right)  = A_-3 expleft  -fracE_a -3k_BTleft(tright) right  \nendsplit","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"This system of DAEs is computationally challenging to solve, so we convert it back to an ODESystem by substituting the expressions for the variable rate constants back into each species' ODE. For example, the ODE for the concentration of species A becomes:","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"fracmathrmd Aleft( t right)mathrmdt = - A_1 expleft  -fracE_a 1k_BTleft(tright) right  Aleft( t right) + A_-1 expleft  -fracE_a -1k_BTleft(tright) right  Bleft( t right) Cleft( t right)","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"With the full ODESystem expanded in this way, ModelingToolkit can be used to create a sparse analytic Jacobian and a CRN can be quickly and efficiently integrated with time under variable experimental conditions. This represents what Kinetica calls (for reasons that will become apparrent soon) the complete-time continuously variable rate constant method of kinetic simulation.","category":"page"},{"location":"tutorials/ode-solution/#Chunkwise-Simulation","page":"ODE Solution","title":"Chunkwise Simulation","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Tackling long-timescale simulations with the approach above presents an interesting challenge. When reactions are occurring very quickly (under high temperatures and/or high pressures, for example) and rate constants are very large, ODE solvers capable of adaptive timestepping usually reduce their timesteps to correctly resolve the changes in species concentrations. Within short-timescale simulations where the length of the simulation is only a few orders of magnitude higher than these rate constants, there are no problems. However once we move to longer-timescale simulations, we run into floating point underflow.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"More specifically, once a timestep is complete, the solver adds the timestep to the global simulation time (GST). If the timestep is so small in comparison to the GST that addition to it does not change the GST, underflow occurs. Sometimes this is subtle, as we believe that in edge cases, Julia makes use of extended precision operations which can perform this addition without underflow, albeit less efficiently than a corresponding Float64 addition.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"However, relying on extended precision calculations can lead to unexpected failures, so we instead recommend enabling chunkwise simulations within Kinetica. This is a technique that splits the global simulation timescale into local chunks of time, each of length tau_c (set by ODESimulationParams.solve_chunkstep). By running back-to-back short simulations where local simulation time (LST) underflow is guaranteed not to occur and accumulating GST separately, we can avoid any underflow and not have to rely on extended precision operations.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Chunkwise-time kinetic simulations are enabled/disabled within the ODESimulationParams parameter block. For further discussion on implementation and necessity, see the section on Implemetation Details - Chunkwise Time.","category":"page"},{"location":"tutorials/ode-solution/#Discretely-Variable-Kinetics","page":"ODE Solution","title":"Discretely Variable Kinetics","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"While the continuously variable rate constant method of kinetic simulation (both in its complete-time and chunkwise-time forms) works for small CRNs, the computational cost of substituting variable rate constants into the ODESystem and creating a sparse analytical Jacobian of the expanded system scales poorly with CRN size. Imagine the system of ODEs needed to describe a CRN with hundreds of species and thousands of reactions, each with their own expanded rate constant! ","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"The continuous formalism is also limited in the range of rate constants that can be used. Since each rate constant must be mathematically embedded within the ODEs it occurs in, rate constants must be expressible purely as functions of experimental conditions (i.e. a quantity that can go in a ConditionSet), with any other quantities precalculated and compiled into these functions during ODESystem compilation. This limits both the level of theory and the level of computation that can occur, as more complicated rate expressions and rate constant calculations based on external programs cannot be used.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Kinetica includes a discrete approximation to continuously variable rate constants that can circumvent both of these issues. It does this by only compiling a cheap static kinetic ODESystem (i.e. one where each rate constant is a single numeric parameter rather than a variable expression) and precalculating all values of the rate constant at times separated by a rate update timestep tau_r. During kinetic simulation, Kinetica discretely updates every rate constant at every tau_r along the GST using DifferentialEquations' callback library. By setting a small enough tau_r, the continuous formalism result can be recovered.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"The discretely variable rate constant method of kinetic simulation has been shown to produce results that are almost indistinguishable from the continuous formalism, while achieving significantly faster compilation and even speeding up ODE solution (see the original Kinetica paper). It is also compatible with the chunkwise time simulations described above, allowing for fast and flexible long-timescale simulations of very large CRNs. ","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Unlike chunkwise simulations, this method is not enabled within the main ODESimulationParams block - instead, it is activated by setting the ts_update keyword argument when constructing a simulation's ConditionSet. This is because each variable condition profile has to know when rate constant updates are going to happen in advance so it can intelligently create arrays of time points to update rate constants at, only where a profile is actually varying. This avoids unnecessary rate constant updates to maintain simulation efficiency. For more information, see the tutorial on Arbitrary Simulation Conditions.","category":"page"},{"location":"tutorials/ode-solution/#Method-Summary","page":"ODE Solution","title":"Method Summary","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Depending on the input parameters used, there are currently 6 methods of the solve_network function that can be triggered. These are outlined below:","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"<table>\n  <tbody>\n    <tr>\n      <th>Kinetics</th>\n      <th>Timestepping</th>\n      <th>Rate Updates</th>\n      <th>Enabled By</th>\n      <th>Uses</th>\n    </tr>\n    <tr>\n      <td>Static</td>\n      <td>Complete</td>\n      <td>N/A</td>\n      <td>\n        <ul>\n          <li>Static conditions only</li>\n          <li><code>solve_chunks=false</code></li>\n        </ul>\n      </td>\n      <td>Very short-timescale simulations where conditions are constant</td>\n    </tr>\n    <tr>\n      <td>Static</td>\n      <td>Chunkwise</td>\n      <td>N/A</td>\n      <td>\n        <ul>\n          <li>Static conditions only</li>\n          <li><code>solve_chunks=true</code></li>\n        </ul>\n      </td>\n      <td>Long-timescale and/or high-rate simulations where conditions are constant</td>\n    </tr>\n    <tr>\n      <td>Variable</td>\n      <td>Complete</td>\n      <td>Continuous</td>\n      <td>\n        <ul>\n          <li>Mixed static/variable conditions</li>\n          <li><code>solve_chunks=false</code></li>\n          <li><code>ConditionSet</code> <b>without</b> <code>ts_update</code> set</li>\n        </ul>\n      </td>\n      <td>Repeated short-timescale simulations of small CRNs under variable conditions</td>\n    </tr>\n    <tr>\n      <td>Variable</td>\n      <td>Complete</td>\n      <td>Discrete</td>\n      <td>\n        <ul>\n          <li>Mixed static/variable conditions</li>\n          <li><code>solve_chunks=false</code></li>\n          <li><code>ConditionSet</code> <b>with</b> <code>ts_update</code> set</li>\n        </ul>\n      </td>\n      <td>Single short-timescale simulations of large CRNs under variable conditions</td>\n    </tr>\n    <tr>\n      <td>Variable</td>\n      <td>Chunkwise</td>\n      <td>Continuous</td>\n      <td>\n        <ul>\n          <li>Mixed static/variable conditions</li>\n          <li><code>solve_chunks=true</code></li>\n          <li><code>ConditionSet</code> <b>without</b> <code>ts_update</code> set</li>\n        </ul>\n      </td>\n      <td>Repeated long-timescale simulations of small CRNs under variable conditions</td>\n    </tr>\n    <tr>\n      <td>Variable</td>\n      <td>Chunkwise</td>\n      <td>Discrete</td>\n      <td>\n        <ul>\n          <li>Mixed static/variable conditions</li>\n          <li><code>solve_chunks=true</code></li>\n          <li><code>ConditionSet</code> <b>with</b> <code>ts_update</code> set</li>\n        </ul>\n      </td>\n      <td>Single long-timescale simulations of small CRNs under variable conditions</td>\n    </tr>\n  </tbody>\n</table>","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"note: Repeated simulations\nIt may be desirable to perform ensemble simulations on a CRN (e.g. with slightly different rate constants). In some cases, the increased compilation cost of the continuous rate update method may be preferable if the CRN being simulated is solved faster with this method than the discrete rate update method, as the CRN may only have to be compiled once and can then be rerun many times. While the underlying DifferentialEquations integrator object can be returned by calling solve_network with return_integrator=true, ensemble calculations are not currently implemented by Kinetica and this exercise is left up to the user. For most other calculations, the discrete rate update method should always be preferred.","category":"page"},{"location":"tutorials/ode-solution/#Running-Kinetic-Simulations","page":"ODE Solution","title":"Running Kinetic Simulations","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"In Getting Started, we demonstrated an example workflow for generating a CRN and running a kinetic simulation on it by creating a number of parameter blocks and passing them to the explore_network function. While this is useful for CRNs that are being explored, kinetic simulations can also be performed independently of exploration, e.g. when a CRN has already been explored.","category":"page"},{"location":"tutorials/ode-solution/#Parameters","page":"ODE Solution","title":"Parameters","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"As with the original tutorial, running a kinetic simulation will require an ODESimulationParams parameter block (see the Solving API page for full documentation). As noted in Getting Started, the first 3 parameters of this block are essential to any kinetic simulation, while the rest have default values and are optional. Nevertheless, these optional parameters are of vital importance to the performance and efficiency of many kinetic simulations:","category":"page"},{"location":"tutorials/ode-solution/#do_jac-and-do_sparse","page":"ODE Solution","title":"do_jac and do_sparse","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"These parameters tell ModelingToolkit whether to generate a symbolic analytical Jacobian and automatically detect its sparsity pattern. Enabling these options (default) can significantly speed up kinetic simulations by eliminating the solver's use of numerical derivatives and allowing for sparse matrix operations. See the ModelingToolkit documentation for more information.","category":"page"},{"location":"tutorials/ode-solution/#abstol-and-reltol","page":"ODE Solution","title":"abstol and reltol","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"These control the absolute/relative tolerances of the ODE solver. These can be reduced to increase the accuracy of the resulting solution at the cost of solution time, as more timesteps will be taken.","category":"page"},{"location":"tutorials/ode-solution/#adaptive_tols-and-update_tols","page":"ODE Solution","title":"adaptive_tols and update_tols","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"These control Kinetica's adaptive solver tolerance optimisation. See the section on Implementation Details - Adaptive Solver Tolerance for more information.","category":"page"},{"location":"tutorials/ode-solution/#solve_chunks-and-solve_chunkstep","page":"ODE Solution","title":"solve_chunks and solve_chunkstep","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"These control Kinetica's chunkwise ODE solution optimisation. See the section above on Chunkwise Simulation for more information.","category":"page"},{"location":"tutorials/ode-solution/#maxiters","page":"ODE Solution","title":"maxiters","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"This parameter allows for more ODE solver iterations to be used when required. This sometimes needs to be increased when performing very long timescale simulations with challenging (high rate) experimental conditions that require many timesteps.","category":"page"},{"location":"tutorials/ode-solution/#ban_negatives","page":"ODE Solution","title":"ban_negatives","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Enabling this forces the ODE solver to reject steps when any species concentrations fall below zero. In most cases, reducing solver tolerances to increase solution accuracy should be preferred.","category":"page"},{"location":"tutorials/ode-solution/#progress","page":"ODE Solution","title":"progress","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Enabling this allows for showing a progress bar during ODE solution. See the tutorial on Logging for more details.","category":"page"},{"location":"tutorials/ode-solution/#save_interval","page":"ODE Solution","title":"save_interval","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"This allows for controlling how often the ODE solver saves species concentrations. While this defaults to saving species concentrations at every timestep (save_interval=nothing), this can lead to high memory consumption and disk space usage during/after long-timescale simulations where many timesteps are taken.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"warning: Set a save interval!\nWhile saving species concentrations at every timestep may be possible within short simulations of small CRNs, save_interval should generally be set to the smallest temporal feature that is required to be analysed in order to not incur large memory costs.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"warning: Saving with chunkwise time\nWhen solve_chunks=true, this parameter behaves slightly differently. If left empty, species concentrations will be saved at the start and end of every chunk. If given a numeric value, this will be interpreted as a value within the local timescale 0.0:save_interval:solve_chunkstep, so providing a value larger than solve_chunkstep will cause nothing to be saved. See the section on Implemetation Details - Chunkwise Time for further details.","category":"page"},{"location":"tutorials/ode-solution/#low_k_cutoff","page":"ODE Solution","title":"low_k_cutoff","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"This parameter allows Kinetica to automatically remove reactions with low rate constants from a CRN, optimising CRN compilation and solution. It defaults to low_k_cutoff=:auto, which selects a conservative value for the minimum rate constant which ensures that only reactions which could never contribute to the current kinetic simulation are removed. ","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"If a numeric value is provided, this is used as the minimum rate constant below which reactions are removed from the CRN. If low_k_cutoff=:none, this behaviour is disabled and no reactions are removed from the CRN. See the section on Implementation Details - Removing Low-Rate Reactions","category":"page"},{"location":"tutorials/ode-solution/#allow_short_u0","page":"ODE Solution","title":"allow_short_u0","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"This parameter allows a vector-valued u0 (as opposed to a Dict-based `u0 shown in previous tutorials) to be shorter than the number of reactions in the current CRN. This can be useful when CRNs are being extended with species that are guaranteed to not exist at the start of a kinetic simulation.","category":"page"},{"location":"tutorials/ode-solution/#Example","page":"ODE Solution","title":"Example","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"We will start by loading in the results from Getting Started and extracting the underlying CRN. For more information on loading saved CRNs, see Saving & Loading.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"using Kinetica\n\nres = load_output(\"../my_CRN_out/direct_network_final.bson\")\nsd, rd = res.sd, res.rd\nnothing # hide","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"note: CRN Representation\nsd and rd above are instances of SpeciesData and RxData respectively. These are the major components of CRNs within Kinetica, and are required for running kinetic simulations - you might not normally see them if you are running explore_network, but they're part of the saved output so that CRNs can be reconstructed once an exploration is complete. For further information, see the section on CRN Representation.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Let's construct another set of parameters for running a kinetic simulation on this CRN. This time, we'll use a different variable temperature profile, and we'll enable the discrete rate update method to speed up ODESystem compilation.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"conditions = ConditionSet(Dict(\n    :T => DoubleRampGradientProfile(;\n        X_start = 500.0,\n        t_start_plateau = 1.0,\n        rate1 = 20.0,\n        X_mid = 1200.0,\n        t_mid_plateau = 3.0,\n        rate2 = -25.0,\n        X_end = 500.0,\n        t_end_plateau = 5.0,\n        t_blend = 0.5\n    )),\n    ts_update = tconvert(1, \"ms\", \"s\")\n)\n\nusing Sundials\n\npars = ODESimulationParams(\n    tspan = (0.0, get_t_final(conditions)),\n    u0 = Dict(\"C\" => 1.0),\n    solver = CVODE_BDF(; linear_solver=:KLU),\n    solve_chunkstep = tconvert(10, \"ms\", \"s\"),\n    save_interval = tconvert(5, \"ms\", \"s\")\n)","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Here we've specified that the rate update timestep tau_r should be 1 ms - that is, all rate constants should be precalculated at 1 ms intervals while the temperature is changing, and should then be discretely updated at these time points during kinetic simulation. We've also specified that the solution chunk length tau_c should be 10 ms, and that the final solution should be saved every 5 ms, as this will be a longer simulation and saving species concentrations at every timestep could become quite expensive.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"We'll set up the kinetic calculator in the same way as before:","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"using BSON\ncalc_pars = BSON.load(\"../../../examples/getting_started/arrhenius_params.bson\")\ncalc = PrecalculatedArrheniusCalculator(calc_pars[:Ea], calc_pars[:A]; k_max=1e12)","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Now all that's left is to run the simulation. This can be achieved with solve_network:","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"solvemethod = VariableODESolve(pars, conditions, calc)\nres = solve_network(solvemethod, sd, rd)\nnothing # hide","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"note: Under the hood\nWhen you called explore_network beforehand to explore and solve a CRN, the solution was actually being handled by solve_network in exactly the same way as above!","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"As before, we can see what this kinetic simulation was doing by plotting from the ODESolveOutput object res:","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"using Plots\nplot(res)\nsavefig(\"../assets/tutorials/ode_solution/kinetics_plot.svg\"); nothing # hide","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"(Image: )","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Again, we can also inspect the simulation's temperature profile:","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"conditionsplot(res, :T)\nsavefig(\"../assets/tutorials/ode_solution/temperature_plot.svg\"); nothing # hide","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"(Image: )","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"This same methodology can be applied to any CRN under any compatible conditions.","category":"page"},{"location":"tutorials/results-analysis/#Results-Analysis","page":"Results Analysis","title":"Results Analysis","text":"","category":"section"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"mkpath(\"../assets/tutorials/results_analysis\")\nusing Random\nRandom.seed!(12345)","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"Upon completion of a kinetic simulation run by solve_network (or through the end of a CRN exploration using explore_network, which also calls this function), Kinetica returns an ODESolveOutput object. This binds together the CRN that this simulation was run on (after modifications such as those described in Filtering CRNs and Removing Low-Rate Reactions), the parameters the simulation was run with, and the simulation's results. This data can be used for analysing the results of a kinetic simulation.","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"We will demonstrate this analysis using the results of the CRN we generated and simulated in Getting Started:","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"using Kinetica, Plots\nres = load_output(\"../my_CRN_out/direct_network_final.bson\")\nnothing # hide","category":"page"},{"location":"tutorials/results-analysis/#Analysing-the-CRN","page":"Results Analysis","title":"Analysing the CRN","text":"","category":"section"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"The output CRN is stored across two data structures: a SpeciesData for holding information about the species within the CRN, and a RxData for holding information about the reactions between those species. These can be accessed through ODESolveOutput.sd and ODESolveOutput.rd respectively. For more information on these objects, see CRN Representation.","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"sd, rd = res.sd, res.rd\nnothing # hide","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"By default, Kinetica stores information about these species and reactions in a compact form to maintain efficiency when working with large CRNs. For example, reactions are stored as Vectors of integer species IDs. To inspect individual reactions, we can use the print_rxn function:","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"# Print the first reaction in the CRN.\nprint_rxn(sd, rd, 1)\nnothing # hide","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"note: Using format_rxn\nprint_rxn is just a wrapper to print the string returned by format_rxn, which uses the reactants/products and stoichiometries in rd and the species SMILES in sd to generate a human-readable string describing a reaction. If you need to print more information alongside a reaction, consider something like println(\"$(format_rxn(sd, rd, rid)): $(extra_data[rid])\").","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"The total number of reactions in a CRN is stored in RxData.nr, so printing all of the reactions in a CRN is as simple as this loop:","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"for i in 1:rd.nr\n    print_rxn(sd, rd, i)\nend\nnothing # hide","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"Other fields of RxData can also be useful for analysis, such as RxData.mapped_rxns. This field contains the atom-mapped reaction SMILES of all reactions in a CRN, and can be used for constructing multi-species reactant and product geometries with consistent atom indeces (vital for any reaction path techniques):","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"println(\"Atom-mapped reaction SMILES: $(rd.mapped_rxns[1])\\n\")\n\n# Split reaction SMILES into individual SMILES for reactants/products.\nam_reacs, am_prods = String.(split(rd.mapped_rxns[1], \">>\"))\n\n# Generate non-overlapping systems of molecules for reactants and products.\nreac_species = [sd.toStr[sid] for sid in rd.id_reacs[1]]\nreacsys = system_from_smiles(reac_species; dmin=3.0)\nprod_species = [sd.toStr[sid] for sid in rd.id_prods[1]]\nprodsys = system_from_smiles(prod_species; dmin=3.0)\n\n# Remap atom indeces using atom-mapped SMILES and RDKit substructure matching.\nmapped_reacs = atom_map_frame(am_reacs, reacsys)\nmapped_prods = atom_map_frame(am_prods, prodsys)\n\n# Add extra info to frames, convert to ExtXYZ and print.\nmapped_reacs[\"info\"][\"type\"] = \"reactant\"\nmapped_reacs[\"info\"][\"SMILES\"] = join(sort(reac_species), \".\")\nmapped_prods[\"info\"][\"type\"] = \"product\"\nmapped_prods[\"info\"][\"SMILES\"] = join(sort(prod_species), \".\")\nprintln(\"Reaction XYZ:\")\nprint(frame_to_xyz(mapped_reacs))\nprint(frame_to_xyz(mapped_prods))","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"As a result of the atom mapping, the hydrogen atoms which dissociate from the reactant ethane are now consistently indexed between reactant and product geometries.","category":"page"},{"location":"tutorials/results-analysis/#Species-Analysis","page":"Results Analysis","title":"Species Analysis","text":"","category":"section"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"Kinetica makes use of many functions within both RDKit and Open Babel to assist with basic property prediction and conversion between geometry and SMILES. A comprehensive list of functions implemented are available in the Open Babel and RDKit API pages.","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"Kinetica supports cached calculation of properties such as species molecular weights and hard-sphere radii through Open Babel through the get_species_stats! function. This places these properties in the SpeciesData.cache, which is useful for storing per-species values during a calculation.","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"Kinetica also stores species geometries within SpeciesData.xyz. These are stored as ExtXYZ.jl frames and can be manipulated as such.","category":"page"},{"location":"tutorials/results-analysis/#Analysing-the-Kinetic-Simulation","page":"Results Analysis","title":"Analysing the Kinetic Simulation","text":"","category":"section"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"Most of the information regarding the results of a kinetic simulation are stored in ODESolveOutput.sol, which is a DifferentialEquations ODESolution (in most cases, some extensions may apply depending on the simulation method but this can always be interacted as if it is an ODESolution). As such, the DiffEq documentation applies for directly analysing simulation results.","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"However, when plotting simulation results, it can often be useful to have information about the experimental conditions that the simulation took place under, as well as some of the other parameters used in the simulation which are not included within the ODESolution. This includes the names of each of the species, which are only referred to be an integer ID within Kinetica's solution methods. Kinetica therefore includes Plots.jl plot recipes which act on the ODESolveOutput object, as this has access to all of these values alongside the ODESolution. The plots created by these recipes can be modified in the same way as any other Plots.jl figure.","category":"page"},{"location":"tutorials/results-analysis/#Concentration-Time-Plots","page":"Results Analysis","title":"Concentration-Time Plots","text":"","category":"section"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"This is the 'default' plot type for ODESolveOutput, with the call signature:","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"plot(::ODESolveOutput; tunit=\"s\", label_above=0.1, ignore_species=nothing, ignore_below=nothing)","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"where","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"tunit is the unit of time to display on the x-axis;\nlabel_above is a concentration above which species should contribute to the plot's legend and be plotted in a colour (species is grey otherwise);\nignore_species can be a Vector of SMILES strings representing species which should not be plotted (nothing if this is not desired);\nignore_below can be a concentration threshold where species with a maximum concentration below are not plotted (nothing if this is not desired).","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"For example, plotting the same results as in Getting Started, but excluding the radical species from the plot is simple:","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"is_radical(smi) = ('[' in smi) && !(smi == \"[H][H]\")\nradical_species = [spec for spec in [sd.toStr[i] for i in 1:sd.n] if is_radical(spec)]\n\nplot(res; label_above=0.01, ignore_species=radical_species, linewidth=5)\nsavefig(\"../assets/tutorials/results_analysis/kinetics_plot.svg\"); nothing # hide","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"(Image: )","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"note: Using Plots.jl Arguments\nNotice how we've used the linewidth keyword argument here, but this isn't defined explicitly in this plot recipe. This is because Plots.jl allows for modifying figures, both within the original plot call and in subsequent plot! calls - we could've similarly done plot!(linewidth=5) after our original plot call to achieve the same goal.","category":"page"},{"location":"tutorials/results-analysis/#Conditions-Plots","page":"Results Analysis","title":"Conditions Plots","text":"","category":"section"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"Kinetica defines a separate plot recipe for variable condition profiles, conditionsplot:","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"conditionsplot(::Union{::ODESolveOutput, ConditionSet}, ::Symbol; tunit=\"s\")","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"This recipe can take either an ODESolveOutput or a ConditionSet, but it has a second mandatory argument - a Symbol representing the condition profile to plot. For example, if a variable temperature profile is required (and it exists in the ConditionSet being plotted), then this is usually available under :T. Again, tunit is the unit of time to display on the x-axis.","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"# Again, this is compatible with Plots.jl keyword arguments.\nconditionsplot(res, :T; linecolor=:red)\nsavefig(\"../assets/tutorials/results_analysis/temperature_plot.svg\"); nothing # hide","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"(Image: )","category":"page"},{"location":"tutorials/results-analysis/#Final-Concentration-Plots","page":"Results Analysis","title":"Final Concentration Plots","text":"","category":"section"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"It can often be useful to examine the final species concentrations at the end of a kinetic simulation, as these often correspond to experimental observables. Kinetica implements a specialised bar chart recipe for this, finalconcplot:","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"finalconcplot(::ODESolveOutput; \n              quantity=:conc, n_top=10, highlight_radicals=false, \n              ignore_species=nothing, xscale=:identity)","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"where","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"quantity is a Symbol, either :conc or :percent. The former plots species concentrations, while the latter plots percentage concentrations with respect to the overall reaction mixture;\nn_top controls the number of species to include in the plot. These are sorted in decreasing order, with species outside n_top going into their own 'Others' bar at the end. For example, with n_top=10, the 10 species with the highest final concentrations will be plotted, followed by a bar for the combined final concentration of all other species;\nhighlight_radicals colours radical species in red when true, as these are often not desired at the end of simulations;\nignore_species accepts a Vector of SMILES strings for species to exclude from the plot. This can be useful when inert species are present with concentrations that are unimportant to the final state of the CRN (nothing if this is not desired);\nxscale mimics Plots.jl's xscale option for setting the scaling of the x-axis. In this case, only :identity (default) and :log10 are supported, as additional calculations are required to obtain the correct x-axis limits for correct bar chart rendering.","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"finalconcplot(res; quantity=:percent, n_top=5, highlight_radicals=true)\nsavefig(\"../assets/tutorials/results_analysis/concs_plot.svg\"); nothing # hide","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"(Image: )","category":"page"},{"location":"api/kinetica/conditions/#Kinetica.jl-API","page":"Conditions","title":"Kinetica.jl API","text":"","category":"section"},{"location":"api/kinetica/conditions/#Conditions","page":"Conditions","title":"Conditions","text":"","category":"section"},{"location":"api/kinetica/conditions/#ConditionSet","page":"Conditions","title":"ConditionSet","text":"","category":"section"},{"location":"api/kinetica/conditions/","page":"Conditions","title":"Conditions","text":"ConditionSet\nConditionSet(::Dict{Symbol, <:Any})\nget_profile(::ConditionSet, ::Symbol)\nKinetica.get_initial_conditions(::ConditionSet)\nisstatic\nisvariable\nget_tstops(::ConditionSet)\nget_t_final(::ConditionSet)\nsolve_variable_conditions!","category":"page"},{"location":"api/kinetica/conditions/#Kinetica.ConditionSet","page":"Conditions","title":"Kinetica.ConditionSet","text":"Container for all conditions in a kinetic simulation.\n\nConditions can be static or variable, and variable conditions can be gradient-based or directly usable.\n\nContains fields for:\n\nSymbolic representation of conditions (symbols)\nCondition profile for each symbol (profiles)\nWhether discrete rate constant updates are enabled for the conditions in this condition set (discrete_updates)\nDiscrete rate constant update timestep, is nothing if discrete_updates = false (ts_update)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/conditions/#Kinetica.ConditionSet-Tuple{Dict{Symbol}}","page":"Conditions","title":"Kinetica.ConditionSet","text":"conditions = ConditionSet(Dict(\n    :C1 => ConditionType1(...),\n    :C2 => ConditionType2(...))\n    [, ts_update]\n))\n\nOuter constructor for ConditionSet..\n\nSeparates condition profiles from their symbols and parses numeric profiles into StaticConditionProfiles. Registers AbstractVariableProfiles with Symbolics to allow for proper computation down the chain.\n\nIf ts_update is provided, creates tstops arrays within each variable profile for use in discrete rate update  simulations.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.get_profile-Tuple{ConditionSet, Symbol}","page":"Conditions","title":"Kinetica.get_profile","text":"profile = get_profile(cs, sym)\n\nGets the condition profile linked to sym from cs.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.get_initial_conditions-Tuple{ConditionSet}","page":"Conditions","title":"Kinetica.get_initial_conditions","text":"initial_conditions = get_initial_conditions(conditions)\n\nExtract initial conditions from ConditionSet.\n\nReturns an array of Pairs linking Symbols to initial values. For AbstractStaticProfiles, initial values are their static values. For AbstractVariableProfiles, initial values are their X_start values.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.isstatic","page":"Conditions","title":"Kinetica.isstatic","text":"isstatic(cs[, sym])\n\nDetermines if condition profiles in a ConditionSet are static.\n\nWhen a Symbol sym is provided, only checks if the profile linked to this Symbol is static. If no Symbol is provided, checks is all profiles are static.\n\nisstatic(profile)\n\nDetermines if a given condition profile is static.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/conditions/#Kinetica.isvariable","page":"Conditions","title":"Kinetica.isvariable","text":"isvariable(cs[, sym])\n\nDetermines if condition profiles in a ConditionSet are variable.\n\nWhen a Symbol sym is provided, only checks if the profile linked to this Symbol is variable. If no Symbol is provided, checks is all profiles are variable.\n\nisvariable(profile)\n\nDetermines if a given condition profile is variable.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/conditions/#Kinetica.get_tstops-Tuple{ConditionSet}","page":"Conditions","title":"Kinetica.get_tstops","text":"tstops = get_tstops(cs)\n\nRetrieves a sorted array of unique time stops from all condition profiles in cs.\n\nShould be used for passing a unified set of time stops to a discrete rate constant update solver. Will throw an error if all condition profiles are static, as they have no tstops.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.get_t_final-Tuple{ConditionSet}","page":"Conditions","title":"Kinetica.get_t_final","text":"t_final = get_t_final(cs)\n\nRetrieves the last necessary time point needed to encompass all variable condition profiles in cs.\n\nWill throw an error if all condition profiles are static, they have no set endpoints.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.solve_variable_conditions!","page":"Conditions","title":"Kinetica.solve_variable_conditions!","text":"solve_variable_conditions!(cs, pars[, reset, solver, solve_kwargs])\n\nSolves all variable condition profiles over the timespan in pars.tspan.\n\nPlaces all condition profile solutions in their sol field. In the case of AbstractDirectProfiles, this creates a DiffEqArray to mimic the regular DiffEq solver interface.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/conditions/#Static-Condition-Profiles","page":"Conditions","title":"Static Condition Profiles","text":"","category":"section"},{"location":"api/kinetica/conditions/","page":"Conditions","title":"Conditions","text":"Kinetica.StaticConditionProfile","category":"page"},{"location":"api/kinetica/conditions/#Kinetica.StaticConditionProfile","page":"Conditions","title":"Kinetica.StaticConditionProfile","text":"\n\n\n\n","category":"type"},{"location":"api/kinetica/conditions/#Directly-Variable-Condition-Profiles","page":"Conditions","title":"Directly Variable Condition Profiles","text":"","category":"section"},{"location":"api/kinetica/conditions/","page":"Conditions","title":"Conditions","text":"Kinetica.solve_variable_condition!(::Kinetica.AbstractDirectProfile, ::ODESimulationParams)\nNullDirectProfile\nNullDirectProfile()\nLinearDirectProfile\nLinearDirectProfile()","category":"page"},{"location":"api/kinetica/conditions/#Kinetica.solve_variable_condition!-Tuple{Kinetica.AbstractDirectProfile, ODESimulationParams}","page":"Conditions","title":"Kinetica.solve_variable_condition!","text":"solve_variable_condition!(profile<:AbstractDirectProfile, pars[, reset, solver, solve_kwargs])\n\nGenerates a solution for the specified directly-variable condition profile.\n\nFor profiles with direct functions, this requires calculating values for the specified pars.tspan and wrapping them within a DiffEqArray for compatibility with other interfaces (plotting, interpolation, etc.).\n\nArguments solver and solve_kwargs are provided for compatibility with callers, do nothing and should be ignored.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.NullDirectProfile","page":"Conditions","title":"Kinetica.NullDirectProfile","text":"Container for null direct profile data and condition function.\n\nThis condition profile should only be used for debugging, as it has a condition function which always returns the initial condition. If only this constant condition is  required, the regular ODESolve should always be used  instead of an ODEConditionSolve with this condition  profile.\n\nContains fields for:\n\nCondition function (f)\nInitial value of condition (X_start)\nTime to stop calculation (t_end)\nTimes for the ODE solver to ensure calculation at (tstops)\nProfile solution, constructed by call to solve_variable_condition! (sol)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/conditions/#Kinetica.NullDirectProfile-Tuple{}","page":"Conditions","title":"Kinetica.NullDirectProfile","text":"condition_profile = NullDirectProfile(; X, t_end)\n\nOuter constructor for null condition direct profile.\n\nShould only be used for testing purposes (see struct documentation).\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.LinearDirectProfile","page":"Conditions","title":"Kinetica.LinearDirectProfile","text":"Container for linear condition ramp profile data and condition function.\n\nThis condition profile represents a linear condition increase/decrease from X_start to X_end.\n\nContains fields for:\n\nCondition function (f)\nRate of change of condition (rate)\nInitial value of condition (X_start)\nFinal value of condition (X_end)\nTime to stop calculation (t_end)\nTimes for the ODE solver to ensure calculation at (tstops)\nProfile solution, constructed by call to solve_variable_condition! (sol)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/conditions/#Kinetica.LinearDirectProfile-Tuple{}","page":"Conditions","title":"Kinetica.LinearDirectProfile","text":"condition_profile = LinearDirectProfile(; rate, X_start, X_end)\n\nOuter constructor for linear condition ramp direct profile.\n\nDetermines the simulation end time from the provided conditions and rate, then constructs the condition function (which is a linear y = mx + c function).\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Gradient-Variable-Condition-Profiles","page":"Conditions","title":"Gradient-Variable Condition Profiles","text":"","category":"section"},{"location":"api/kinetica/conditions/","page":"Conditions","title":"Conditions","text":"LinearGradientProfile\nLinearGradientProfile()\nDoubleRampGradientProfile\nDoubleRampGradientProfile()","category":"page"},{"location":"api/kinetica/conditions/#Kinetica.LinearGradientProfile","page":"Conditions","title":"Kinetica.LinearGradientProfile","text":"Container for linear condition ramp profile data and condition gradient function.\n\nThis condition profile represents a linear condition increase/decrease from X_start to X_end.\n\nContains fields for:\n\nCondition gradient function (grad)\nRate of change of condition (rate)\nInitial value of condition (X_start)\nFinal value of condition (X_end)\nTime to stop calculation (t_end)\nTimes for the ODE solver to ensure calculation at (tstops)\nProfile solution, constructed by call to solve_variable_condition! (sol)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/conditions/#Kinetica.LinearGradientProfile-Tuple{}","page":"Conditions","title":"Kinetica.LinearGradientProfile","text":"condition_profile = LinearGradientProfile(; rate, X_start, X_end)\n\nOuter constructor for linear condition ramp gradient profile.\n\nDetermines the simulation end time from the provided conditions and gradient, then constructs the condition gradient function  (which returns rate for every timestep).\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.DoubleRampGradientProfile","page":"Conditions","title":"Kinetica.DoubleRampGradientProfile","text":"Container for double condition ramp profile data and condition gradient function.\n\nThis condition profile represents two condition ramps with adjustable condition plateaus before, after and in between the ramps, i.e.\n\n              ------   X_mid\n      rate1  /      \\\n            /        \\  rate2\nX_start ----          \\\n                       ----- X_end\n\nThe profile starts at X_start and maintains that value for t_start_plateau. The condition then ramps with gradient rate1 to condition value X_mid. This value is maintained for t_mid_plateau. The condition then ramps with gradient rate2 to condition value X_end. This value is maintained for t_end_plateau until the calculated time t_end.\n\nTo smooth out gradient discontinuities, a blending time t_blend can be passed to linearly interploate between plateaus and ramps, forming a smooth function of time. Larger values of t_blend yield smoother functions but decrease accuracy of the ramps, so should be used carefully.\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/conditions/#Kinetica.DoubleRampGradientProfile-Tuple{}","page":"Conditions","title":"Kinetica.DoubleRampGradientProfile","text":"condition_profile = DoubleRampGradientProfile(; X_start, t_start_plateau, rate1, X_mid, t_mid_plateau, rate2, X_end, t_end_plateau[, t_blend])\n\nOuter constructor for double condition ramp gradient profile.\n\nDetermines the simulation end time from the provided conditions and gradients, then constructs the condition gradient function  (which returns rate for every timestep).\n\nIf t_blend is passed, constructs a smooth approximation of the otherwise discontinuous gradient function.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/arbitrary-conditions/#Arbitrary-Simulation-Conditions","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"using Kinetica, Plots\nmkpath(\"../assets/tutorials/arbitrary_conditions\")\ncspars = ODESimulationParams(\n    tspan = (0.0, 10.0),\n    u0 = [0.0],\n    solver = nothing\n)","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"Alongside the modular kinetic calculator interface, the ability to pass arbitrary combinations of simulation conditions through to be used in CRN integration is one of the key elements of extensibility and customisation within Kinetica.","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"By only requiring that conditions use consistent symbolic names at their definition and within a kinetic calculator, any variable condition profile, defined either directly or by its gradient with respect to time, can be symbolically bound to any quantity of interest.","category":"page"},{"location":"tutorials/arbitrary-conditions/#[ConditionSet](@ref)","page":"Arbitrary Simulation Conditions","title":"ConditionSet","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"At the core of this system is the ConditionSet, which acts as an aggregator for individula condition profiles and their symbols. At their definition, ConditionSets take a dictionary of Symbol => Profile() mappings. Each Symbol can realistically be anything that Julia allows, but by convention (and for compatibility with most calculator implementations) we stick to the usual abbreviations for common conditions - :T for temperature, :P for pressure, :V for volume, etc. Each condition profile can be one of three options:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"A Number representing a static value for the given condition to take for the duration of the simulation. Internally this is converted into a Kinetica.StaticConditionProfile, but this is just a container for the number within.\nA directly variable condition profile, e.g. LinearDirectProfile. These are variable condition profiles where the condition is implemented directly as a function of time.\nA gradient-variable condition profile, e.g. LinearGradientProfile. These are variable condition profiles where the condition is implemented indirectly through its gradient with respect to time. These profiles must be numerically integrated (handled automtically within Kinetica) before they can be used.","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"The ConditionSet constructor takes an optional keyword argument, ts_update. If provided, this argument causes any kinetic simulations done with this ConditionSet to use the discrete rate update approximation, which is usually desired in any moderate to large-scale CRN simulations. For more information, see the tutorial on ODE Solution.","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"A ConditionSet which implements static simulation volume, linearly increasing temperature and linearly decreasing pressure with a rate constant update timestep of 1 ms could therefore look like the following:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"conditions = ConditionSet(Dict(\n    :V => 1000.0,\n    :T => LinearDirectProfile(;\n        rate = 20.0,\n        X_start = 300.0,\n        X_end = 500.0\n    ),\n    :P => LinearGradientProfile(;\n        rate = -50.0,\n        X_start = 1e5,\n        X_end = 9e4\n    )),\n    ts_update = tconvert(1.0, \"ms\", \"s\")\n)","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"note: Converting times\nBy default, Kinetica works in units of seconds (this can be changed within the kinetic calculator being used). While the conversion above may be a bit redundant, the tconvert function can be used to quickly convert between commonly used time units.","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"warning: Discrete Rate Approximation Behaviour\nThe behaviour of the ts_update argument is subject to change in the near future. This will likely not be a dramatic change, but it may be worth bearing in mind.","category":"page"},{"location":"tutorials/arbitrary-conditions/#Useful-Functions","page":"Arbitrary Simulation Conditions","title":"Useful Functions","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"Once constructed, ConditionSets can be queried in a number of ways. To fetch any of the profiles within, get_profile can be called:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"get_profile(conditions, :T)","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"To test if a given condition is static or variable, the isstatic and isvariable funcitons can be called:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"println(\"Temperature profile is static: $(isstatic(conditions, :T))\")\nprintln(\"Pressure profile is variable: $(isvariable(conditions, :P))\")","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"To get the final time at which all condition profiles have stopped varying, get_t_final can be called. This returns the maximum value of each condition profile's t_end attribute (see below):","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"get_t_final(conditions)","category":"page"},{"location":"tutorials/arbitrary-conditions/#Condition-Profile-Showcase","page":"Arbitrary Simulation Conditions","title":"Condition Profile Showcase","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"Below are the currently implemented variable condition profiles, along with examples of their shapes. Condition profiles are being added as we need them, so this library is currently quite small. You can help us out by adding new profiles and submitting a pull request (see the Development section on Condition Profiles), or by requesting them to be added on our Issues page!","category":"page"},{"location":"tutorials/arbitrary-conditions/#Directly-Variable-Condition-Profiles","page":"Arbitrary Simulation Conditions","title":"Directly Variable Condition Profiles","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/#[LinearDirectProfile](@ref)","page":"Arbitrary Simulation Conditions","title":"LinearDirectProfile","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"This profile represents a linear change from one value to another. It has a piecewise linear condition function, defined as follows for the arbitrary condition X:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"Xleft( t right) = \n    begincases\n        textttX_start  textif  t leq 00 \n        textttX_start + tleft( textttrate right)  textif  t  00 text and  t leq t_textend \n        textttX_end  textif  t  t_textend \n    endcases","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"where t_textend = left( textttX_end - textttX_start right)  textttrate. For example:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"# This is not being run in an example block with lines hidden because there\n# is seemingly no way of not having any kind of return block, and redefining\n# the functions within profiles prints to stderr, which is returned when the\n# example returns nothing.\ncs = ConditionSet(Dict(\n    :T => LinearDirectProfile(;\n        X_start = 300.0,\n        X_end = 500.0,\n        rate=20.0)\n))\ncspars.tspan = (0.0, get_t_final(cs))\nsolve_variable_conditions!(cs, cspars)\nplot(get_profile(cs, :T).sol, label=\"T\", xlabel=\"t\")\nsavefig(\"../assets/tutorials/arbitrary_conditions/lineardirectprofile.svg\")","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"cs = ConditionSet(Dict(\n    :T => LinearDirectProfile(;\n        X_start = 300.0,\n        X_end = 500.0,\n        rate=20.0)\n))","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"(Image: )","category":"page"},{"location":"tutorials/arbitrary-conditions/#Gradient-Variable-Condition-Profiles","page":"Arbitrary Simulation Conditions","title":"Gradient-Variable Condition Profiles","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/#[LinearGradientProfile](@ref)","page":"Arbitrary Simulation Conditions","title":"LinearGradientProfile","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"The gradient-based implementation of LinearDirectProfile. Either can be used, they should be equally accurate. Mostly serves as an example of how gradient profiles differ in implementation to their directly variable counterparts. It has a piecewise linear gradient function, defined as follows for the arbitrary condition X:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"fracmathrmd Xleft( t right)mathrmdt = \n    begincases\n        00  textif  t leq 00 \n        textttrate  textif  t  00 text and  t leq t_textend \n        00  textif  t  t_textend \n    endcases","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"where t_textend = left( textttX_end - textttX_start right)  textttrate. For example:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"cs = ConditionSet(Dict(\n    :P => LinearGradientProfile(;\n        X_start = 1e5,\n        X_end = 9e4,\n        rate=-50.0)\n))\ncspars.tspan = (0.0, get_t_final(cs))\nsolve_variable_conditions!(cs, cspars)\nplot(get_profile(cs, :P).sol)\nsavefig(\"../assets/tutorials/arbitrary_conditions/lineargradientprofile.svg\")","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"cs = ConditionSet(Dict(\n    :P => LinearGradientProfile(;\n        X_start = 1e5,\n        X_end = 9e4,\n        rate=-50.0)\n))","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"(Image: )","category":"page"},{"location":"tutorials/arbitrary-conditions/#[DoubleRampGradientProfile](@ref)","page":"Arbitrary Simulation Conditions","title":"DoubleRampGradientProfile","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"This profile represents two linear condition ramps, each of which can have either a positive or a negative gradient, separated by a plateau of variable time. The profile also begins and ends with variable-length condition plateaus to enable equilibration at the initial and final values. It has a piecewise linear gradient function, defined as follows for the arbitrary condition X:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"fracmathrmd Xleft( t right)mathrmdt = \n    begincases\n        00  textif  t  t_r1 textstart \n        textttrate1  textif  t_r1 textstart leq t  t_r1 textend \n        00  textif  t_r1 textend leq t  t_r2 textstart \n        textttrate2  textif  t_r2 textstart leq t  t_r2 textend \n        00  textif  t geq t_r2 textend \n    endcases","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"where textttrate1 and textttrate2 are the rates of change of the two linear ramps, and t_r1 textstart, t_r1 textend, t_r2 textstart and t_r2 textend are the respective start- and end-times of the first and second ramps, determined by the lengths of the starting, middle and ending plateaus.","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"The profile features an optional argument t_blend, which can be used to create smooth transitions between the otherwise discontinuous gradient changes through linear interpolation. For example:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"cs = ConditionSet(Dict(\n    :K => DoubleRampGradientProfile(;\n        X_start = 100.0,\n        t_start_plateau = 3.0,\n        rate1 = 10.0,\n        X_mid = 250.0,\n        t_mid_plateau = 5.0,\n        rate2 = -25.0,\n        X_end = 50.0,\n        t_end_plateau = 10.0,\n        t_blend = 0.5)\n))\ncspars.tspan = (0.0, get_t_final(cs)) # hide\nsolve_variable_conditions!(cs, cspars) # hide\nplot(get_profile(cs, :K).sol) # hide\nsavefig(\"../assets/tutorials/arbitrary_conditions/doublerampgradientprofile.svg\"); nothing # hide","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"(Image: )","category":"page"},{"location":"api/kinetica/utilities/#Kinetica.jl-API","page":"Utilities","title":"Kinetica.jl API","text":"","category":"section"},{"location":"api/kinetica/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"api/kinetica/utilities/","page":"Utilities","title":"Utilities","text":"tconvert\nformat_rxn\nprint_rxn","category":"page"},{"location":"api/kinetica/utilities/#Kinetica.tconvert","page":"Utilities","title":"Kinetica.tconvert","text":"tconvert(t, from_unit, to_unit)\n\nConverts a time from one unit (from_unit) to another (to_unit).\n\nSupported units (with accepted abbreviations) are:\n\npicoseconds (ps)\nnanoseconds (ns)\nmicroseconds (us)\nmilliseconds (ms)\nseconds (s)\nminutes (mins)\nhours (hrs)\ndays\nmonths (mts)\nyears (yrs)\n\nWill throw an error if unsupported units are provided.\n\n\n\n\n\ntconvert(from_unit, to_unit)\n\nReturns tconvert(1.0, from_unit, to_unit).\n\nUseful for just getting a conversion factor between time units,  rather than converting a specific time directly.\n\n\n\n\n\ntconvert(t, from_unit, to_unit)\n\nConverts a vector of times from one unit (from_unit) to another (to_unit).\n\nSupported units (with accepted abbreviations) are:\n\npicoseconds (ps)\nnanoseconds (ns)\nmicroseconds (us)\nmilliseconds (ms)\nseconds (s)\nminutes (mins)\nhours (hrs)\ndays\nmonths (mts)\nyears (yrs)\n\nWill throw an error if unsupported units are provided.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/utilities/#Kinetica.format_rxn","page":"Utilities","title":"Kinetica.format_rxn","text":"format_rxn(sd, rd, rid)\n\nNicely formats a string describing the reaction at rid.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/utilities/#Kinetica.print_rxn","page":"Utilities","title":"Kinetica.print_rxn","text":"print_rxn(sd, rd, rid)\n\nPrints the reaction at ID rid with SMILES names for species.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/utilities/#Logging","page":"Utilities","title":"Logging","text":"","category":"section"},{"location":"api/kinetica/utilities/","page":"Utilities","title":"Utilities","text":"start_log\nend_log\nflush_log","category":"page"},{"location":"api/kinetica/utilities/#Kinetica.start_log","page":"Utilities","title":"Kinetica.start_log","text":"logger = start_log(logdir[, label])\n\nCreates a SimpleLogger for logging to a file in logdir.\n\nFilename of the log can be customised using label. All new logfiles will have dates attached.\n\nExample\n\n# Creates a new logfile in `logdir/MyLog_yymmdd-HHMMSS.log`\nlogger = start_log(logdir; label=\"MyLog\")\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/utilities/#Kinetica.end_log","page":"Utilities","title":"Kinetica.end_log","text":"end_log(logger)\n\nCloses the IOStream attached to logger.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/utilities/#Kinetica.flush_log","page":"Utilities","title":"Kinetica.flush_log","text":"flush_log()\n\nFlushes the IOStream attached to the currently scoped logger.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/openbabel/#Kinetica.jl-API","page":"Open Babel","title":"Kinetica.jl API","text":"","category":"section"},{"location":"api/kinetica/openbabel/#Open-Babel","page":"Open Babel","title":"Open Babel","text":"","category":"section"},{"location":"api/kinetica/openbabel/#Conversion","page":"Open Babel","title":"Conversion","text":"","category":"section"},{"location":"api/kinetica/openbabel/#Property-Calculation","page":"Open Babel","title":"Property Calculation","text":"","category":"section"},{"location":"api/kinetica/openbabel/","page":"Open Babel","title":"Open Babel","text":"get_species_stats!","category":"page"},{"location":"api/kinetica/openbabel/#Kinetica.get_species_stats!","page":"Open Babel","title":"Kinetica.get_species_stats!","text":"get_species_stats!(sd[, refresh])\n\nGets statistics about the species in sd.\n\nCalculates values for the following useful statistics, which are placed in the species data cache at sd.cache with a key for each property:\n\nAverage COM-atom radius of species (:radii)\nMolecular weight of species (:weights)\n\nOnly calculates statistics for species without defined values, unless refresh=true which causes all statistics for every species to be updated.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/rdkit/#Kinetica.jl-API","page":"RDKit","title":"Kinetica.jl API","text":"","category":"section"},{"location":"api/kinetica/rdkit/#RDKit","page":"RDKit","title":"RDKit","text":"","category":"section"},{"location":"tutorials/iterative-exploration/#Iterative-CRN-Exploration","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"","category":"section"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"The iterative CRN exploration method (IterativeExplore) allows for CRNs to be efficiently explored by only attempting to find reactions involving kinetically viable species. In the vast majority of cases, this produces CRNs with more thoroughly sampled reactions per species than the direct exploration method (DirectExplore, demonstrated in Getting Started).","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"(Image: )","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"The figure above shows the main methodological differences between the direct and iterative exploration methods. In the direct method (a), as many reactions as possible are explored outwards from a starting system of species. This is done by successive iterations of stochastic mechanism generation with CDE's single-ended graph-driven sampling (SE-GDS) method. Each random mechanism is of length n_r, controlled within Kinetica by the radius parameter in a CDE parameter block. ","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"CRNs are built by adding all new reactions from each mechanism to the current SpeciesData and RxData (see CRN Representation for details). Mechanism generation proceeds until a user-defined number of CDE iterations have passed without any new reactions being added to the CRN (controlled by the rxn_convergence_threshold parameter of DirectExplore).","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"The direct method has a number of flaws when applied to large CRNs - it is capable of simulataneously under-exploring reactions between species many reactive steps away from the starting system, and it over-explores species and reactions that may never form/occur due to the kinetics of the CRN as a whole. This is the rationale behind the iterative exploration method.","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"In the iterative method (b), exploration proceeds in levels. Each level consists of the following steps:","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"A system of species is created. CDE requires species to be input within a single XYZ file, so care must be taken to place species in cartesian space such that they are separated (not considered to be bonded to one another). \nThis is performed by optimisation of a spring-particle system that moves species' centres of mass (see Molecule System).\nReactions of species within this system are explored. This is usually set such that only adjacent reactions - those that are a single reaction away from reactants within the given species system - are explored, as this avoids the most unneccessary exploration. \nThis is first done by finding all same-species reactions, both unimolecular and bimolecular, then finding all different-species reactions. This occurs in dedicated subspaces, which are then collated to form the overall level.\nEach subspace is considered to be converged in the same way as a direct method CRN - once a user-defined number of CDE iterations have passed without any new reactions being discovered (controlled by the rxn_convergence_threshold parameter of IterativeExplore).\nA kinetic simulation is run with the full CRN explored so far. This is done to identify species which exist at a high concentration at some point during the time period of interest, as these species are the most likely to react since they are most prevalent in the reaction mixture.\nThese high concentration species are referred to as seed species within Kinetica, as they are used to grow the next level of exploration.\nSpecies are selected as seeds if they have a maximum concentration above the seed_conc parameter of IterativeExplore.\nThe seed species are collated and the next level begins at step 1.","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"The iterative exploration method stops generating new levels of reactions once seed_convergence_threshold levels of exploration have passed without the seed system changing. This indicates that the remaining seeds are the high concentration species that should exist within the full CRN.","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"By only exploring down reactive pathways that are kinetically viable, the iterative exploration method avoids the combinatorial explosion of possible reactions that the direct method faces. This comes with the benefit of avoiding exploration of reactions that cannot occur because their reactants are never formed, speeding up kinetic simulations dramatically.","category":"page"},{"location":"tutorials/iterative-exploration/#Example","page":"Iterative CRN Exploration","title":"Example","text":"","category":"section"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"From a user's perspective, running a CRN exploration with the iterative method is almost identical to running one with the direct method. The simulation conditions, parameters and calculator are all defined in the same way, but an IterativeExplore parameter block is used instead of a DirectExplore block:","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"crn_dir = \"./my_iterative_CRN\"\n\nexploremethod = IterativeExplore(\n    rdir_head = crn_dir,\n    reac_smiles = [\"C\"],\n    rxn_convergence_threshold = 5,\n    seed_convergence_threshold = 3,\n    seed_conc = 0.05,\n    independent_blacklist = [\"[H]\"],\n    cde = CDE(\n        template_dir = \"../../examples/cde_template\",\n        radius = 1\n    )\n)","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"Most of the new parameters here are defined above, with exception of the independent_blacklist parameter. This defines a list of SMILES species names which should not be subjected to same-species reactions within their own subspace. The hydrogen radical is shown here as an example, as it cannot break down any more and the only reactions which consume it are the opposites of those that create it.","category":"page"},{"location":"tutorials/iterative-exploration/#Setting-seed_conc","page":"Iterative CRN Exploration","title":"Setting seed_conc","text":"","category":"section"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"The value of the seed_conc parameter is crucial in iterative explorations, effectively determining the accuracy of the resulting CRN. Set too high, very few species will ever have maximum concentrations above it and CRN levels will not contain many reactions, leading to a CRN that converges very quickly but is not sampled enough to be accurate. If seed_conc is set too low however, too many species will become seeds and individual levels will struggle to converge due to the breadth of reactions that must be sampled.","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"Finding the 'correct' value of seed_conc is therefore not a simple task - it is highly dependent on the species being reacted and the conditions and kinetic calculator that the simulations which guide the CRN exploration are using. We therefore recommend that multiple iterative explorations are run with decreasing values of seed_conc until an acceptable CRN accuracy has been found (i.e. the CRN is as complete as it needs to be for your use case). It can help if you have some experimental results for a related initial system under similar conditions to compare against.","category":"page"},{"location":"tutorials/filtering-crns/#Filtering-CRNs","page":"Filtering CRNs","title":"Filtering CRNs","text":"","category":"section"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"Sometimes, certain chemical reactions are known to be unwanted in a CRN before any kinetic simulations are run. For example, it may be desirable to place a limit on the size of chemical species within a CRN by removing any reactions which create species above this size.","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"Kinetica enables this reaction filtering through an easily extensible system that can scale to as many arbitrary filters as desired. This is done by constructing a RxFilter. This is essentially a Vector of functions, each of which takes the current CRN in the form (SpeciesData, RxData) and returns a boolean mask over the reactions in the given RxData.","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"To demonstrate, let's construct an RxFilter which removes all reactions involving double bonds from a CRN. We'll use the CRN we created in Getting Started by loading the results file and extracting the SpeciesData and RxData:","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"using Kinetica\nres = load_output(\"../my_CRN_out/direct_network_final.bson\")\nsd, rd = res.sd, res.rd\nnothing # hide","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"If we inspect the reactions in this CRN, we can see that quite a few of them involve double bonds (represented in SMILES by an equals sign = between two elements):","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"for i in 1:rd.nr\n    print_rxn(sd, rd, i)\nend\nnothing # hide","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"To create our RxFilter, we must first write a function that identifies reactions which involve double bonds, then writes a boolean mask which indicates that these reactions should be removed. Remember that this function must take the current CRN in the form (SpeciesData, RxData):","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"function db_filter(sd, rd)\n    # Create a mask where no reactions are removed.\n    mask = [false for _ in 1:rd.nr]\n\n    # Iterate through products of reactions.\n    for (i, rx_reac_ids) in enumerate(rd.id_reacs)\n        for reac_species_id in rx_reac_ids\n            # Set mask at this reaction to true if there are double bonds.\n            # We can determine this easily by the presence of '=' in a species' SMILES.\n            if '=' in sd.toStr[reac_species_id]\n                mask[i] = true\n                break\n            end\n        end\n    end\n    \n    # Do the same for products of reactions.\n    for (i, rx_prod_ids) in enumerate(rd.id_prods)\n        # Skip already masked reactions.\n        if mask[i] continue end\n        for prod_species_id in rx_prod_ids\n            if '=' in sd.toStr[prod_species_id]\n                mask[i] = true\n                break\n            end\n        end\n    end\n\n    return mask\nend","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"We can turn this into a RxFilter like so:","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"filter = RxFilter([db_filter])","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"note: Inverting Filters\nWe have created a filter that will remove reactions where the mask is true, however sometimes it may be more convenient to write filters that only keep reactions where the mask is true. This is supported by passing the keyword argument keep_filtered=true (false by default) to RxFilter during its construction.","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"Filters are applied automatically when running a kinetic simulation, as long as they are provided when constructing the intermediate StaticODESolve/VariableODESolve object:","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"# conditions = ConditionSet(...)\n# pars = ODESimulationParams(...)\n# calculator = ...\nsolvemethod = VariableODESolve(pars, conditions, calculator, filter)\n# res = solve_network(solvemethod, sd, rd)","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"Under the hood, this is just calling a simple procedure: filter is queried to construct a combined mask from all filter functions given the current CRN, and splice!(::RxData, ::Vector{Int}) is called to remove the masked reactions from the CRN. We can replicate this to see how the CRN is modified by our filter:","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"mask = get_filter_mask(filter, sd, rd)\n# Create a copy of RxData to avoid modifying it.\nfiltered_rd = deepcopy(rd)\nsplice!(filtered_rd, findall(mask))\n\nfor i in 1:filtered_rd.nr\n    print_rxn(sd, filtered_rd, i)\nend\nnothing # hide","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"note: Using findall(mask)\nNote that we can't just pass the mask directly to the splice! function - instead, we must pass it through findall. This converts the BitVector mask into a Vector{Int} containing the indices of reactions where the mask is true, which is compatible with splice!.","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"We've now successfully masked out all of the reactions that involve double bonds from our CRN! However, let's say we also want to remove all reactions that consume methane (C in SMILES). We could extend our db_filter function above, but it would start to become quite large. Instead, we can create a new function for this new filter and let the RxFilter do the work of combining the resulting masks together:","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"function methane_filter(sd, rd)\n    mask = [false for _ in 1:rd.nr]\n    for (i, rx_reac_ids) in enumerate(rd.id_reacs)\n        for reac_species_id in rx_reac_ids\n            if sd.toStr[reac_species_id] == \"C\"\n                mask[i] = true\n                break\n            end\n        end\n    end\n    return mask\nend\n\n# Create a new filter that uses both filter functions.\nfilter = RxFilter([db_filter, methane_filter])\n\n# Create a new combined mask to act on the original CRN.\nmask = get_filter_mask(filter, sd, rd)\n\n# Filter the original CRN with both filters.\nfiltered_rd = deepcopy(rd)\nsplice!(filtered_rd, findall(mask))\n\nfor i in 1:filtered_rd.nr\n    print_rxn(sd, filtered_rd, i)\nend\nnothing # hide","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"Notice that now we've also filtered out all reactions where methane (C) was a reactant! We can combine as many filter functions as we want in this way to remove arbitrary sets of reactions from a CRN as needed.","category":"page"},{"location":"api/kineticakpm/#KineticaKPM.jl-API","page":"KineticaKPM.jl","title":"KineticaKPM.jl API","text":"","category":"section"},{"location":"api/kineticakpm/#KPM-Runner","page":"KineticaKPM.jl","title":"KPM Runner","text":"","category":"section"},{"location":"api/kineticakpm/","page":"KineticaKPM.jl","title":"KineticaKPM.jl","text":"KPMRun","category":"page"},{"location":"api/kineticakpm/#KineticaKPM.KPMRun","page":"KineticaKPM.jl","title":"KineticaKPM.KPMRun","text":"kpm = KPMRun(model_path)\n\nKPM runner for prediction of reaction activation energies.\n\nHandles instantiation of the underlying Scikit-Learn model in Python, and can be called to use this model for predictions.\n\n\n\n\n\n","category":"type"},{"location":"api/kineticakpm/#KPM-Calculators","page":"KineticaKPM.jl","title":"KPM Calculators","text":"","category":"section"},{"location":"api/kineticakpm/","page":"KineticaKPM.jl","title":"KineticaKPM.jl","text":"KPMBasicCalculator\nKPMCollisionCalculator\nKPMCollisionEntropyCalculator","category":"page"},{"location":"api/kineticakpm/#KineticaKPM.KPMBasicCalculator","page":"KineticaKPM.jl","title":"KineticaKPM.KPMBasicCalculator","text":"Basic KPM kinetic calculator for reactions.\n\nKinetic calculator that uses KPM to predict activation energies for reactions and uses these predictions within the Arrhenius equation to calculate rate constants.\n\nBasic calculator uses a flat RT/h Arrhenius prefactor for all reactions. This is usually not accurate enough to enable sensible kinetic simulations.\n\nImplemented conditions:\n\nTemperature (T, unit: K)\n\nRequires:\n\nReaction energies (rd.dH, unit: eV)\nTrained KPM model (kpm.model_path, loaded when KPMRun is instantiated)\n\nHas support for dispatching with/without a maximum rate constant k_max and scaling by time unit t_unit (assuming rates are provided in units of /s).\n\n\n\n\n\n","category":"type"},{"location":"api/kineticakpm/#KineticaKPM.KPMCollisionCalculator","page":"KineticaKPM.jl","title":"KineticaKPM.KPMCollisionCalculator","text":"Collision theory-based KPM kinetic calculator for reactions.\n\nKinetic calculator that uses KPM to predict activation energies for reactions and uses these predictions within the Arrhenius equation to calculate rate constants.\n\nCollision theory-based calculator approximates Arrhenius prefactors on a per-reaction basis with a hard sphere approximation of collision frequency. This is most accurate for small, spherical reactants, and becomes less realistic the further from this ideal the reactants get.\n\nAdditionally, allows for using one of a selection of steric factors for correcting discrepancies between collision theory prefactors and real Arrhenius prefactors.\n\nImplemented conditions:\n\nTemperature (T, unit: K)\n\nRequires:\n\nReaction energies (rd.dH, unit: eV)\nTrained KPM model (kpm.model_path, loaded when KPMRun is instantiated)\n\nHas support for dispatching with/without a maximum rate constant k_max and scaling by time unit t_unit (assuming rates are provided in units of /s).\n\n\n\n\n\n","category":"type"},{"location":"api/kineticakpm/#KineticaKPM.KPMCollisionEntropyCalculator","page":"KineticaKPM.jl","title":"KineticaKPM.KPMCollisionEntropyCalculator","text":"Collision theory-based KPM kinetic calculator for reactions, with translational entropy.\n\nKinetic calculator that uses KPM to predict activation energies for reactions and uses these predictions within the Arrhenius equation to calculate rate constants.\n\nCollision theory-based calculator approximates Arrhenius prefactors on a per-reaction basis with a hard sphere approximation of collision frequency. This is most accurate for small, spherical reactants, and becomes less realistic the further from this ideal the reactants get.\n\nAdditionally, calculates translational entropy change for each reaction to correct for lack of entropic contribution in collision theory prefactors.\n\nImplemented conditions:\n\nTemperature (T, unit: K)\n\nRequires:\n\nReaction energies (rd.dH, unit: eV)\nTrained KPM model (kpm.model_path, loaded when KPMRun is instantiated)\n\nHas support for dispatching with/without a maximum rate constant k_max and scaling by time unit t_unit (assuming rates are provided in units of /s).\n\n\n\n\n\n","category":"type"},{"location":"api/kineticakpm/#Property-Calculation","page":"KineticaKPM.jl","title":"Property Calculation","text":"","category":"section"},{"location":"api/kineticakpm/","page":"KineticaKPM.jl","title":"KineticaKPM.jl","text":"KineticaKPM.calc_collision_params\nKineticaKPM.calc_steric_factors","category":"page"},{"location":"api/kineticakpm/#KineticaKPM.calc_collision_params","page":"KineticaKPM.jl","title":"KineticaKPM.calc_collision_params","text":"μ, σ = calc_collision_params(rd, sd[, easy_units])\n\nCalculates the collision theory parameters for given reactions.\n\nCollision theory requires calculation of a reduced mass μ and a collision cross-section σ for each pair of reactants in a reaction.\n\nCalculates these values, using an 'average collision partner' for unimolecular reactions. Possible to get around this by implementing a non-reactive collision partner with unit concentration to all  unimolecular reactions, effectively making them bimolecular for the purposes of these calculations.\n\nMust be preceded by a call to get_frag_stats!() to populate species weights and radii.\n\n\n\n\n\n","category":"function"},{"location":"api/kineticakpm/#KineticaKPM.calc_steric_factors","page":"KineticaKPM.jl","title":"KineticaKPM.calc_steric_factors","text":"ρ = calc_steric_factors(rd, sd, steric_factor)\n\nCalculates steric factors for all reactions in rd, using the requested steric factor function.\n\nValid steric factors are\n\n:basic - Calculates steric factors as 1/(α_A * α_B), where α_i = n_i² + 5r_i(n_i - 1).\n:exp - Calculates steric factors as 1/(α_A * α_B)^β, where α_i = n_i² + 5r_i(n_i - 1). Requires passing a value of β via params\n:logistic - Calculates steric factors with an adjustable bivariate logistic distribution. Requires passing a value of β via params\n:dlogistic - Calculates steric factors with 2 adjustable bivariate logistic distributions. Requires passing a vector of [βassoc, βdissoc] via params\n:none - Makes all steric factors equal to 1, removing them from the rate equation.\n\n\n\n\n\nρ = calc_steric_factors(rd, sd, Val(:none))\n\nMakes all steric factors equal to 1, removing them from the rate equation.\n\n\n\n\n\nρ = calc_steric_factors(rd, uniq_frags, Val(:basic))\n\nCalculates steric factors as 1/(α_A * α_B), where α_i = n_i + 5r_i(n_i - 1).\n\n\n\n\n\nρ = calc_steric_factors(rd, uniq_frags, Val(:exp), β)\n\nCalculates steric factors as 1/(α_A * α_B)^β, where α_i = n_i² + 5r_i(n_i - 1).\n\n\n\n\n\nρ = calc_steric_factors(rd, uniq_frags, Val(:logistic), β)\n\nCalculates steric factors on an adjustable bivariate logistic distribution.\n\nThe steric factor ρ for a reaction is calculated as\n\nρ = D / ((1+exp(βα_A))(1+exp(βα_B)))\n\nwhere \n\nD = (1+exp(β))^2, \nα_i = n_i + 5r_i(n_i-1),\n\nand A and B are the bimolecular reactants.\n\n\n\n\n\nρ = calc_steric_factors(rd, uniq_frags, Val(:dlogistic), β_assoc, β_dissoc)\n\nCalculates steric factors on 2 adjustable bivariate logistic distributions.\n\nCreates 2 logistic distributions: one for associative reactions, and the other for dissociative reactions. The gradient of each distribution can be tuned with its respective β parameter.\n\nThe steric factor ρ for an associative reaction is calculated as\n\nρ = D_assoc / ((1+exp(β_assoc*α_A))(1+exp(β_assoc*α_B)))\n\nwhile the steric factor for a dissociative reaction is calculated as\n\nρ = D_dissoc / ((1+exp(β_dissoc*α_A))(1+exp(β_dissoc*α_B)))\n\nwhere \n\nD_assoc = (1+exp(β_assoc))^2, \nD_dissoc = (1+exp(β_dissoc))^2,\nα_i = n_i + 5r_i(n_i-1),\n\nand A and B are the bimolecular reactants. Reactions which are neither associative nor dissociative use the associative steric factor by default.\n\n\n\n\n\n","category":"function"},{"location":"#Kinetica.jl-Documentation","page":"Home","title":"Kinetica.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kinetica.jl is a Julia package for performing automated exploration of chemical reaction networks (CRNs) and integrating these networks in time. In particular, it features:","category":"page"},{"location":"#Arbitrary-simulation-conditions","page":"Home","title":"Arbitrary simulation conditions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kinetica.jl is built around giving users complete freedom over kinetic simulations. As such any combination of customisable simulation conditions, static or variable, can be utilised by binding symbolic variable names to flexible parametric condition profiles.","category":"page"},{"location":"#Kinetics-driven-CRN-exploration","page":"Home","title":"Kinetics-driven CRN exploration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Chemical space exploration can be performed with a fully random approach, sampling every reaction within a defined number of intermediates from a starting system. This can be very difficult to sample completely and is often inefficient. We provide a focused kinetics-driven approach that selectively explores reaction space in places relevant to the given simulation conditions.","category":"page"},{"location":"#Flexible-kinetic-simulation","page":"Home","title":"Flexible kinetic simulation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"By leveraging packages from Julia's SciML organization (including DifferentialEquations.jl, ModelingToolkit.jl and Catalyst.jl), users can perform difficult long-timescale integrations of generated CRNs under challenging variable experimental conditions. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We supplement this with a discrete approximation to variable rate constant simulations that greatly improves overall solution efficiency and allows for previously inaccessible levels of theory to be incorporated into variable kinetic calculations.","category":"page"},{"location":"#Modular-kinetic-calculators","page":"Home","title":"Modular kinetic calculators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Extending user control over kinetic simulations, Kinetica.jl makes use of a modular calculator interface for rate constant calculations. This allows for a wide variety of techniques to be utilised within kinetic simulations, ranging from expensive DFT-based approaches to fast ML-based approximations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We currently provide the KineticaKPM.jl package for calculating rate constants from ML-predicted activation energies, and aim to release further calculator packages in the future. However, the calculator interface allows for simple user definition of new methods too.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kinetica.jl can be installed through the Julia package manager by adding the KinetcaRegistry package registry:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.Registry.add(RegistrySpec(url=\"https://github.com/Kinetica-jl/KineticaRegistry\"))\nPkg.add(\"Kinetica\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will fetch the latest version of Kinetica.jl, as well as all of its dependencies.","category":"page"},{"location":"#Other-Kinetica-Packages","page":"Home","title":"Other Kinetica Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This process is the same for other Kinetica extension packages, such as KineticaKPM.jl, which can be installed in the same way, e.g.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"KineticaKPM\")","category":"page"},{"location":"#Python-Dependencies","page":"Home","title":"Python Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kinetica makes use of Python packages such as RDKit and Open Babel internally for extracting information from molecular geometries. Installation of these packages is handled automatically thanks to CondaPkg.jl, which creates a conda environment that is isolated to the current project and the packages within it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This conda environment is composable at runtime, so if you were to have both Kinetica.jl and KineticaKPM.jl in the same Julia project, the Python dependencies of both packages would be automatically assembled into a dedicated conda environment that is then used internally by both packages through PythonCall.jl. ","category":"page"},{"location":"#xTB","page":"Home","title":"xTB","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"While not a direct dependency, some parts of Kinetica's CRN exploration routines (which act through the CDE code) require an electronic structure code to perform geometry optimisations and energy calculations. Since only approximate geometries and energies are required within CDE, we recommend using the GFN2-xTB method within the Extended Tight-Binding (xTB) package by Bannwarth et. al. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"An xTB package is included with Kinetica.jl's Python dependencies and will be installed automatically. A shorthand alias to this package can be created (assuming you are in your Julia project's directory) with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"alias xtb=\"$(julia --project -e 'using CondaPkg; print(CondaPkg.which(\"xtb\"))')\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note for tutorial users\nIf you plan to follow the tutorials in this documentation, the example CDE inputs assume that you have xTB installed and available by calling xtb (either aliased or in your PATH). The above alias is therefore required for the tutorials to function.","category":"page"},{"location":"#Citing-Kinetica","page":"Home","title":"Citing Kinetica","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use any of the Kinetica packages in your work, please cite the following:","category":"page"},{"location":"#Kinetica.jl","page":"Home","title":"Kinetica.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Gilkes, J.; Storr, M.; Maurer, R. J.; Habershon, S. Predicting long timescale kinetics under variable experimental conditions with Kinetica.jl. 2024, arXiv:2403.08657. arXiv.org e-Print archive. https://arxiv.org/abs/2403.08657","category":"page"},{"location":"#KineticaKPM.jl","page":"Home","title":"KineticaKPM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Paper coming soon!","category":"page"},{"location":"api/kinetica/solving/#api_solving","page":"Solving","title":"Kinetica.jl API","text":"","category":"section"},{"location":"api/kinetica/solving/#Simulation-Parameters","page":"Solving","title":"Simulation Parameters","text":"","category":"section"},{"location":"api/kinetica/solving/","page":"Solving","title":"Solving","text":"ODESimulationParams","category":"page"},{"location":"api/kinetica/solving/#Kinetica.ODESimulationParams","page":"Solving","title":"Kinetica.ODESimulationParams","text":"Container for ODE-driven simulation parameters.\n\nContains fields for:\n\nSimulation timespan (must match time unit used in an attached calculator) (tspan)\nInitial concentrations of species, either as a Dict of certain species or a Vector of all species (u0)\nDifferentialEquations ODE solver (solver)\nWhether to use ModelingToolkit to formulate an analytical Jacobian (do_jac=true)\nWhether to use ModelingToolkit to formulate a sparse problem (do_sparse=true)\nAbsolute tolerance of ODE solver (abstol=1e-10)\nRelative tolerance of ODE solver (reltol=1e-8)\nWhether to use adaptive solver tolerance (adaptive_tols=true)\nWhether to update solver tolerances after successful solve with adaptive tolerance (update_tols=false)\nWhether to break solution into chunks of size solve_chunkstep to avoid floating point underflow (solve_chunks=true)\nGlobal timestep at which solution should be reinitialised when solve_chunks=true (solve_chunkstep=1e-3)\nMaximum number of ODE solver iterations (maxiters=1e5)\nWhether to explicitly disallow negative values in the solver (ban_negatives=false)\nWhether to display progress bars - requires TerminalLogger initialisation (progress=false)\nTime interval to interpolate solution data on (save_interval=nothing)\nCutoff below which reactions with low rate constants are removed from the network (low_k_cutoff=:auto)\nWhether to allow a vector u0 to be shorter than the number of species in the network (allow_short_u0=false)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/solving/#Kinetic-Calculators-(Kinetica.jl)","page":"Solving","title":"Kinetic Calculators (Kinetica.jl)","text":"","category":"section"},{"location":"api/kinetica/solving/","page":"Solving","title":"Solving","text":"PrecalculatedArrheniusCalculator","category":"page"},{"location":"api/kinetica/solving/#Kinetica.PrecalculatedArrheniusCalculator","page":"Solving","title":"Kinetica.PrecalculatedArrheniusCalculator","text":"Arrhenius theory kinetic calculator for precalculated reactions.\n\nKinetic calculator that uses the Arrhenius equation to determine rates of reaction. Requires prior specification of reaction activation energies (Ea) and Arrhenius prefactors (A), will not calculate/predict these internally.\n\nImplemented conditions:\n\nTemperature (T, unit: K)\n\nRequires:\n\nActivation energies (Ea, unit: J/mol)\nArrhenius prefactors (A, unit: mol dm^-3 s^-1 assuming bimolecular reactions)\n\nHas support for dispatching with/without a maximum rate constant k_max and scaling by time unit t_unit (assuming rates are provided in units of /s).\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/solving/#Solvers","page":"Solving","title":"Solvers","text":"","category":"section"},{"location":"api/kinetica/solving/","page":"Solving","title":"Solving","text":"StaticODESolve\nVariableODESolve\nsolve_network","category":"page"},{"location":"api/kinetica/solving/#Kinetica.StaticODESolve","page":"Solving","title":"Kinetica.StaticODESolve","text":"Static kinetic CRN solver type.\n\nCombines all parameter inputs, conditions, a calculator and a set of reaction finters into a single type to be passed to the solver.\n\nAll conditions in the provided ConditionSet must be static  (defined as a single number), and also must be compatible with the provided calculator.\n\nAllows for optional specification of RxFilter. If not defined, creates a filter that allows all reactions.\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/solving/#Kinetica.VariableODESolve","page":"Solving","title":"Kinetica.VariableODESolve","text":"Variable kinetic CRN solver type.\n\nCombines all parameter inputs, conditions, a calculator and a set of reaction finters into a single type to be passed to the solver.\n\nConditions in the provided ConditionSet must be compatible with the calculator and can be a combination of static and  variable. However, this will throw an error if all conditions  are static, as a StaticODESolve should be used instead.\n\nAllows for optional specification of RxFilter. If not defined, creates a filter that allows all reactions.\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/solving/#Kinetica.solve_network","page":"Solving","title":"Kinetica.solve_network","text":"solve_network(method::StaticODESolve, sd, rd[, copy_network, return_integrator])\n\nSolve a network with static kinetics.\n\nAutomatically dispatches to the correct method based on the value of method.pars.solve_chunks, as chunkwise solution requires a significantly different approach.\n\nSetting copy_network=true generates a deepcopy of the original network in rd and sd and uses these in the solution, to avoid side effects from calculators modifying the original network that is passed in. The copied (modified) network is returned as part of the  resulting ODESolveOutput.\n\nSetting return_integrator=true sets up and returns the underlying integrator without solving (i.e. at  t = method.pars.tspan[1]), allowing for manual stepping through the solution. Note that chunkwise solutions implement many reinitialisations of this integrator, which will have to be mirrored in the calling script to get the same results.\n\n\n\n\n\nsol = solve_network(method::VariableODESolve, sd, rd[, copy_network, return_integrator])\n\nSolve a network with variable kinetics.\n\nAutomatically dispatches to the correct method based on the value of method.pars.solve_chunks, as chunkwise solution requires a significantly different approach.\n\nSetting copy_network=true generates a deepcopy of the original network in rd and sd and uses these in the solution, to avoid side effects from calculators modifying the original network that is passed in. The copied (modified) network is returned as part of the  resulting ODESolveOutput.\n\nSetting return_integrator=true sets up and returns the underlying integrator without solving (i.e. at  t = method.pars.tspan[1]), allowing for manual stepping through the solution. Note that chunkwise solutions implement many reinitialisations of this integrator, which will have to be mirrored in the calling script to get the same results.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/solving/#Reaction-Filtering","page":"Solving","title":"Reaction Filtering","text":"","category":"section"},{"location":"api/kinetica/solving/","page":"Solving","title":"Solving","text":"RxFilter","category":"page"},{"location":"api/kinetica/solving/#Kinetica.RxFilter","page":"Solving","title":"Kinetica.RxFilter","text":"Data container for CRN filters.\n\nDefines a set of functions which can be used on a network to construct a set of masks of reactions. These reactions can then be excluded from a network, or their inverse can be taken to exclude all other reactions form a network.\n\nContains fields for:\n\nArray of filter functions, each taking a tuple of ::SpeciesData and ::RxData as arguments (filters)\nWhether to remove or keep masked reactions (keep_filtered)\n\nCan be constructed blank (rf = RxFilter()) to obtain a mask of all reactions, which are then kept. Can also be constructed as  rf = RxFilter(filters) to default to removing the filtered reactions.\n\n\n\n\n\n","category":"type"}]
}
