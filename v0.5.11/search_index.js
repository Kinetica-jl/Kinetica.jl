var documenterSearchIndex = {"docs":
[{"location":"development/condition-profiles/#Condition-Profiles","page":"Condition Profiles","title":"Condition Profiles","text":"","category":"section"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"using Kinetica\nprev_res = load_output(\"../my_CRN_out/direct_network_final.bson\")\nsd, rd = prev_res.sd, prev_res.rd\n\nusing Sundials\npars = ODESimulationParams(\n    tspan = (0.0, 1.0),\n    u0 = Dict(\"C\" => 1.0),\n    solver = CVODE_BDF(; linear_solver=:KLU),\n    abstol = 1e-11,\n    reltol = 1e-9\n)\n\nusing BSON\ncalc_pars = BSON.load(\"../../../examples/getting_started/arrhenius_params.bson\")\ncalc = PrecalculatedArrheniusCalculator(calc_pars[:Ea], calc_pars[:A]; k_max=1e12)\n\nmkpath(\"../assets/tutorials/condition_profiles\")","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"For an introduction into Kinetica's arbitrary simulation condition framework, see the tutorial on Arbitrary Simulation Conditions. This page aims to explain the underlying implementation of Kinetica's variable condition profiles, such that users can easily extend Kinetica by adding their own profiles to represent new macroscopic state variable changes.","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"As noted previously, variable condition profiles can take on one of two types of definition which effect how they are represented and interacted with inside Kinetica's solvers:","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"Directly variable condition profiles (subtypes of Kinetica.AbstractDirectProfile) encode a condition X as a continuous function of time X(t). The result of this function is then computed directly whenever it is needed at a given time t.\nGradient-variable condition profiles (subtypes of Kinetica.AbstractGradientProfile) encode a condition X within a gradient with respect to time fracdXdt. These condition profiles must be integrated with time using DifferentialEquations.jl to yield an interpolable ODESolution which can be queried to produce values of the condition at time t.","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"Both types of variable condition profile are simple to implement within Kinetica, provided a few criteria are fulfilled:","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"Both are implemented as structs with supertypes as above that indicate how Kinetica should handle them. These structs must have a number of fields, but are otherwise entirely customisable for whatever data needs to be held. These usually come with outer constructors that create variables that are needed within the profile's condition function, as well as binding a condition function to one of the struct's fields.\nA condition function (usually called _f_[struct name] for direct condition profiles or _grad_[struct_name] for gradient condition profiles) must exist such that it can be bound to a condition profile struct. This function takes two arguments - the time t and the profile that it will ultimately be bound to.\nA method of Kinetica.create_discrete_tstops! must be created for the new profile struct which tells Kinetica where rate constants should be updated in discrete rate constant update simulations.","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"We'll demonstrate this by implementing both directly variable and gradient-variable versions of a simple sinusoidal condition profile.","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"note: Why not a functor?\nThe implementation of condition functions described above may look a bit strange. Variable condition profiles require condition functions that always take the same arguments for internal consistency, but are also capable of taking a potentially large number of runtime-defined parameters that are accessible from some kind of Kinetica.AbstractVariableProfile. Why then do we pass a condition function as a field of the profile struct during construction and then pass the struct back to that function instead of using a functor, which would seemingly fill both of these roles?While the functor approach would certainly be more convenient, it's currently incompatible with Symbolics.jl (more specifically its function registration API), which Kinetica uses to programatically embed variable condition profiles into systems of ODEs. Instead, we are forced to use a regular function, which then takes its parameters from a condition profile struct such that its call signature is always conditionfunc(t, profile::AbstractVariableProfile). This function is bound to its respective condition profile struct so that irrespective of its true name, it is always accessible through profile.f for direct profiles, and profile.grad for gradient profiles.Similarly, we could define condition functions within the outer constructors, allowing them to implicitly make use of profile variables defined within the constructor and eliminating the need to pass an instance of the profile struct as an argument. However, due to how functions are registered within Symbolics, this can lead to condition functions overwriting one another. The separate condition function approach is admittedly a bit cumbersome, but it is currently the best viable approach that allows for hands-off creation of ConditionSets for users.","category":"page"},{"location":"development/condition-profiles/#Directly-Variable-Profile-Implementation","page":"Condition Profiles","title":"Directly Variable Profile Implementation","text":"","category":"section"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"When a condition profile can be represented exactly as a simple function of time, it is usually easiest to implement as a directly variable condition profile. In the case of our sinusoidal profile, this function of time will be a sinusoid:","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"X(t)=Asinleft( 2pi f t right)","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"where A is the amplitude and f is the number of oscillations per second.","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"We will begin by creating the struct for our condition profile, which we'll call SinusoidDirectProfile. Aside from the parameters above, we'll also need to implement fields for some basics which Kinetica expects in every directly variable profile:","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"f: The function which will be bound in the struct's outer constructor.\nX_start: The initial value of the condition profile.\nt_end: The time at which the condition profile should stop varying. This can either be provided by the user or calculated within the outer constructor.\ntstops: Time points at which ODE solvers should ensure to stop at and recalculate. This array is useful for handling discontinuities in condition profiles, and is usually modified by Kinetica.create_discrete_tstops!.\nsol: Profile solution over the requested timespan, usually created internally by calling Kinetica.solve_variable_condition!(::Kinetica.AbstractDirectProfile, ::ODESimulationParams).","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"For this profile, we will also implement a field X_end to signify the value of the condition once it stops varying. In some profiles, this is more easily calculated by the profile itself, e.g. as a function of time when t_end is given. Conversely, in other profiles, it can be convenient to only provide X_end and let t_end be calculated instead. As a sinusoidal profile is periodic and may reach the same value multiple times, users will provide t_end directly and we will calculate and save the value of X_end in the outer constructor.","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"An implementation of our condition profile's struct may therefore look something like:","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"using Kinetica\n\nmutable struct SinusoidDirectProfile{uType, tType} <: Kinetica.AbstractDirectProfile\n    f::Function\n    A::uType\n    freq::uType\n    X_start::uType\n    X_end::uType\n    t_end::tType\n    tstops::Vector{tType}\n    sol\nend\nnothing # hide","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"We've used a parametric type here to ensure that all values that may affect the value of our condition are using consistent numeric types.","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"With this definition complete, we can now define our profile's condition function and outer constructor. The condition function will take a time t and an instance of the SinusoidDirectProfile. The outer constructor will take a minimal set of parameters needed to populate and calculate the entire condition profile, and create an instance of the profile with the condition function bound to the f field:","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"function _f_SinusoidDirectProfile(t, profile::SinusoidDirectProfile)\n    return typeof(profile.X_start)(\n        ((t <= 0.0) * profile.X_start) +\n        ((t > 0.0 && t <= profile.t_end) * (profile.X_start + profile.A*sin(2*pi*profile.freq*t))) + \n        ((t > profile.t_end) * profile.X_end)\n    )\nend\n\nfunction SinusoidDirectProfile(;\n    A::uType,\n    freq::uType,\n    X_start::uType,\n    t_end::tType\n) where {uType <: AbstractFloat, tType <: AbstractFloat}\n\n    X_end = X_start + A*sin(2*pi*freq*t_end)\n    tstops = [t_end]\n\n    return SinusoidDirectProfile(_f_SinusoidDirectProfile, A, freq, X_start, X_end, t_end, tstops, nothing)\nend\nnothing # hide","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"How we've defined _f_SinusoidDirectProfile(t, profile) here may look a little strange. This is actually a way of writing if-else statements that is compatible with Symbolics.jl, and is equivalent to writing","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"function _f_SinusoidDirectProfile(t, profile::SinusoidDirectProfile)\n    if t <= 0.0\n        return profile.X_start\n    elseif t > 0.0 && t <= profile.t_end\n        return profile.X_start + profile.A*sin(2*pi*profile.freq*t)\n    else\n        return profile.X_end\n    end\nend","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"However, Symbolics isn't compatible with this form of if-else statement so instead we use a bit of boolean algebra to embed the same meaning into our condition function. We've therefore assumed that simulation time will start at t=0.0, before which time the condition will be X_start. After t_end, the condition profile will stop varying and be set to the value of the sinusoid at this time. In between these two times, we take the instantaneous value of the sinusoid instead.","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"note: Naming Condition Functions\nCondition functions do not have to take any particular names, although Kinetica generally follows the pattern set above. Starting with an underscore indicates that the function is not intended for general use, the f (or grad in the case of gradient functions) specifies the type of variable condition profile that it attaches to, and the name of the condition profile indicates that it should only be used in the context of that particular profile.","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"Finally, we need to define a method of Kinetica.create_discrete_tstops! for our new profile. This function creates time stopping points for discrete rate update simulations. Some profiles contain periods of time where their condition is stationary, during which rate constant updates are unnecessary, so their method of this function can avoid creating time points during these periods. However, since the gradient of a sinusoid is only ever momentarily stationary, this optimisation is not necessary. Our implementation of this method is therefore as follows:","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"function Kinetica.create_discrete_tstops!(profile::SinusoidDirectProfile, ts_update::AbstractFloat)\n    if ts_update > profile.t_end \n        throw(ArgumentError(\"Error defining tstops, `ts_update` is too large.\")) \n    end\n    profile.tstops = create_savepoints(0.0, profile.t_end, ts_update)\n    return\nend\nnothing # hide","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"This is simply checking that the rate update timestep ts_update is not larger than the total duration of our condition profile, then setting the tstops of our profile to an evenly spaced array of time points between t=0.0 and t=t_end. create_savepoints is just a Kinetica utility function for creating evenly spaced ranges of values while avoiding floating point rounding errors.","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"warning: Adding methods to Kinetica functions\nNote that when we extended Kinetica.create_discrete_tstops! above, we specifically prepended the function name with Kinetica.. The extra name of the module here is required as we want to add a method to Kinetica's existing function, not define our own in the Main module!","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"With this all implemented, our directly variable condition profile is now ready for use! Let's start by constructing a ConditionSet for a discrete rate update simulation with a sinusoidally-varying temperature:","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"conditions = ConditionSet(Dict(\n    :T => SinusoidDirectProfile(;\n        A = 75.0,\n        freq = 0.25,\n        X_start = 900.0,\n        t_end = 20.0\n    )),\n    ts_update=tconvert(0.1, \"ms\", \"s\")\n)\nnothing # hide","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"Because we've made SinusoidDirectProfile a subtype of Kinetica.AbstractDirectProfile, Kinetica's ConditionSet has done a bunch of work in the background and set this profile up for use within Symbolics.jl by registering the generated SinusoidDirectProfile.f function (which is really just a reference to _f_SinusoidDirectProfile) into Symbolics' computation graph. This means it's ready for use within kinetic simulations, just like that!","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"pars.tspan = (0.0, get_t_final(conditions)) # hide\n# Load in existing CRN...\n# pars = ODESimulationParams(...)\n# calc = PrecalculatedArrheniusCalculator(...)\n\nsolvemethod = VariableODESolve(pars, conditions, calc)\nres = solve_network(solvemethod, sd, rd)\nnothing # hide","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"using Plots\n\np1 = plot(res)\np2 = conditionsplot(res, :T)\nplot(p1, p2, layout=(2, 1))\nsavefig(\"../assets/tutorials/condition_profiles/direct.svg\"); nothing # hide","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"(Image: )","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"As you can see, the condition profile has been seamlessly integrated into Kinetica. Within solve_network, a new method of Kinetica.solve_variable_condition!(::Kinetica.AbstractDirectProfile, ::ODESimulationParams) was created and run for our condition profile, which generated an interpolable DiffEqArray that is now available in the solved profile's sol field:","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"profile = get_profile(res.conditions, :T)\nprofile.sol","category":"page"},{"location":"development/condition-profiles/#Gradient-Variable-Profile-Implementation","page":"Condition Profiles","title":"Gradient-Variable Profile Implementation","text":"","category":"section"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"Implementing a gradient-variable condition profile is a very similar procedure to the above directly variable profile - we'll still define a new struct that needs some specific fields to be compatible with the rest of Kinetica, we'll still make an outer constructor for this struct that creates a specialised function which will be automatically registered within Symbolics.jl, and we'll need a new method for Kinetica.create_discrete_tstops!.","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"Unlike the directly variable profile, we'll need to implement a function for our sinusoid's gradient with respect to time. In the case of this profile, a gradient-based definition is not required since we already have an exact function for mapping our sinusiodal condition to simulation time. However, it turns out that the gradient-based representation actually helps us include an additional parameter to describe the phase of the sinusoid varphi:","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"fracdXdt=2pi fA cos left( 2pi f t + φ right)","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"This would've been inconvenient to include into our directly variable form, as the user's input value of X_start would've needed to be changed within the outer constructor to take the starting phase into account. However, a gradient-based representation lends itself naturally to this addition.","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"The struct for this condition profile, which we'll call SinusoidGradientProfile, requires the same fields as its directly variable counterpart. The exception to this is the f field, which previously held the actual time-dependent condition function. In gradient-based profiles, this is replaced with a field called grad, which holds the gradient function. We also need to subtype Kinetica.AbstractGradientProfile this time, and we'll add a field for our starting phase varphi. Our new struct might therefore look something like this:","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"mutable struct SinusoidGradientProfile{uType, tType} <: Kinetica.AbstractGradientProfile\n    grad::Function\n    A::uType\n    freq::uType\n    φ::uType\n    X_start::uType\n    t_end::tType\n    tstops::Vector{tType}\n    sol\nend\nnothing # hide","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"The condition function and outer constructor for this profile will also be similar to their directly variable counterparts, again with an extra parameter φ added:","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"function _grad_SinusoidGradientProfile(t, profile::SinusoidGradientProfile)\n    return typeof(profile.X_start)(\n        ((t <= 0.0) * 0.0) +\n        ((t > 0.0 && t <= profile.t_end) * (2*pi*profile.freq*profile.A*cos(2*pi*profile.freq*t + profile.φ))) + \n        ((t > profile.t_end) * 0.0)\n    )\nend\n\nfunction SinusoidGradientProfile(;\n    A::uType,\n    freq::uType,\n    φ::uType,\n    X_start::uType,\n    t_end::tType\n) where {uType <: AbstractFloat, tType <: AbstractFloat}\n\n    tstops = [t_end]\n    return SinusoidGradientProfile(_grad_SinusoidGradientProfile, A, freq, φ, X_start, t_end, tstops, nothing)\nend\nnothing # hide","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"The gradient function we've defined here describes a function that is stationary (gradient of zero) before t=0.0 and after t=t_end, but that varies sinusoidally in between. This sinusoidal variation now also takes into account the starting phase varphi.","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"The implementation of Kinetica.create_discrete_tstops! can be the same as it was for the directly variable profile, as we are describing the same underlying function:","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"function Kinetica.create_discrete_tstops!(profile::SinusoidGradientProfile, ts_update::AbstractFloat)\n    if ts_update > profile.t_end \n        throw(ArgumentError(\"Error defining tstops, `ts_update` is too large.\")) \n    end\n    profile.tstops = create_savepoints(0.0, profile.t_end, ts_update)\n    return\nend\nnothing # hide","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"And with that, we're done implementing another condition profile! Let's see it in action:","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"conditions = ConditionSet(Dict(\n    :T => SinusoidGradientProfile(;\n        A = 75.0,\n        freq = 0.25,\n        φ = pi/2,\n        X_start = 975.0,\n        t_end = 20.0\n    )),\n    ts_update=tconvert(0.1, \"ms\", \"s\")\n)\n\nsolvemethod = VariableODESolve(pars, conditions, calc)\nres = solve_network(solvemethod, sd, rd)\nnothing # hide","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"This time, because we're using a gradient-based profile, when solve_network is called Kinetica goes away and assembles a ModelingToolkit.jl ODESystem and solves it with respect to time, just like it does when performing the kinetic simulation of the CRN immediately afterwards. As such, the sol field of our profile now contains a full ODESolution:","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"profile = get_profile(res.conditions, :T)\nprofile.sol","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"We can also look at the simulation results from using our gradient-based profile. Notice how both the concentrations and the temperature have changed since we introduced the phase parameter - now temperature starts from the top of the sinusiod rather than the middle:","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"p1 = plot(res)\np2 = conditionsplot(res, :T)\nplot(p1, p2, layout=(2, 1))\nsavefig(\"../assets/tutorials/condition_profiles/gradient.svg\"); nothing # hide","category":"page"},{"location":"development/condition-profiles/","page":"Condition Profiles","title":"Condition Profiles","text":"(Image: )","category":"page"},{"location":"tutorials/logging/#logging_page","page":"Logging","title":"Logging","text":"","category":"section"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"Kinetica makes use of multiple logging functions from the JuliaLogging organisation to handle writing logs of varying detail levels to the console and to file, as well as to handle various optional progress bars for tracking ODE solution progress.","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"By default, running Kinetica functions such as explore_network will output a text stream containing important information about the task at hand to stdout. An example of this can be seen in the 'Running the Simulation' section of Getting Started. This will always log at the Info level, so detailed debugging messages will not be present.","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"To log to a file and/or enable Debug-level logging, Kinetica provides a shorthand function for setting up the correct logger, start_log:","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"using Kinetica\nusing Logging: with_logger, Debug, Info\nlogger = start_log(\"./\"; min_level=Info, label=\"MyLog\")","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"This creates a nicely formatted logger of the requested level at the path ./MyLog_yymmdd-HHMMSS.log, inserting the date and time of creation into the yymmdd and HHMMSS fields respectively. If debug logging is required, min_level=Debug should be set instead.","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"To use this logger on a set of expressions, correctly formatting log messages and sending them to the requested log file, it needs to wrap the expressions in a with_logger function:","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"with_logger(logger) do\n    global res = explore_network(exploremethod, solvemethod, \"./my_CRN_out\")\nend","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"Note the use of the global keyword here - if this is a top-level script, the with_logger function will create a new scope that contains the variable res, which will be lost to the global (script-level) scope once it is exited. By making this variable global, it ensures we don't lose simulation results while logging!","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"Once you've finished logging within a script, call end_log to safely close the log file:","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"end_log(logger)","category":"page"},{"location":"tutorials/logging/#Progress-Bars","page":"Logging","title":"Progress Bars","text":"","category":"section"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"When solving ODEs, Kinetica can both make use of DifferentialEquations.jls native progress bar implementation and set up its own, depending on the solve type requested. Both depend on TerminalLoggers.jl in the background, but if we were to wrap a progress bar into a text log, we'd get a bit of a mess!","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"Kinetica works around this by always passing progress bars within ODE solution calls to the global logger. While the logger variable we defined above is a local logger that needs to be called within a with_logger wrapper, the global logger is specified over the entire session and can be accessed from anywhere in the code. It is therefore enough to define the global logger at the start of a Kinetica script, and the solvers will handle the rest. As in DifferentialEquations.jl, this is done by specifying the following:","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"using Logging: global_logger\nusing TerminalLoggers: TerminalLogger\nglobal_logger(TerminalLogger())","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"To enable progress bars during ODE solution, the progress parameter of ODESimulationParams needs to be set to true.","category":"page"},{"location":"api/kinetica/exploration/#Kinetica.jl-API","page":"Exploration","title":"Kinetica.jl API","text":"","category":"section"},{"location":"api/kinetica/exploration/#CRN-Representation","page":"Exploration","title":"CRN Representation","text":"","category":"section"},{"location":"api/kinetica/exploration/#Representing-Chemical-Species","page":"Exploration","title":"Representing Chemical Species","text":"","category":"section"},{"location":"api/kinetica/exploration/","page":"Exploration","title":"Exploration","text":"SpeciesData\nBase.push!(::SpeciesData, ::String, ::Dict{String, Any})\nBase.push!(::SpeciesData, ::Vector{String}, ::Vector{Any})\nBase.push!(::SpeciesData, ::String)\npush_unique!","category":"page"},{"location":"api/kinetica/exploration/#Kinetica.SpeciesData","page":"Exploration","title":"Kinetica.SpeciesData","text":"SpeciesData(smi_list, xyz_list[, unique_species=true])\nSpeciesData(xyz_file[, unique_species=true, fix_radicals=true])\n\nBidirectional String-Int dictionary for chemical species.\n\nCan either be constructed from an array of SMILES strings and their corresponding ExtXYZ frames, or from a single XYZ file with one or multiple species present. If unique_species=true, will not include any duplicate species if present. If fix_radicals=true in the XYZ file loading case, will attempt to tidy up radical SMILES with OBCR.\n\nContains fields for:\n\nSMILES string -> integer ID dictionary (toInt)\nInteger ID -> SMILES string dictionary (toStr)\nNumber of species (n)\nExtXYZ structures of species (xyz)\nDictionary of per-species cached values (cache)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/exploration/#Base.push!-Tuple{SpeciesData, String, Dict{String, Any}}","page":"Exploration","title":"Base.push!","text":"push!(sd::SpeciesData, smi::String, xyz::Dict{String, Any})\n\nAdd a species to SpeciesData.\n\nDoes not account for smi already existing within sd. To ensure no overlap, use push_unique!.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/exploration/#Base.push!-Tuple{SpeciesData, Vector{String}, Vector{Any}}","page":"Exploration","title":"Base.push!","text":"push!(sd::SpeciesData, smis::Vector{String}, xyzs::Vector{Any})\n\nAdd an array of species to SpeciesData.\n\nDoes not account for smi already existing within sd. To ensure no overlap, use push_unique!.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/exploration/#Base.push!-Tuple{SpeciesData, String}","page":"Exploration","title":"Base.push!","text":"push!(sd::SpeciesData, xyz_file::String[, fix_radicals=true])\n\nAdd all species in xyz_file to sd.\n\nDoes not account for smi already existing within sd. To ensure no overlap, use push_unique!.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/exploration/#Kinetica.push_unique!","page":"Exploration","title":"Kinetica.push_unique!","text":"push_unique!(sd::SpeciesData, smi::String, xyz::Dict{String, Any})\n\nAdd a species SMILES to a SpeciesData, as long as it does not already exist there.\n\n\n\n\n\npush_unique!(sd::SpeciesData, xyz_file::String[, fix_radicals=true])\n\nAdd species in xyz_file to sd, as long as they do not already exist there.\n\n\n\n\n\npush_unique!(sd::SpeciesData, smis::String, xyzs::Vector{Dict{String, Any}})\n\nAdd an array of species to SpeciesData, as long as each does not already exist there.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Representing-Reactions","page":"Exploration","title":"Representing Reactions","text":"","category":"section"},{"location":"api/kinetica/exploration/","page":"Exploration","title":"Exploration","text":"RxData\nBase.push!(::RxData{iType, fType}, ::SpeciesData, ::Vector{Vector{String}}, ::Vector{Vector{String}}, ::Vector{Dict{String, Any}}, ::Vector{Dict{String, Any}}, ::Vector{fType}) where {iType, fType <: AbstractFloat}\nBase.splice!(::RxData, ::Vector{Int})","category":"page"},{"location":"api/kinetica/exploration/#Kinetica.RxData","page":"Exploration","title":"Kinetica.RxData","text":"rd = RxData(sd::SpeciesData, reacs::Vector{Vector{String}}, prods::Vector{Vector{String}}, \n            rsys::Vector{Dict{String, Any}}, psys::Vector{Dict{String, Any}}, \n            dH::Vector{<:AbstractFloat}[, unique_rxns=true, max_molecularity=2])\n\nData container for reactions.\n\nConstructor creates a new RxData reaction data store from  lists of reactant and product SMILES by cross-referencing species IDs with sd. sd should therefore already have all species input here loaded in.\n\nreacs and prods should be the raw SMILES arrays from ingest_cde_run(), i.e. without any duplicate species removed due to stoichiometry. This constructor will determine stoichiometry and output the unique form of each set of reactants/products.\n\nBy default, adds a maximum of 1 of each reaction type when unique_rxns = true, and only admits reactions with a maximum molecularity of 2 (i.e. bimolecular reactions).\n\nContains fields for:\n\nNumber of reactions encountered (nr)\nAtom-mapped reaction SMILES for unambiguous linking of atom indices in reactants and products (mapped_rxns)\nUnique IDs of reactants for each reaction (id_reacs)\nUnique IDs of products for each reaction (id_prods)\nStoichiometries of reactants for each reaction (stoic_reacs)\nStoichiometries of products for each reaction (stoic_prods)\nReaction enthalpies (dH)\nReaction hashes, used for unique identification (rhash)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/exploration/#Base.push!-Union{Tuple{fType}, Tuple{iType}, Tuple{RxData{iType, fType}, SpeciesData, Vector{Vector{String}}, Vector{Vector{String}}, Vector{Dict{String, Any}}, Vector{Dict{String, Any}}, Vector{fType}}} where {iType, fType<:AbstractFloat}","page":"Exploration","title":"Base.push!","text":"push!(rd::RxData, sd::SpeciesData, reacs::Vector{Vector{String}}, prods::Vector{Vector{String}}, \n      rsys::Vector{Dict{String, Any}}, psys::Vector{Dict{String, Any}}, \n      dH::Vector{<:AbstractFloat}[, unique_rxns=true, max_molecularity=2])\n\nAdds an array of reactions to rd.\n\nExtends an RxData reaction data store from lists of reactant and product SMILES by cross-referencing species IDs with sd. sd should therefore already have all species input here loaded in.\n\nreacs and prods should be the raw SMILES arrays from ingest_cde_run(), i.e. without any duplicate species removed due to stoichiometry. This function will determine stoichiometry and output the unique form of each set of reactants/products.\n\nBy default, adds a maximum of 1 of each reaction type when unique_rxns = true, and only admits reactions with a maximum molecularity of 2 (i.e. bimolecular reactions).\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/exploration/#Base.splice!-Tuple{RxData, Vector{Int64}}","page":"Exploration","title":"Base.splice!","text":"splice!(rd::RxData, rids::Vector{Int})\n\nRemoves reactions at indeces rids from rd.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/exploration/#CRN-Initialisation","page":"Exploration","title":"CRN Initialisation","text":"","category":"section"},{"location":"api/kinetica/exploration/","page":"Exploration","title":"Exploration","text":"init_network","category":"page"},{"location":"api/kinetica/exploration/#Kinetica.init_network","page":"Exploration","title":"Kinetica.init_network","text":"init_network([iType=Int64, fType=Float64])\n\nInitialises an empty reaction network.\n\nReturns an empty SpeciesData{iType} and RxData{iType, fType}.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#CDE-Interface","page":"Exploration","title":"CDE Interface","text":"","category":"section"},{"location":"api/kinetica/exploration/","page":"Exploration","title":"Exploration","text":"CDE\ningest_cde_run\nimport_mechanism\nimport_mechanism!\nimport_network","category":"page"},{"location":"api/kinetica/exploration/#Kinetica.CDE","page":"Exploration","title":"Kinetica.CDE","text":"CDE(template_dir::String [, env_threads, cde_exec, sampling_seed, radius, nrxn, parallel_runs, parallel_exes, write_stdout, write_stderr, allow_errors])\n\nCDE runner. Initialised through keyword-based struct, run through functor.\n\nStruct contains fields for:\n\nCDE template directory (template_dir)\nEnvironmental multithreading number of threads (Optional, defaults to 1 thread; env_threads)\nPath to CDE executable (Optional, defaults to CDE packaged within CDEjll; `cdeexec`)\nSeed for CDE's RNG (Optional, setting to 0 indicates seed should be random; sampling_seed)\nRadius for exploration of breakdown space (Optional, Default = 50; radius)\nNumber of mechanisms to generate within a single CDE run (Optional, Default = 1; nrxn)\nNumber of parallel CDE runs to execute (Optional, Default = 1; parallel_runs)\nMaximum number of parallel CDE executables to run at any time (Optional, Default = 1; parallel_exes)\nWhether to write CDE's stdout to file (Optional, Default = false; write_stdout)\nWhether to write CDE's stderr to file (Optional, Default = false; write_stderr)\nWhether to allow functions to continue running if CDE errors are detected (Optional, Default = false; allow_errors)\n\nAdditionally, some fields are usually modified within Kinetica, and are not intended to be changed by users.\n\nMain reaction directory (rdir)\nXYZ file of starting molecule/material (init_xyz)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/exploration/#Kinetica.ingest_cde_run","page":"Exploration","title":"Kinetica.ingest_cde_run","text":"ingest_cde_run(rdir::String, rcount[, fix_radicals=true])\n\nReads in the results from a CDE run.\n\nSeparates out fragment species from each available reaction's reactants and products, forming arrays of their SMILES strings and ExtXYZ geometries.\n\nOBCanonicalRadicals can be enabled to tidy up radical SMILES using the fix_radicals parameter.\n\nReturns reac_smis, reac_xyzs, reac_systems, prod_smis, prod_xyzs, prod_systems, dH, where:\n\nreac_smis and prod_smis are arrays of the SMILES of each reaction's reactants and products;\nreac_xyzs and prod_xyzs are their corresponding geometries as ExtXYZ frames; \nreac_systems and prod_systems are the ExtXYZ frames of the systems of molecules that came out of CDE;\ndH is an array of reaction energies.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Kinetica.import_mechanism","page":"Exploration","title":"Kinetica.import_mechanism","text":"import_mechanism(rdir::String, rcount[, max_molecularity=2])\n\nCreate a CRN's initial SpeciesData and RxData from a CDE generated mechanism(s).\n\nReads in the results of a CDE run at the rcount reaction directory under rdir. Returns a new SpeciesData and RxData containing the unique species and reactions within these results, provided these reactions do not exceed the maximum molecularity set by max_molecularity, which defaults to only accepting unimolecular and bimolecular reactions.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Kinetica.import_mechanism!","page":"Exploration","title":"Kinetica.import_mechanism!","text":"import_mechanism!(sd::SpeciesData, rd::RxData, rdir::String, rcount[, max_molecularity=2])\n\nExtend a CRN's SpeciesData and RxData from a CDE generated mechanism(s).\n\nReads in the results of a CDE run at the rcount reaction directory under rdir. Extends sd and rd with the unique  species and reactions within these results, provided these  reactions do not exceed the maximum molecularity set by  max_molecularity, which defaults to only accepting unimolecular and bimolecular reactions.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Kinetica.import_network","page":"Exploration","title":"Kinetica.import_network","text":"import_network(rdir_head::String)\n\nImports a network from a level tree within rdir_head.\n\nRecurses through level directories in rdir_head, then recurses through subspace directories in each level. Within each subspace, imports all mechanisms within each CDE run.\n\nReturns the resulting network (an instance of SpeciesData and  RxData).\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Exploration","page":"Exploration","title":"Exploration","text":"","category":"section"},{"location":"api/kinetica/exploration/","page":"Exploration","title":"Exploration","text":"Kinetica.ExploreLoc\npathof(::Kinetica.ExploreLoc)\nKinetica.find_current_loc\nDirectExplore\nIterativeExplore\nexplore_network\nKinetica.load_past_seeds\nKinetica.load_current_seeds\nKinetica.identify_next_seeds","category":"page"},{"location":"api/kinetica/exploration/#Kinetica.ExploreLoc","page":"Exploration","title":"Kinetica.ExploreLoc","text":"ExploreLoc(rdir_head::String, level::Int, subspace::Int)\n\nContainer for iterative exploration location data.\n\nStruct contains fields for:\n\nHead directory of CRN ('rdir_head`)\nCurrent level index within head directory (level)\nCurrent subspace index within level (subspace)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/exploration/#Base.pathof-Tuple{Kinetica.ExploreLoc}","page":"Exploration","title":"Base.pathof","text":"pathof(loc::ExploreLoc[, to_level=false])\n\nReturns the path of the current subspace in the current level in the head directory specified by loc.\n\nIf to_level=true, only returns the path to the current level, excluding the current subspace.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/exploration/#Kinetica.find_current_loc","page":"Exploration","title":"Kinetica.find_current_loc","text":"find_current_loc(rdir_head::String)\n\nFinds the current exploration location in a partially explored CRN.\n\nReturns an ExploreLoc for the current exploration location.\n\nLooks for level directories within rdir_head. If none are found, points to the initial subspace of the initial level. Otherwise finds the latest level with a 'seeds.in' file. If subspaces are not found within this level, points to the initial subspace of this level. Otherwise finds the latest subspace without an 'isconv' convergence file, and points here. If all subspaces in this level are converged, emits a warning and points to the last subspace in this level.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Kinetica.DirectExplore","page":"Exploration","title":"Kinetica.DirectExplore","text":"DirectExplore(rdir_head::String, reac_smiles::Vector{String}, cde::CDE[, \n              maxiters::Int=1000, rxn_convergence_threshold::Int=5,\n              modify_network_on_solve::Bool=true])\n\nKeyword-based container for parameters used in direct CRN exploration.\n\nContains fields for:\n\nTop level of CRN exploration directory (rdir_head)\nSMILES string(s) of main breakdown reactant(s) being studied (reac_smiles)\nCDE instance (cde)\nMaximum number of iterations to perform (maxiters)\nNumber of iterations with no change in reactions to consider as converged (rxn_convergence_threshold)\nWhether to allow CRN modification after solving (modify_network_on_solve)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/exploration/#Kinetica.IterativeExplore","page":"Exploration","title":"Kinetica.IterativeExplore","text":"IterativeExplore(rdir_head::String, reac_smiles::VEctor{String}, cde::CDE[, maxiters::Int=1000, \n                 rxn_convergence_threshold::Int=5, seed_convergence_threshold::Int=3, seed_conc=0.05,\n                 n_undirected_levels::Int=0, independent_blacklist::Vector{String}=[], \n                 inert_species::Vector{String}=[], modify_network_on_solve::Bool=true])\n\nKeyword-based container for parameters used in iterative kinetics-based CRN exploration.\n\nContains fields for:\n\nTop level of CRN exploration directory (rdir_head)\nSMILES string(s) of main breakdown reactant(s) being studied (reac_smiles)\nCDE instance (cde)\nMaximum number of iterations to perform (maxiters)\nNumber of subspace iterations with no change in reactions to consider a subspace converged (rxn_convergence_threshold)\nNumber of level iterations with no change in seeds to consider the network converged (seed_convergence_threshold)\nConcentration above which species will be selected as seeds each level (seed_conc)\nNumber of undirected levels of exploration to perform at the start (n_undirected_levels)\nBlacklist of species to avoid doing independent subspace explorations on (independent_blacklist)\nInert species that should not be considered for reaction (inert_species)\nWhether to allow CRN modification after solving (modify_network_on_solve)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/exploration/#Kinetica.explore_network","page":"Exploration","title":"Kinetica.explore_network","text":"explore_network(exploremethod::DirectExplore, solvemethod[, savedir])\nexplore_network(exploremethod::IterativeExplore, solvemethod[, savedir])\n\nRuns network exploration with one of the available methods.\n\nIf exploremethod isa DirectExplore, runs a single-level network exploration to attempt to locate all relevant reactions in a radius of exploremethod.cde.radius species from the starting system.\n\nIf exploremethod isa IterativeExplore, runs a multi-level iterative network exploration using kinetic simulations to identify seed species for successive levels, in order to fully characterise the reaction space relevant to the conditions in solvemethod.conditions.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Kinetica.load_past_seeds","page":"Exploration","title":"Kinetica.load_past_seeds","text":"load_past_seeds(loc::ExploreLoc)\n\nLoads in SMILES of all seeds from previous levels.\n\nReturns an array of these SMILES.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Kinetica.load_current_seeds","page":"Exploration","title":"Kinetica.load_current_seeds","text":"load_current_seeds(loc::ExploreLoc)\n\nLoads in SMILES of all seeds from current level.\n\nReturns an array of these SMILES.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Kinetica.identify_next_seeds","page":"Exploration","title":"Kinetica.identify_next_seeds","text":"identify_next_seeds(sol, sd::SpeciesData, seed_conc<:AbstractFloat[, elim_small_na::Int=0, \n                    ignore::Vector{String}=[], saveto::Union{String, Nothing}=nothing])\nidentify_next_seeds(sol, sd::SpeciesData[, elim_small_na::Int=0, ignore::Vector{String}=[],\n                    saveto::Union{String, Nothing}=nothing])\n\nSelects seed species for the next level of network exploration.\n\nIdentifies species in sol with a maximum concentration above seed_conc and returns an array of the SMILES of these species. If seed_conc is not provided, assumes all species in sd should become seeds.\n\nSpecies meeting selection criteria can be manually ignored by including their SMILES in the ignore argument. Similarly, if species below a certain number of atoms are not desired as seeds (e.g. if they are too small to break down), this number of atoms can be set with elim_small_na.\n\nIf saveto is set to a file path, the selected seeds and their maximum concentrations are output to this file (usually generated automatically as a 'seeds.out' file in the current  level of exploration).\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Molecule-System","page":"Exploration","title":"Molecule System","text":"","category":"section"},{"location":"api/kinetica/exploration/","page":"Exploration","title":"Exploration","text":"system_from_smiles\nsystem_from_mols\nKinetica.molsys_opt","category":"page"},{"location":"api/kinetica/exploration/#Kinetica.system_from_smiles","page":"Exploration","title":"Kinetica.system_from_smiles","text":"system_from_smiles(smiles::String[, dmin::Float64=5.0, maxiters::Int=200])\nsystem_from_smiles(smiles::String[, saveto::String, dmin::Float64=5.0, maxiters::Int=200])\n\nForms a single XYZ system out of the molecules in smiles.\n\nUseful for making unified molecular systems with no overlap for feeding into CDE. smiles should be a single String with individual species separated by '.'. dmin represents the minimum molecule-molecule distance that should be allowed.\n\nIf the argument saveto is provided, outputs the optimised system to a file at this path. If not, returns the optimised system as a single ExtXYZ dict.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Kinetica.system_from_mols","page":"Exploration","title":"Kinetica.system_from_mols","text":"system_from_mols(mols::Vector{Dict{String, Any}[, dmin::Float64=5.0, maxiters::Int=200])\nsystem_from_mols(mols::Vector{Dict{String, Any}[, saveto::String, dmin::Float64=5.0, maxiters::Int=200])\n\nForms a single XYZ system out of the molecules in mols.\n\nUseful for making unified molecular systems with no overlap for feeding into CDE. mols should be a Vector of ExtXYZ frames. dmin represents the minimum molecule-molecule  distance that should be allowed.\n\nIf the argument saveto is provided, outputs the optimised system to a file at this path. If not, returns the optimised system as a single ExtXYZ dict.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Kinetica.molsys_opt","page":"Exploration","title":"Kinetica.molsys_opt","text":"molsys_opt(mols::Vector{Dict{String, Any}}, dmin::Float64, maxiters::Int)\n\nOptimises positions of molecules in mols to ensure they are all at least dmin Angstroms apart.\n\nCreates and solves an N-body spring-driven particle system and transforms molecular coordinates to these particles to check for proximity.\n\nReturns a new translated Vector of molecules when finished.\n\n\n\n\n\n","category":"function"},{"location":"development/crn-representation/#crn_representation_page","page":"CRN Representation","title":"CRN Representation","text":"","category":"section"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"As noted in many of the main tutorials, Kinetica represents CRNs through two structs:","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"SpeciesData, which holds information on the species within a CRN including their SMILES representations, integer IDs and their geometries (stored as ExtXYZ.jl frame::Dict{String, Any}).\nRxData, which holds information about the reactions within a CRN including the integer IDs of the species within each reaction's reactants and products, the stoichiometries of these species, the atom-mapped reaction SMILES of each reaction, and unique hashes that can ensure reactions are not duplicated, irrespective of species ordering.","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"These are split into two rather than making a single unified CRN struct because:","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"Situations often arise where only data regarding species or reactions are needed.\nThis allows dedicated methods of base Julia functions such as push! and splice! to be easily added for adding/removing species and reactions.\nA unified CRN struct could easily become quite bloated.","category":"page"},{"location":"development/crn-representation/#Representing-Species-(SpeciesData)","page":"CRN Representation","title":"Representing Species (SpeciesData)","text":"","category":"section"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"At the core of SpeciesData is a bidirectional mapping between species IDs and their respective SMILES representations within its toStr and toInt fields (which are just Dicts mapping ID to SMILES and SMILES to ID respectively). This mapping facilitates going back and forth between a human-understandable format and one that Kinetica can use when automatically assembling systems of ODEs for kinetic simulations.","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"note: Species Within ODESystems\nWhen a CRN gets converted to a ModelingToolkit ODESystem, every species needs to have a symbolic representation that can be mapped to its concentration during kinetic simulations. While it may be natural to assume we'd simply use the species' SMILES representations here, these contain special characters that cannot be present in Symbols. To also facilitate simple scaling to any number of species, species are automatically mapped to time-dependent symbolic variables spec(t)[i], where i becomes an integer ID within the range 1:SpeciesData.n. This is one of the core reasons why this SMILES to ID mapping is required.","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"An instance of SpeciesData can be constructed in one of three ways:","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"From an array of SMILES strings and a corresponding array of geometries (ExtXYZ frames).\nFrom a single XYZ file containing one or more species.\nFrom a CDE mechanism exploration directory with import_mechanism (see later).\nAs an empty struct (correctly initialised, but with no species), with init_network.","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"Once created, more species can be added, again from SMILES and their respective geometries, or from other XYZ files, using various methods of push!(::SpeciesData, ...). These methods will all add species irrespective of whether they are already present. To only add new unique species, instead use the methods of push_unique!(::SpeciesData, ...).","category":"page"},{"location":"development/crn-representation/#Fields","page":"CRN Representation","title":"Fields","text":"","category":"section"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"Aside from the aforementioned toStr and toInt fields, SpeciesData structs can hold a wealth of information:","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"SpeciesData.n holds the total number of species that have been added.\nSpeciesData.xyz holds a Vector of species geometries, indexed by species ID, in ExtXYZ.jl frame format. These store the cartesian coordinates of all atoms within a species, but can be used to store additional information related to a species.\nSpeciesData.cache holds an empty Dict, which can be used to store temporary information related to a species. For example, caling [get_species_stats!] populates the cache with Dicts that map species IDs to properties including molecular weight and hard-sphere radius.","category":"page"},{"location":"development/crn-representation/#Use-of-SMILES","page":"CRN Representation","title":"Use of SMILES","text":"","category":"section"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"While SpeciesData admits any string-form identifier for species and uses this identifier as its method for testing if two species are identical, Kinetica as a whole currently uses SMILES as its only form of species identification. This is because SMILES is human-readable, and the vast majority of gas- and liquid-phase systems can be described using combinations of SMILES strings.","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"note: Solid-Phase Systems\nSupport for periodic solid-phase systems in Kinetica is not currently planned and would require a different identifier that supports representation of periodic systems. However, with such an identifier in hand, Kinetica could be modified for this purpose.","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"Using SMILES as an identifier does come with a significant downside though - as a 2D descriptor of molecular structure, SMILES is not capable of distinguising between different conformers of molecular species. It is however capable of representing unique cis-trans/E-Z isomers and enantiomers. ","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"Since Kinetica is primarily made for investigating CRNs for long-timescale kinetic processes, we therefore view this as less of a downside of SMILES, and more of a necessary coarse-graining step. While molecular species usually require significant energy to move between the types of stereoisomer that SMILES can represent (e.g. temporary breaking of a pi-bond to move between cis and trans isomers around a C-C double bond), the purely conformational changes that SMILES cannot represent typically come with very low energy barriers. As such, over long timescales, contributions from any but the most stable conformation of a given species should be almost negligible, as any conformational changes should occur incredibly quickly.","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"Representing species as SMILES and assuming reactions only occur between the lowest energy conformer of each species therefore eliminates the need to consider these conformational changes. However, care should be taken when calculating reaction rate constants to always use low-energy conformations of species.","category":"page"},{"location":"development/crn-representation/#Representing-Reactions-(RxData)","page":"CRN Representation","title":"Representing Reactions (RxData)","text":"","category":"section"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"RxData maintains its space efficiency by only encoding reactions using species' integer IDs. They are therefore necessarily constructed in conjunction with an existing SpeciesData, which must already contain the species that are in these reactions. They are therefore only constructed:","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"As an empty struct, with init_network.\nFrom arrays of reactant/product SMILES and reactant/product XYZ systems, alongside a SpeciesData.","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"To avoid the hassle of importing reactions from files, adding their species to a SpeciesData and then adding their reactions to an RxData, Kinetica alos provides shortcuts in the form of import_mechanism for starting new CRNs and import_mechanism! for extending existing ones. These will be covered in the next section below.","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"To extend existing RxData, push!(::RxData, ::SpeciesData, ...) should be used. This has an optional argument unique_rxns=true which can be used to ensure only unique reactions are added to a CRN.","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"To remove existing reactions from an RxData, splice!(::RxData, ::Vector{Int}) can be used. This allows users to specify a Vector of integer reaction IDs to be specified, and will remove these reactions from the CRN while shifting the remaining reactions back along each of the fields of RxData to form reactions with new IDs (much like how Julia's default splice! works on regular arrays).","category":"page"},{"location":"development/crn-representation/#Fields-2","page":"CRN Representation","title":"Fields","text":"","category":"section"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"Instances of RxData contain the following fields:","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"RxData.nr counts the number of reactions currently in the struct.\nRxData.mapped_rxns holds the atom-mapped reaction SMILES representations of each reaction in the struct. These can be useful for generating correctly atom-indexed reactant/product systems (see Analysing the CRN for an example).\nid_reacs and id_prods hold Vectors of the unique reactant/product IDs in each reaction. For example, if the CRN's SpeciesData dictated that species \"CC\" had ID 1 and \"[CH3]\" had ID 2, and reaction 5 was CC -> 2 [CH3] (heterolytic cleavage of ethane), then id_reacs[5] == [\"CC\"] and id_prods[5] == [\"[CH3]\"].\nstoic_reacs and stoic_prods hold Vectors of the stoichiometry of each species in the reactions in id_reacs and id_prods respectively. This is why in the above example, id_prods[5] does not contain two \"[CH3]\"s - because stoic_reacs[5] == [1] and stoic_prods[5] == [2].\ndH holds each reaction's enthalpy of reaction, Delta H_r, as calculated by the level of electronic structure theory used within CDE during reaction generation.\nrhash holds a unique reaction hash for every reaction in the struct. This is calculated by taking the sha256 of the concatenation of the sorted reactant and product SMILES, and is used for checking whether new reactions are duplicates of any others already in the struct.","category":"page"},{"location":"development/crn-representation/#New-Reaction-Criteria","page":"CRN Representation","title":"New Reaction Criteria","text":"","category":"section"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"When adding new reactions to RxData, Kinetica performs a few checks. Reactions are discarded if they:","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"Only contain conformational changes. Species are internally represented by SMILES, so any changes not representable by SMILES (e.g. single bond rotations) lead to species being classed as the same. Note that E/Z isomers and enantiomers are distinct from one another in SMILES.\nExceed the maximum molecularity. By default this is 2, so only unimolecular and bimolecular reactions are allowed to enter a CRN. This is controllable by the max_molecularity argument when constructing or push!ing to RxData.\nAlready exist in the RxData they are being added to, provided unique_rxns=true. This is checked by comparing a reaction's unique hash to those currently in the CRN.","category":"page"},{"location":"development/crn-representation/#CRN-File-Structure","page":"CRN Representation","title":"CRN File Structure","text":"","category":"section"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"Chemical reactions are generated in Kinetica using CDE. When calling CDE, XYZ files for each of the generated reactions are output into a given working directory. During CRN exploration, Kinetica automatically lays out a directory tree for these reactions to be explored in based on a main 'head' directory rdir_head, as well as the current level and subspace of exploration (see Iterative CRN Exploration) and the current iteration of exploration within that subspace rcount. At any given time during CRN exploration (expect in between levels, when kinetic simulations are being performed), Kinetica will be running CDE at","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"\"$(rdir_head)/level_$(lpad(level, 3, \"0\"))/subspace_$(lpad(subspace, 3, \"0\"))/reac_$(lpad(rcount, 5, \"0\"))\"","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"This location is held and accumulated within an instance of Kinetica.ExploreLoc during CRN explorations, which implements a method pathof(::Kinetica.ExploreLoc) to quickly create this path.","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"Once a given CDE iteration is complete and there are new reactions at the current rcount, Kinetica reads these reactions in and adds them to the current CRN. It does this by calling import_mechanism!, which does the following:","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"Reads in all final reaction XYZs from the current exploration directory and processes them into separable reactant/product SMILES and ExtXYZ frames using ingest_cde_run.\nAdds all newly discovered species to the current SpeciesData using push_unique!(::SpeciesData).\nAdds all newly discovered reactions to the current RxData using push!(::RxData, ::SpeciesData, ...; unique_rxns=true).","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"note: Reverse Reactions\nWhen ingest_cde_run is called to import all reactions in a CDE run into Kinetica, it automatically adds their reverse reactions too! In this way, we preserve the principle of detailed balance within our CRN.","category":"page"},{"location":"development/crn-representation/#Checkpoints-and-Status-Files","page":"CRN Representation","title":"Checkpoints and Status Files","text":"","category":"section"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"Once exploration within a subspace is complete, Kinetica writes a small file called isconv to the subspace's directory. This acts as a checkpoint signal that tells Kinetica that this subspace is converged (completed) if it ever needs to re-import this CRN from its file tree. This can occur when CRN exploration is ended early, for example due to an error or a lack of walltime, and the Julia process is ended.","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"If the same exploration script is run again and the directory structure is unchanged, Kinetica will be able to pick up on the latest isconv file and know that this was the last completed subspace with Kinetica.find_current_loc. It can then import the currently explored CRN with import_network and continue from the next subspace.","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"Similarly, during iterative CRN explorations, Kinetica leaves behind files containing information about the seed species that should form the subspaces in each level. These seeds.in files are placed in each level's directory upon level creation, and similarly act as important markers for determination of exploration location within Kinetica.find_current_loc. However, they are mainly used so that Kinetica can know which seed species have had their self-reactions fully explored in previous levels (Kinetica.load_past_seeds), and which seed species are responsible for the subspaces in the current level (Kinetica.load_current_seeds).","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"Once a level's exploration is complete and Kinetica has finished a kinetic simulation to determine the next seed species, it calls Kinetica.identify_next_seeds. This uses concentration criteria defined in IterativeExplore to choose species with kinetic relevance to the overall CRN. Upon identification of these seeds, Kinetica writes a seeds.out file to the current exploration's savedir (provided savedir is given as a keyword argument when calling explore_network). This file is not currently used for restarting explorations, but can be used to monitor the progress of the current CRN exploration.","category":"page"},{"location":"tutorials/saving-loading/#Saving-and-Loading","page":"Saving & Loading","title":"Saving & Loading","text":"","category":"section"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"Kinetica allows for saving and loading ODESolveOutput objects (see Results Analysis) in a binary JSON (BSON) format using the BSON.jl package. This allows for generated CRNs and the parameters and results of kinetic simulations to be serialised and efficiently stored, while also being usable in new Julia sessions and retaining the analysis tools detailed in Results Analysis.","category":"page"},{"location":"tutorials/saving-loading/#Saving","page":"Saving & Loading","title":"Saving","text":"","category":"section"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"When performing a CRN exploration, saving is handled automatically by passing a directory to the savedir keyword argument of explore_network, as was demonstrated in Getting Started. However, ODESolveOutputs can also be saved manually using the save_output function:","category":"page"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"# res = solve_network(solvemethod, sd, rd)\nsave_output(res, \"/path/to/saved_output.bson\")","category":"page"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"note: Save Path\nUnlike the savedir argument of explore_network, the path provided to save_output should be to a file ending in .bson, rather than to a directory, since only a single CRN is being saved (rather than the multiple checkpoints saved by iterative CRN explorations).","category":"page"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"Saving simulation outputs this way destructures them into core Julia objects only - mostly Vectors, Dicts and Arrays. This allow them to be loaded back in under any Julia environment, even those where Kinetica or DifferentialEquations.jl (which ODESolveOutputs makes heavy use of types from) are not loaded. However, this does necessitate discarding some of the internals of objects such as ConditionSets and DiffEq's ODESolutions which are not easily serialised.","category":"page"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"warning: Unsaved Fields\nAmong the data that will be lost on saving are:Anything in ODESolveOutput.sd.cache, as the contents of this cache are intentionally undefined and therefore difficult to serialise correctly. This will be replaced with an empty Dict upon loading.\nAny Julia functions within variable condition profiles, i.e. the f field within AbstractDirectProfiles and the grad field within AbstractGradientProfiles. Functions are not directly serialisable within BSON.\nThe exact ODE solver used within ODESolveOutput.pars.solver, as this is always an external type. This will be replaced with a Symbol representing the type of solver for reference of what was used within the attached simulation.\nAny DiffEq ODESolutions such as ODESolveOutput.sol will lose their underlying ModelingToolkit representations, as only the sol.u and sol.t fields will be saved. These are reconstructed as DiffEqArrays when loaded back in.Note that no information about the kinetic calculator used within the simulation is saved either. Calculator implementation varies too much to be consistently serialised so it is intentionally left out of ODESolveOutput. It can be very useful to save some of the information stored within calculators and this is entirely possible with BSON.jl, but this is left to the user.","category":"page"},{"location":"tutorials/saving-loading/#Loading","page":"Saving & Loading","title":"Loading","text":"","category":"section"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"Saved CRN results can be loaded back in to Julia through two methods. If loaded back in using Kinetica's load_output function, the serialised BSON gets reconstructed into a new ODESolveOutput. Taking the CRN we generated and simulated in Getting Started as an example:","category":"page"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"using Kinetica\n\nres = load_output(\"../my_CRN_out/direct_network_final.bson\");\nnothing # hide","category":"page"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"note: Suppressing Output\nWhen called in an interactive session, load_output will produce a lot of output detailing the ODESolveOutput object. To suppress this, the load call can be ended with a semicolon, like above.","category":"page"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"While every effort is made to maintain compatibility between saved outputs between Kinetica versions, we cannot guarantee that the internal structure of ODESolveOutputs will never change. If this happens in a way that cannot be worked around when reconstructing within load_output, or if you wish to load the data in an environment without Kinetica, the output can still be loaded in as a raw BSON Dict tree:","category":"page"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"using BSON\nout_raw = BSON.load(\"../my_CRN_out/direct_network_final.bson\")","category":"page"},{"location":"tutorials/saving-loading/","page":"Saving & Loading","title":"Saving & Loading","text":"This allows users to flexibly access generated CRNs and kinetic simulation results, even when Kinetica is unavailable.","category":"page"},{"location":"development/implementation-details/#Implementation-Details","page":"Implementation Details","title":"Implementation Details","text":"","category":"section"},{"location":"development/implementation-details/","page":"Implementation Details","title":"Implementation Details","text":"The purpose of this page is to expand on the definition and implementation of some of the features in Kinetica that appear in other pages within this documentation. Sections here are not critical to the understanding of how to use parts of Kinetica, but may be necessary for development purpooses.","category":"page"},{"location":"development/implementation-details/#implementation_chunkwise_time","page":"Implementation Details","title":"Chunkwise Time","text":"","category":"section"},{"location":"development/implementation-details/","page":"Implementation Details","title":"Implementation Details","text":"Chunkwise simulation time is mentioned primarily in the tutorial on ODE Solution. It is a workaround to a floating point underflow issue that is caused by accumulating extremely small timesteps onto a relatively large global simulation time (GST), t_textglobal. ","category":"page"},{"location":"development/implementation-details/","page":"Implementation Details","title":"Implementation Details","text":"To be more precise, assuming t_textglobal is represented by an IEEE 64-bit floating point number (i.e. a Float64) where the smallest precision that is computationally representable epsilon = 2^-53 simeq 10^-16. The smallest value that can be added at any given time is therefore t_textglobal epsilon. When very small timesteps are being taken and the GST is large, underflow occurs.","category":"page"},{"location":"development/implementation-details/","page":"Implementation Details","title":"Implementation Details","text":"In practice, the impact of this problem can be seemingly minimal, with most simulations running without issue. However, closer inspection of the timesteps being taken reveals that floating point underflow can still occur in otherwise convergent simulations. We theorise that this is actually due to x86-64 processors allowing for a limited set of computations to take place on extended precision 80-bit floating point numbers where epsilon=2^63approx10^-18 when necessary, which only appear to underflow when being converted back to Float64 in memory. However, this is slower than performing the respective 64-bit operations and is entirely implementation and platform-dependent, should not be relied upon to always work.","category":"page"},{"location":"development/implementation-details/","page":"Implementation Details","title":"Implementation Details","text":"Enabling chunkwise time (ODESimulationParams.solve_chunks=true) therefore splits the overall simulation timespan (ODESimulationParams.tspan) into 'chunks' of local time, each of length ODESimulationParams.solve_chunkstep, or tau_c.","category":"page"},{"location":"development/implementation-details/","page":"Implementation Details","title":"Implementation Details","text":"warning: Uneven Chunk Splits\nCurrently, Kinetica only supports splitting simulations into chunks with the same tau_c. This means that ODESimulationParams.tspan[2] - ODESimulationParams.tspan[1] must be evenly divisible by ODESimulationParams.solve_chunkstep, such that an integer number of chunks are created.","category":"page"},{"location":"development/implementation-details/","page":"Implementation Details","title":"Implementation Details","text":"The first simulation chunk is initialised with species concentrations mathbfc=mathbfc_0, t_textglobal=00, local simulation time (LST) t_textlocal=00 and number of chunks n_c = 0. Integration of species concentrations then proceeds with respect to t_textlocal until t_textlocal=tau_c, at which point the concentrations and their respective LSTs are saved to a global-time array. In this array, t_textglobal is calculated as","category":"page"},{"location":"development/implementation-details/","page":"Implementation Details","title":"Implementation Details","text":"t_textglobal = t_textlocal + tau_c n_c","category":"page"},{"location":"development/implementation-details/","page":"Implementation Details","title":"Implementation Details","text":"and species concentrations and times are interpolated onto a grid of save times","category":"page"},{"location":"development/implementation-details/","page":"Implementation Details","title":"Implementation Details","text":"mathbft_textsaves=left( tau_textsaven right)_n=0^tau_ctau_textsave","category":"page"},{"location":"development/implementation-details/","page":"Implementation Details","title":"Implementation Details","text":"where tau_textsave is simply ODESimulationParams.save_interval.","category":"page"},{"location":"development/implementation-details/","page":"Implementation Details","title":"Implementation Details","text":"The solver is then reinitialised at t_textlocal=00 with mathbfc=mathbfc_textfinal, where mathbfc_textfinal is the species concentrations at the end of the previous chunk, and n_c is incremented. This continues until t_textglobal reaches ODESimulationParams.tspan[2]. By replacing t_textglobal with a t_textlocal that can never become very large during timestep accumulation, timesteps can be safely taken down to values of tau_c epsilon. This allows long-timescale, high-rate simulations to proceed unhindered by floating point underflow.","category":"page"},{"location":"development/implementation-details/#implementation_adaptive_tolerance","page":"Implementation Details","title":"Adaptive Solver Tolerance","text":"","category":"section"},{"location":"development/implementation-details/","page":"Implementation Details","title":"Implementation Details","text":"When solving ODESystems, adaptive timestepping ODE solvers requires two tolerances (abstol and reltol, given within Kinetica through ODESimulationParams.abstol and ODESimulationParams.reltol respectively) which control the numeric error allowed within the solver. A balance must be struck with these tolerances, as setting very low values increases solution accuracy, at the cost of taking many more small timesteps in order to achieve this.","category":"page"},{"location":"development/implementation-details/","page":"Implementation Details","title":"Implementation Details","text":"By default, these tolerances are set at the start of a simulation and remain constant throughout. This can be a problem if the solver runs into an area of the simulation where an accurate solution cannot be obtained at the current tolerances, as the solver will throw an error and crash. To avoid this, Kinetica implements an adaptive-tolerance solution method based around DifferentialEquations.jl's integrator interface. This method is enabled with the ODESimulationParams.adaptive_tols parameter.","category":"page"},{"location":"development/implementation-details/","page":"Implementation Details","title":"Implementation Details","text":"This method takes a pre-assembled integrator, and attempts to solve the underlying ODEProblem at the initially requested tolerances. If this is not possible, abstol and reltol are decreased by a factor of 10, reducing numerical error at the cost of a more expensive simulation. The tolerances are decreased until one or both fall below the precision of the numeric type used within the simulation, at which point an error will be returned as the simulation cannot be solved. An error is also returned if more than five tolerance changes have been attempted, to avoid needlessly running expensive, impossible simulations.","category":"page"},{"location":"development/implementation-details/","page":"Implementation Details","title":"Implementation Details","text":"If the solver tolerances need to be modified during adaptive tolerance solution and ODESimulationParams.update_tols=true, the changes to the tolerances will be echoed back to the ODESimulationParams object returned within the simulation's ODESolveOutput, which can be useful if similar simulations need to be rerun with the same parameters, as the solver tolerances will stay at workable values.","category":"page"},{"location":"development/implementation-details/","page":"Implementation Details","title":"Implementation Details","text":"note: Adaptive tolerance in chunkwise simulations\nThe behaviour enabled with ODESimulationParams.update_tols=true is usually not desired when running simulations with chunkwise time. Decreased solver tolerances are often only required in localised areas of time within kinetic simulations where reactions are proceeding exceptionally quickly and there are very large changes in species concentrations. As such, decreased tolerances may only be necessary within a few simulation chunks, while the rest of the simulation can get by with a higher tolerance (and therefore a faster solve time within these chunks). By not updating the tolerances within ODESimulationParams, each simulation chunk starts at the default tolerances and only reduces them if necessary.","category":"page"},{"location":"development/implementation-details/#implementation_low_rate","page":"Implementation Details","title":"Removing Low-Rate Reactions","text":"","category":"section"},{"location":"development/implementation-details/","page":"Implementation Details","title":"Implementation Details","text":"When assembling a generated CRN into a system of ODEs to be integrated, some reactions can be purposefully left out if they have sufficiently low rates. This can be triggered with the ODESimulationParams.low_k_cutoff parameter by giving it a value other than :none. This calculates the maximum rate constant for every reaction, and reactions are then removed from the CRN if this maximum rate is below the cutoff. Setting the cutoff to :auto predicts a safe value, where maximum rates below this value will never change any species concentrations. This is checked by making sure that if a given reaction were to run at its maximum rate over the entire duration of the requested simulation (ODESimulationParams.tspan[2], t_textglobal) with maximum reactant concentrations set by ODESimulationParams.low_k_maxconc (c^2_textmax), any generated species concentration would still be less than the ODE solver's relative tolerance (ODESimulationParams.reltol):","category":"page"},{"location":"development/implementation-details/","page":"Implementation Details","title":"Implementation Details","text":"textremove reaction  i text if  t_textglobal cdot c^2_textmaxk_i^textmax  reltol","category":"page"},{"location":"development/implementation-details/","page":"Implementation Details","title":"Implementation Details","text":"Maximum rates of reaction are calculated by enumeration over all permutations of maximum and minimum values of the conditions being calculated against. This should account for the vast majority of cases as rates are usually highest at extrema of experimental conditions.","category":"page"},{"location":"api/kinetica/analysis/#Kinetica.jl-API","page":"Analysis","title":"Kinetica.jl API","text":"","category":"section"},{"location":"api/kinetica/analysis/#Analysis","page":"Analysis","title":"Analysis","text":"","category":"section"},{"location":"api/kinetica/analysis/#CRN-I/O","page":"Analysis","title":"CRN I/O","text":"","category":"section"},{"location":"api/kinetica/analysis/","page":"Analysis","title":"Analysis","text":"ODESolveOutput\nsave_output\nload_output","category":"page"},{"location":"api/kinetica/analysis/#Kinetica.ODESolveOutput","page":"Analysis","title":"Kinetica.ODESolveOutput","text":"ODESolveOutput(solvemethod<:AbstractODESolveMethod, sol<:AbstractODESolution, sd::SpeciesData, rd::RxData)\n\nData container for output of CRN ODE solutions.\n\nBinds together all data required for analysis of network ODE solution results. Used as an input for many of the automated plotting functions in Kinetica.jl.\n\nAlso used for results IO, can be completely deconstructed into a package-independent dictionary tree for saving as binary JSON (BSON) with save_output. Can be reconstructed from such a BSON file with load_output.\n\nContains fields for:\n\nCRN SpeciesData after simulation (sd)\nCRN RxData after simulation (rd)\nKinetic simulation solution, usually a DiffEq ODESolution o/e (sol)\nDiffEqArray of precalculated rate constants, if discrete rate update method was used (sol_k)\nDict of DiffEqArrays for variable conditions, if solved simultaneously with species concentrations (sol_vcs)\nODESimulationParams used for kinetic simulation (pars)\nConditionSet used for kinetic simulation (conditions)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/analysis/#Kinetica.save_output","page":"Analysis","title":"Kinetica.save_output","text":"save_output(out::ODESolveOutput, saveto::String)\n\nSaves the output of a CRN ODE solution to BSON file.\n\nAvoids massive file sizes and attempts to maintain forward compatibility by breaking down large structs into their base arrays and values, such that they can be reconstructed when loaded back in.\n\nThe resulting BSON file is therefore a dictionary tree, which can be read in using only Julia's base library and OrderedCollections if all else fails using BSON.load directly.\n\nHowever, the original ODESolveOutput can be mostly reconstructed by instead calling load_output(). Some data is necessarily lost or converted to a Symbol for reference - mostly data concerning the internals of ODESolutions. \n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/analysis/#Kinetica.load_output","page":"Analysis","title":"Kinetica.load_output","text":"load_output(outfile::String)\n\nLoads in the results from a CRN ODE solution generated by save_output.\n\nReconstructs an ODESolveOutput from a dictionary tree in the BSON file outfile. Note that some data is lost in the serialisation process, see the documentation of save_output for details.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/analysis/#Graphing","page":"Analysis","title":"Graphing","text":"","category":"section"},{"location":"api/kinetica/analysis/","page":"Analysis","title":"Analysis","text":"Graph(::SpeciesData, ::RxData)","category":"page"},{"location":"api/kinetica/analysis/#Catalyst.Graph-Tuple{SpeciesData, RxData}","page":"Analysis","title":"Catalyst.Graph","text":"Graph(sd::SpeciesData, rd::RxData[, graph_attrs, species_attrs, rxn_attrs, edge_attrs, use_smiles=false, remove_inactive_species=true])\n\nCreates a Graphviz graph from the supplied CRN.\n\nCopies the functionality in Catalyst's ReactionSystem graphing utilities (see https://github.com/SciML/Catalyst.jl/blob/master/src/graphs.jl), but makes them usable on raw Kinetica CRNs. This includes reworking node names, as Symbolics.jl's 'arrays of symbolic expressions' are not currently supported in the Catalyst implementation.\n\nAlso extends this functionalty by allowing passing of graph attributes directly to Graphviz through the  graph_attrs keyword argument. When this is nothing, the default Catalyst graph (drawn using the dot layout) is returned. When given a Dict{Symbol, String} of  graph keywords, these are applied to the generated graph.\n\nSimilarly, node attributes for species and reaction nodes can be passed through species_attrs and rxn_attrs respectively. Global edge attributes can be passed through edge_attrs, but individual edges may still set their own properties.\n\nAdditionally allows for plotting with SMILES node labels. This is disabled by default, as many of the special characters in SMILES cannot currently be rendered properly.\n\nThe resulting Catalyst.Graph can be rendered in a notebook, or saved to file using Catalyst.savegraph, both of which are reexported by Kinetica.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Here we will demonstrate how to perform a simple CRN exploration using Kinetica. Simulations within Kinetica are designed to be run as a script, consisting of the following elements:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Parameter blocks,\nSimulation,\nAnalysis.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"We will begin by going through a basic example of each of these elements. Further details can be found in the Tutorials section of this documentation. ","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If you are attempting to recreate this tutorial for yourself, it relies on a few input files that are included in the main code repository. These files can be found in the examples directory, which can be accessed by cloning this repository:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"git clone https://github.com/Kinetica-jl/Kinetica.jl.git\ncd Kinetica.jl/examples","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"To start with the tutorial, load the main Kinetica.jl package:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using Kinetica","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"We'll also set a seed for Julia's random number generation, to ensure that this tutorial is fully reproducible. This can be ignored in regular use, but is useful here if you want to compare your results to those obtained here.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using Random\nRandom.seed!(12345)\nnothing # hide","category":"page"},{"location":"getting-started/#Parameter-Blocks","page":"Getting Started","title":"Parameter Blocks","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The initial part of Kinetica simulation scripts usually consist of 3-4 blocks of parameters, depending on whether or not the simulation consists of only a kinetic calculation on a pre-existing CRN or if it also requires a CRN exploration before such a calculation can take place.","category":"page"},{"location":"getting-started/#Simulation-Conditions","page":"Getting Started","title":"Simulation Conditions","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The first parameter block should be a ConditionSet, which defines the experimental conditions a kinetic calculation should take place under. This block is usually defined first as later parameters often depend on it.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"ConditionSet blocks allow for flexible definitions of any number of arbitrary conditions, each of which can be static (constant) or variable (time-dependent). For this simple CRN exploration, we will define a ConditionSet that specifies a linear temperature increase, from 300 K at time t = 0.0 to 1000 K at a rate of 50 K/s. Kinetica comes with a library of variable condition profiles, allowing this ConditionSet to be simply defined as follows:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"conditions = ConditionSet(Dict(\n    :T => LinearGradientProfile(;\n        rate = 50.0,\n        X_start = 500.0,\n        X_end = 1200.0\n    )\n))","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This generates a LinearDirectProfile for the linear temperature increase we are interested in, and binds it to the symbol :T for use within kinetic calculators. Further information on the types of condition profiles implemented in Kinetica can be found in the tutorial on Arbitrary Simulation Conditions.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"We will be able to visualise this condition profile shortly, but we must first define a parameter block of ODE solution parameters.","category":"page"},{"location":"getting-started/#Kinetic-Simulation-Parameters","page":"Getting Started","title":"Kinetic Simulation Parameters","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The ODESimulationParams block defines all of the parameters needed when converting a CRN to a system of ODEs and integrating it in time. This includes parameters such as the simulation timespan, initial concentrations of reactants and the ODE solver being used.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For the purposes of this tutorial, we will construct the following ODESimulationParams block:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using OrdinaryDiffEq\nusing Sundials\n\npars = ODESimulationParams(\n    tspan = (0.0, get_t_final(conditions)),\n    u0 = Dict(\"C\" => 1.0),\n    solver = CVODE_BDF(; linear_solver=:KLU)\n)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This block details the three essential parameters for any simulation in Kinetica:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"tspan: Simulation timespan (in seconds, unless otherwise specified within kinetic calculator). Must be a tuple of (start_time, end_time). Here, we fetch the end time directly from the ConditionSet defined above using get_t_final(conditions), which calculates the time at which all defined conditions have reached their final state.\nu0: Dictionary of initial concentrations. Here we define that kinetic simulations should start with 1.0 mol dm^-3 of methane (C in SMILES notation), and no other reactants.\nsolver: ODE solution algorithm to use, from those available in DifferentialEquations.jl. Here we load in the CVODE_BDF solver from the Sundials.jl library, as this has been the best general-purpose solver in our testing. The KLU linear solver allows this ODE solver to work with sparse arrays, which are enabled by default.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Further details of the parameters available in this block can be found in the ODE Solution section.","category":"page"},{"location":"getting-started/#CRN-Exploration-Parameters","page":"Getting Started","title":"CRN Exploration Parameters","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"In order to perform a CRN exploration, an exploration method must be chosen. Kinetica currently provides two: DirectExplore and IterativeExplore. For now we will use the former, as it is simpler.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"DirectExplore explores all chemical reactions within a given radius of the starting reactants, irrespective of whether or not they will occur within a later kinetic simulation under the selected environmental conditions. This method is best suited to small CRNs under kinetically slow conditions, where few reactions are possible and complete sampling of all available reactions is easy.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Reactions are sampled using CDE, an external code for graph-droven sampling of reactions that is included with Kinetica.jl. CDE has its own parameters which must be set, but these are usually very similar for most CRN explorations. As such, a directory of template inputs must be provided for CDE to function. We provide such a template directory with this documentation, which can be used to run this tutorial. If you have cloned this documentation's repository, as suggested at the start of this tutorial, these files are in KineticaDocs.jl/examples/cde_template.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Once this is done, the exploration parameters can be set up as follows:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"crn_dir = \"./my_CRN\"\n\nexploremethod = DirectExplore(\n    rdir_head = crn_dir,\n    reac_smiles = [\"C\"],\n    rxn_convergence_threshold = 5,\n    cde = CDE(\n        template_dir = \"../../examples/cde_template\",\n        radius = 5,\n        sampling_seed = 1\n    )\n)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The parameters defined in this block are as follows:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"rdir_head : This is the directory in which the raw CRN exploration files will be stored. We have defined crn_dir above because it will be useful to reference later. ","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"warning: I/O intensity\nMany CDE runs can be quite I/O-heavy, so it is useful to place this directory on a fast, directly-attached drive. Running the CRN exploration out of a network-attached spinning hard drive will probably be a bad time.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"reac_smiles: Array of SMILES strings representing reactants in the initial reactant system. These will be fed to CDE to generate reactions. In this case, we will generate all reactions that can occur between two methane molecules.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"note: The Iterative method works differently!\nWatch out for the meaning of these parameters changing slightly between DirectExplore and IterativeExplore. They can serve the same purpose, but methodologically do different things under the hood. See the tutorial on Iterative CRN Exploration for more information.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"rxn_convergence_threshold: How many CDE iterations to perform with no new reactions discovered before considering the CRN converged.\ncde: CDE parameter block using the example input templates (change this path to the directory you saved yours into). This defines a reactive radius of 5, meaning that all reactions within 5 steps of the reactant system will be generated. The sampling_seed parameter is usually not set, but we will set it here to make this tutorial reproducible. More information on this sub-block is also given in the Iterative CRN Exploration tutorial.","category":"page"},{"location":"getting-started/#Kinetic-Calculator","page":"Getting Started","title":"Kinetic Calculator","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The final parameter block to set up is the simulation's kinetic calculator. This is an object capable of calculating rate constants for every reaction in a CRN under a given set of conditions. Kinetic calculators are one of the core points of modularity in Kinetica, with extension packages like KineticaKPM.jl extending the functionality of the main code by adding in more calculators for different requirements.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The main Kinetica.jl package only includes one kinetic calculator, the PrecalculatedArrheniusCalculator. This calculator calculates temperature-dependent rate constants using the Arrhenius equation:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"k = Ae^-dfracE_aRT","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The PrecalculatedArrheniusCalculator requires vectors of Arrhenius prefactors A and activation energies Ea for all reactions before the code is executed, and as such is typically only used when a CRN has been generated and these values have been determined outside Kinetica. However, for the purposes of this tutorial (where the random seed for CDE's reaction generation has been set, see above), we know the reactions that are going to be generated in advance, so we have provided approximate values to input into this calculator. These values are in KineticaDocs.jl/examples/getting_started/arrhenius_params.bson, and can be loaded in with:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using BSON\ncalc_pars = BSON.load(\"../../examples/getting_started/arrhenius_params.bson\")","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"again, replacing this path with the equivalent path on your computer. The calculator for this CRN can now be constructed:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"calc = PrecalculatedArrheniusCalculator(calc_pars[:Ea], calc_pars[:A]; k_max=1e12)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For more advanced calculators that allow on-the-fly calculation of rate constants as reactions are generated, see the tutorial on Kinetic Calculators.","category":"page"},{"location":"getting-started/#Simulation","page":"Getting Started","title":"Simulation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Now that all of the parameter blocks have been constructed, we can start generating and simulating CRNs!","category":"page"},{"location":"getting-started/#Visualising-Condition-Profiles","page":"Getting Started","title":"Visualising Condition Profiles","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"First, now that we have both a ConditionSet and a ODESimulationParams block, we can have a look at the variable temperature profile that we created. To begin, we need to construct a DifferentialEquations ODESolution for this profile. Kinetica provides a shortcut for this, with a one-liner that constructs ODEProblems and solves them for every variable condition in a ConditionSet:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"solve_variable_conditions!(conditions, pars)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"note: Not neccessary in regular use!\nWe are manually triggering the solution of the ConditionSet here to visualise how the constructed temperature profile will look in the final simulation. However, calling solve_variable_conditions! as above is not neccessary in all Kinetica scripts. This function is normally run automatically before integrating the CRN ODEs, and does not typically need to be called like this.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"With this in place, we can now plot our temperature profile's ODESolution to see how the simulation temperature is going to vary with time:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"mkpath(\"assets/getting-started\") # hide\nusing Plots\nplot(get_profile(conditions, :T).sol)\nsavefig(\"assets/getting-started/Tprofile.svg\"); nothing # hide","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"As expected, the temperature profile we constructed goes from 300 K to 1000 K at a rate of 50 K/s. Provided we are happy with this, we can continue to perform a CRN exploration and a kinetic simulation.","category":"page"},{"location":"getting-started/#Running-the-Simulation","page":"Getting Started","title":"Running the Simulation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"CRN exploration and kinetic simulation are wrapped under a single function call: explore_network. This takes the exploration parameters, the simulation parameters and calculator (which we will wrap under a single variable), and optionally a directory to save the finished results to. These results will additionally be returned by the function. To run the entire simulation, we simply call the following:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"solvemethod = VariableODESolve(pars, conditions, calc)\nmkdir(\"./my_CRN_out\") # hide\nres = explore_network(exploremethod, solvemethod; savedir=\"./my_CRN_out\")\nnothing # hide","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"note: Checkpoints and Restarts\nIn the event that a Kinetica CRN exploration fails before completion, all is not lost! As long as you still have the original head directory that the CRN was being explored in (crn_dir in this tutorial), both of Kinetica's exploration algorithms will detect where you left off and restart from there seamlessly. In the iterative exploration algorithm, Kinetica also creates checkpoint files with current CRN state and kinetic simulation results, which are saved under the savedir keyword argument specified above along with the final simulation output.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The resulting ODESolveOutput object contains the explored CRN, the kinetic simulation results, and all of the parameters and conditions that went into it. These can be easily and efficiently saved and loaded as needed (see Saving & Loading).","category":"page"},{"location":"getting-started/#Analysis","page":"Getting Started","title":"Analysis","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The ODESolveOutput object has plot recipes defined for easy plotting using Plots.jl, allowing complex figures and statistics to be shown with a single line of code. To begin, we can look at how the concentrations of all of the species found during CRN generation vary over time under the variable temperature profile we specified. This is achieved by simply running","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"plot(res)\nsavefig(\"assets/getting-started/kinetics_plot.svg\"); nothing # hide","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This CRN presents some interesting results! Accoding to the kinetics enforced by the calculator we have used, methane will not start breaking down into any of the free radical species discovered within this CRN until t approx 5 text s. We could check the temperature that this occurs at by referencing the temperature profile we plotted above but this is also accessible from res by running","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"conditionsplot(res, :T)\nsavefig(\"assets/getting-started/Tprofile_2.svg\"); nothing # hide","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Notice how, because we used the conditionsplot() function, the correct symbolically-indexed condition profile was obtained and axis labels were set accordingly.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If we want to obtain the numeric value of the temperature at t approx 5 text s, we can interpolate this directly:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Tprofile = get_profile(res.conditions, :T)\nTprofile.sol(5.0)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If we had multiple variable condition profiles, the above could also be done for them by simply passing in their bound symbols.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Similarly, we can also obtain the concentrations of all of the species in the reaction mixture at any time in the simulation through interpolation:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"res.sol(5.0)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"It is also very useful to analyse the final concentrations of species at the end of a kinetic simulation. Kinetica defines another plot recipe for this:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"finalconcplot(res)\nsavefig(\"assets/getting-started/concs_plot.svg\"); nothing # hide","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"getting-started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Now you're familiar with the basics of network exploration and kinetic simulation within Kinetica, you can learn more by looking through the other tutorials! ","category":"page"},{"location":"development/calculator-interface/#Calculator-Interface","page":"Calculator Interface","title":"Calculator Interface","text":"","category":"section"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"For an introduction to Kinetica's kinetic calculators, which allow rate constant calculation under arbitrary experimental conditions of interest, see the tutorial on Kinetic Calculators. This page details the underlying implementation of these calculators in order to facilitate extension and development of new calculators.","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"All kinetic calculators implemented in Kinetica and its modules follow the same basic interface. They should consist of:","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"A (mutable) struct which holds all of the data that the calculator needs to calculate rate constants. This must be a subtype of Kinetica.AbstractKineticCalculator. Mutability is not a prerequisite, but is suggested as many calculators are designed to be updated further down the calculation chain.\nAn outer constructor which simplifies construction of the main struct, potentially offering optional arguments such as the ability to change the time unit the calculator works in. While not strictly necessary, this is recommended.\nA method of the setup_network! function which can be called with the calculator being implemented. This handled compatibility checking with the current CRN, as well as any additional calculation that needs to take place on a per-reaction basis (and therefore cannot be done during calculator construction).\nA method of splice!(calc::cType, rids::Vector{Int}) where cType<:Kinetica.AbstractKineticCalculator which can be called with the calculator being implemented. This enables data about unnecessary reactions to be deleted, mirroring the funcitonality of splice!(::RxData, ::Vector{Int}) for deletion of reactions from the current CRN.\nA method of allows_continuous for the calculator being implemented, which specifies if the calculator is allowed to be used in continuous rate update simulations (see ODE Solution).\nA method of has_conditions for the calculator being implemented, which checks if the experimental conditions in the current kinetic simulation are compatible with the calculator.\nFunctors of the calculator being implemented which calculate the rate constant of every reaction in the current CRN at a given set of experimental conditions. These must accept the experimental conditions of interest as keyword arguments.","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"As long as these are implemented, a new calculator will slot in seamlessly to Kinetica's arbitrary variable condition and CRN simulation frameworks.","category":"page"},{"location":"development/calculator-interface/#Implementation-Example","page":"Calculator Interface","title":"Implementation Example","text":"","category":"section"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"We will demonstrate the implementation of a new kinetic calculator with a somewhat contrived example that should nevertheless demonstrate all of the above points. This calculator will return rate constants that:","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"Are dependent on temperature :T and pressure :P as experimental conditions,\nCan be calculated with or without a maximum rate constant k_max,\nTake a base rate constant k_base and multiply it by the ratio of products to reactants in a given reaction, under the formula","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"k_r = fracn_pn_rk_textbase expleft-fracP10Tright","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"where n_p is the number of product molecules in a given reaction, and n_r is the number of reactant molecules.","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"Assuming the above equation yields rate constants in time units of s^-1, can be modified to work under other time units.","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"This rate constant contains no physical meaning, but will illustrate all of the requirements of a kinetic calculator very well.","category":"page"},{"location":"development/calculator-interface/#Calculator-Struct","page":"Calculator Interface","title":"Calculator Struct","text":"","category":"section"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"First, we must create the main calculator struct, which will hold user-facing parameters such as k_base and k_max that are set at calculator construction and are not intended to be modified much down the line, as well as internal parameters such as n_reacs and n_prods which are reaction-specific and will be calculated later. Assuming we're naming this calculator MyNewCalculator, this can be done as follows:","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"using Kinetica\n\nmutable struct MyNewCalculator{kmType, uType, tType} <: Kinetica.AbstractKineticCalculator\n    k_base::uType\n    n_reacs::Vector{Int}\n    n_prods::Vector{Int}\n    k_max::kmType\n    t_unit::String\n    t_mult::tType\nend","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"Here we've defined a Parametric Type, which allows us to both specialise to the numeric types of species concentrations uType (assuming we represent k_base with the same numeric type as our species concentrations) and of simulation time tType, as well as allowing us to use multiple dispatch based on whether or not we have a k_max using kmType down the line. These parameters are not necessary to create a functioning calculator, but we include them here for consistency with how most of Kinetica's calculators are curently implemented.","category":"page"},{"location":"development/calculator-interface/#Outer-Constructor","page":"Calculator Interface","title":"Outer Constructor","text":"","category":"section"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"While it's nice to keep the information for both what our time unit is t_unit and what it does to our rates t_mult for reference, one quantity can be derived from the other and therefore both do not need to be provided to construct our calculator. We may also want to establish some sensible defaults for both k_max and t_unit to avoid having to input them every time we need to construct a calculator. Finally, we also don't need to provide values to CRN-specific fields such as n_reacs and n_prods at construction time. These features can be achieved by implementing an outer constructor:","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"function MyNewCalculator(k_base::uType; k_max::Union{uType, Nothing}=nothing, \n                         t_unit=\"s\") where {uType <: AbstractFloat}\n    \n    t_mult = tconvert(t_unit, \"s\")\n    return MyNewCalculator(k_base, Int[], Int[], k_max, t_unit, t_mult)\nend\nnothing # hide","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"With this, we've now created a default state so that when a user calls calc = MyNewCalculator(k_base), the calculator creates empty arrays for n_reacs and n_prods, and automatically assumes there is no upper rate constant limit and we're working in rate units where time is measured in seconds. This instance of the calculator will be of type MyNewCalculator{Nothing, uType, tType}, allowing us to dispatch on a rate constant equation which excludes k_max. We've also enforced that the type of k_max (when provided) must be the same as that of k_base by making this constructor a Parametric Method, and that this type must be a subtype of AbstractFloat.","category":"page"},{"location":"development/calculator-interface/#Simulation-Setup","page":"Calculator Interface","title":"Simulation Setup","text":"","category":"section"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"So far we've taken care of the parameters that are specific to a given instance of our calculator, but what about the parameters that are specific to a CRN being simulated? In the above outer constructor, we've left n_reacs and n_prods (which represent the number of reactant and product molecules in each reaction) as empty integer arrays. We need these values to calculate our rate constants, so we'll need to populate these arrays within setup_network!.","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"setup_network! is a function that is always called early in a kinetic simulation under solve_network. It takes the current CRN as a set of SpeciesData and RxData objects, along with the given kinetic calculator, and modifies the internal state of the calculator to work with the CRN - in our example here, it will calculate and update n_reacs and n_prods:","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"function setup_network!(sd::SpeciesData, rd::RxData, calc::MyNewCalculator)\n    n_reacs = zeros(Int, rd.nr)\n    n_prods = zeros(Int, rd.nr)\n    # Number of reactant/product molecules is the sum of the \n    # reactant/product stoichiometries for each reaction.\n    for i in 1:rd.nr\n        n_reacs[i] = sum(rd.stoic_reacs[i])\n        n_prods[i] = sum(rd.stoic_prods[i])\n    end\n\n    calc.n_reacs = n_reacs\n    calc.n_prods = n_prods\n    return\nend\nnothing # hide","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"warning: Fixed Argument Structure\nAs setup_network! is intended to be called automatically as part of a chain of functions, it must always use the same call signature of (sd, rd, calc), even when one or more of these arguments is unused, as sd is here. Similarly, even if no calculator setup is required, an empty method must be implemented here so that normal CRN simulation can proceed.","category":"page"},{"location":"development/calculator-interface/#Calculator-Splicing","page":"Calculator Interface","title":"Calculator Splicing","text":"","category":"section"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"Sometimes, reactions are removed from CRNs as part of the kinetic simulation workflow (e.g. as part of a low-rate reaction cleanup, see low_k_cutoff in ODE Solution). Since this occurs after the calculator setup done in setup_network!, any reactions removed from a CRN's RxData through splice!(::RxData, ::Vector{Int}) must similarly be removed from any reaction-specific fields in the calculator (in our case, n_reacs and n_prods). This is done through a custom method of splice!(calc::cType, rids::Vector{Int}) where cType<:Kinetica.AbstractKineticCalculator:","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"function Base.splice!(calc::MyNewCalculator, rids::Vector{Int})\n    # Splice the underlying reaction-specific arrays.\n    splice!(calc.n_reacs, rids)\n    splice!(calc.n_prods, rids)\n    return\nend\nnothing # hide","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"warning: Required Implementation\nAs with setup_network!, a method of splice!(calc::cType, rids::Vector{Int}) where cType<:Kinetica.AbstractKineticCalculator must be implemented for every kinetic calculator, as it can be called as part of solve_network. ","category":"page"},{"location":"development/calculator-interface/#Continuous-Rate-Tagging","page":"Calculator Interface","title":"Continuous Rate Tagging","text":"","category":"section"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"Some calculators may have rate constant calculation functions that contain calls to external programs or are otherwise incompatible with representation as a Symbolics.jl-based expression through ModelingToolkit.jl. These calculators are not compatible with the continuous rate update formalism and must be run through discrete rate update simulations instead (see ODE Solution for details).","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"Kinetica prevents these calculators from being passed to an incompatible solution algorithm by checking the calculator's allows_continuous method. This simply returns a Bool stating whether the calculator should be allowed within continuous formalism simulaitons. In our example here, the rate constant function that we are going to implement can be represented in symbolic algebra by Symbolics, so we simply add:","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"allows_continuous(::MyNewCalculator) = true\nnothing # hide","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"note: Which rate expressions are allowed?\nIf you're new to Symbolics or ModelingToolkit, it may be unclear which rate expressions are or are not compatible with the continuous formalism. In some cases this may require some trial and error, but in most, if you can write out the algebraic form of the rate expression by hand, it can be made to be compatible. If you need to use loops, this won't work (vectorised operations are okay though). Don't worry if your rate expression isn't compatible - the discrete rate update formalism is usually much quicker to compile, and sometimes it's quicker to solve too!","category":"page"},{"location":"development/calculator-interface/#Argument-Pre-Checking","page":"Calculator Interface","title":"Argument Pre-Checking","text":"","category":"section"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"It's often useful to check far in advance if a kientic calculator is actually capable of working with the experimental conditions you're throwing at it. This is performed automatically by a method of has_conditions when the calculator and the ConditionSet first meet, in the inner constructor of StaticODESolve/VariableODESolve.","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"We must therefore implement such a method for our calculator, which lets Kinetica know which symbolic conditions are acceptable:","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"function has_conditions(::MyNewCalculator, symbols::Vector{Symbol})\n    return all([sym in [:T, :P] for sym in symbols])\nend\nnothing # hide","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"This way, if we were to provide a :V condition in our ConditionSet which our calculator wouldn't know what to do with, this would be caught early instead of causing problems deep into a difficult to diagnose solve_network call.","category":"page"},{"location":"development/calculator-interface/#Rate-Constant-Calculation","page":"Calculator Interface","title":"Rate Constant Calculation","text":"","category":"section"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"Finally, with the rest of the calculator out of the way, we can write our actual rate expressions. These are written as functors of our main calculator struct. Here, we will define two functors and allow Julia to dispatch to the correct one based on the type of calculator it receives. If the calculator's kmType is the same as its uType, we know that a value was provided for k_max and we need to dispatch on a modified version of the rate expression. Otherwise, if kmType is Nothing, we know there's no k_max and we can dispatch on the normal rate expression:","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"# Dispatching without k_max awareness.\nfunction (calc::MyNewCalculator{Nothing, uType, tType})(; T::Number, P::Number) where {uType, tType}\n    k_r = (calc.n_prods ./ calc.n_reacs) .* calc.k_base * exp(-P/(10*T)) * calc.t_mult\n    return k_r\nend\n\n# Dispatching with k_max awareness.\nfunction (calc::MyNewCalculator{uType, uType, tType})(; T::Number, P::Number) where {uType, tType}\n    k_r = (calc.n_prods ./ calc.n_reacs) .* calc.k_base * exp(-P/(10*T)) * calc.t_mult\n    return 1.0 ./ ((1.0 / calc.k_max) .+ (1.0 ./ k_r))\nend\nnothing # hide","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"Vitally important here are:","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"Experimental conditions must be passed in as keyword arguments, as Kinetica splats an array of Pairs of condition Symbols and their values (static parameters or variable expressions) into the calculator internally to enable arbirtary conditions to be passed to arbitrary calculators. This is accomplished by indicating that there are no positional arguments with a semicolon before listing the conditions.\nCalculator functors return rate constants for all reactions in a CRN simultaneously, so rate constant expressions typically make use of vectorised operations to make neat one-liners like those above.","category":"page"},{"location":"development/calculator-interface/#Checking-Our-Work","page":"Calculator Interface","title":"Checking Our Work","text":"","category":"section"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"That's it! Now we have everything implemented for a working (albeit non-physical and mostly useless) kinetic calculator. We can make sure it works by running all the above functions on a small CRN. We'll use the CRN that was created for Getting Started:","category":"page"},{"location":"development/calculator-interface/","page":"Calculator Interface","title":"Calculator Interface","text":"res = load_output(\"../my_CRN_out/direct_network_final.bson\")\nsd, rd = res.sd, res.rd\n\n# Test added methods.\ncalc = MyNewCalculator(2e5)\nprintln(\"Calculator allows continuous formalism: $(allows_continuous(calc))\")\nprintln(\"Calculator accepts conditions Z, P, V: $(has_conditions(calc, [:Z, :P, :V]))\")\nprintln(\"Calculator accepts conditions T, P: $(has_conditions(calc, [:T, :P]))\")\nsetup_network!(sd, rd, calc)\n@assert length(calc.n_reacs) == length(calc.n_prods) == rd.nr\nprintln(\"Pre-splice calculator contains info on $(rd.nr) reactions\")\nsplice!(rd, calc, collect(1:5)) # Remove first 5 reactions from rd and calc\n@assert length(calc.n_reacs) == length(calc.n_prods) == rd.nr\nprintln(\"Post-splice calculator contains info on $(rd.nr) reactions\")\n\n# Default calculator implementation.\ncalc = MyNewCalculator(2e5)\nsetup_network!(sd, rd, calc)\nk_default = calc(; T=1000.0, P=1e5)\n\n# Calculator with rate constants capped to 10 s-1\ncalc = MyNewCalculator(2e5; k_max=10.0)\nsetup_network!(sd, rd, calc)\nk_capped = calc(; T=1000.0, P=1e5)\n\n# Compare default and capped rate constants.\nusing Printf\nprintln(\"\\nRID  k_default  k_capped\")\nfor i in 1:rd.nr\n    println(\"$(rpad(string(i), 3, ' '))  $(@sprintf(\"%.9f\", k_default[i]))  $(@sprintf(\"%.9f\", k_capped[i]))\")\nend\nnothing # hide","category":"page"},{"location":"tutorials/kinetic-calculators/#Kinetic-Calculators","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"Kinetica allows for any and all rate constant expressions to be used within kinetic simulations through its modular kinetic calculator interface. This allows users and developers alike to quickly define a set of functions which are dependent on a CRN (through a SpeciesData and an RxData) and some arbitrary experimental conditions which the simulation takes place under, such as temperature and pressure, and to calculate rate constants. For more information on how kinetic calculators are implemented, see Calculator Interface.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"Kinetica features a single base calculator, the PrecalculatedArrheniusCalculator. This calculator relies on having Arrhenius prefactors and activation energies precalculated for every reaction in a CRN, and serves mostly as a test calculator and an implementation example. ","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"Other more useful calculators are provided as modular addon packages that extend Kinetica.jl (e.g. KineticaKPM.jl). Some calculators have extensive dependencies, so this modularisation allows for picking and choosing only the calculators required for a specific project rather than having every available calculator in one bloated Julia/Python environment.","category":"page"},{"location":"tutorials/kinetic-calculators/#Manually-Calling-Calculators","page":"Kinetic Calculators","title":"Manually Calling Calculators","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"The examples below all show how calculators can be manually called to calculate rate constants. This is useful when these values are required, e.g. for analysis, but is not required during kinetic simulations. Passing a calculator into explore_network or solve_network via a VariableODESolve struct (see the 'Running the Simulation' section of Getting Started) is enough to set up the calculator and evaluate rate constants as many times as is required by the simulation.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"In the event that a calculator is required to be called manually, the process is very simple. Once the calculator has been instantiated, it should be passed to its setup_network! method. All kinetic calculators implement such a function, which checks the values provided to the calculator are compatible with a given SpeciesData and RxData and does any necessary pre-calculation such that the calculator can perform the minimum computation when rate constants are requested. Once setup, the calculator object can be called as a functor with its implemented experimental conditions as keyword arguments to evaluate the rate constants of all reactions in the given CRN at the provided values of the conditions. Examples of this process can be found below.","category":"page"},{"location":"tutorials/kinetic-calculators/#Calculator-Showcase","page":"Kinetic Calculators","title":"Calculator Showcase","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"In all of the examples below, sd and rd refer to instances of SpeciesData and RxData respectively. These are the internal representations of species and reactions within Kinetica, see the page on CRN Representation for further information.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"note: This section is growing!\nKinetica currently has only a handful of kinetic calculators available. We are adding more as we need them, but if you require a specific implementation then please let us know on our Issues page. Alternatively, calculators aren't too hard to implement yourself, and custom calculators can be dropped into kinetic simulations just like the ones presented here. See Calculator Interface for details.","category":"page"},{"location":"tutorials/kinetic-calculators/#Kinetica.jl","page":"Kinetic Calculators","title":"Kinetica.jl","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/#[PrecalculatedArrheniusCalculator](@ref)","page":"Kinetic Calculators","title":"PrecalculatedArrheniusCalculator","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"This calculator is dependent on temperature as an experimental condition, and takes a vector of Arrhenius prefactors and a vector of activation energies, each with an entry for each reaction in a given CRN, and calculates rate constants with the Arrhenius equation. It also accepts an optional maximum rate constant k_max which takes over through partial diffusion control. The calculated rate constant for reaction i is therefore: ","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"k_i = dfrac1dfrac1k_textmax + dfrac1A_ie^-dfracE_iRT","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"where A_i is the ith Arrhenius prefactor, E_i is the ith activation energy, R is the ideal gas constant and T is the temperature, which must be passed in as a parameter.","category":"page"},{"location":"tutorials/kinetic-calculators/#Example:","page":"Kinetic Calculators","title":"Example:","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"# Get Arrhenius prefactors A and activation energies Ea from elsewhere...\n# Length of A and Ea should match rd.nr.\ncalc = PrecalculatedArrheniusCalculator(Ea, A; k_max = 1e12)\nsetup_network!(sd, rd, calc)\nk = calc(; T = 300.0)","category":"page"},{"location":"tutorials/kinetic-calculators/#KineticaKPM.jl","page":"Kinetic Calculators","title":"KineticaKPM.jl","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"The calculators in KineticaKPM all use KineticPredictorModel (KPM), a Python code for predicting activation energies using a simple neural network, as a driver for rate constant calculation using the Arrhenius equation. Arrhenius prefactors are estimated through a variety of methods depending on the calculator used.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"The calculators in this package require an instance of KPMRun, which acts as an interface to the KPM package and handles conversion of the current CRN into reactions which it can predict activation energies for. This is simply constructed by calling the following:","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"kpm = KPMRun(\"/path/to/kpm_model.npz\")","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"where the KPM model .npz file should be obtained separately through training a model with the main Python package.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"All calculators in this package accept an optional maximum rate constant k_max which takes over through partial diffusion control. They are also all capable of returning rate constants with Measurements.jl uncertainties, derived from the standard deviation between activation energy predictions within an ensemble of neural networks. While these can be used manually, they are not currently supported within any of the ODE solution methods in Kinetica.","category":"page"},{"location":"tutorials/kinetic-calculators/#[KPMBasicCalculator](@ref)","page":"Kinetic Calculators","title":"KPMBasicCalculator","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"This calculator is dependent on temperature as an experimental condition. It estimates Arrhenius prefactors as","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"A = dfracRTh","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"for all reactions, where R is the ideal gas constant, T is the temperature, which must be passed as a parameter, and h is the Planck constant. The resulting rate constant for reaction i is therefore:","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"k_i = dfrac1dfrac1k_textmax + dfrac1dfracRThe^-dfracE_iRT","category":"page"},{"location":"tutorials/kinetic-calculators/#Example:-2","page":"Kinetic Calculators","title":"Example:","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"# Set up KPMRun object before this...\ncalc = KPMBasicCalculator(kpm; uncertainty = false, k_max = 1e12)\nsetup_network!(sd, rd, calc)\nk = calc(; T = 300.0)","category":"page"},{"location":"tutorials/kinetic-calculators/#[KPMCollisionCalculator](@ref)","page":"Kinetic Calculators","title":"KPMCollisionCalculator","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"This calculator is dependent on temperature as an experimental condition. It estimates Arrhenius prefactors using collision theory, a hard-sphere approximation of collision frequency. All unimolecular reactions therefore require a collision partner for reactions to occur, which can be passed through the inert_species argument. If this is given, setup_network! will modify all unimolecular reactions to become bimolecular with the provided collision partners. Otherwise, an average collision partner will be calculated from the species in the CRN and rates will be calculated assuming a concentration of 1 mol dm^-3 of this 'species'.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"The calculator computes two properties for each reaction: the reduced mass mu and the collision cross section sigma. For collision partners A and B, these are defined as","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"mu = dfracm_A m_Bm_A + m_B \nsigma = pi left( r_A + r_B right)^2","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"where m_A and m_B are the masses of A and B respectively and r_A and r_B are the hard sphere radii of A and B respectively.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"The calculator optionally allows for specification of a 'steric factor' rho. Collision theory is known to overestimate rate constants, but there is no perfect mathematical relationship that can calculate how much this overestimate is by. The steric factors implemented here attempt to establish an empirical correction to the collision theory rate constant based on a variety of information about each species. See KineticaKPM.calc_steric_factors for further information.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"The resulting rate constant for reaction i is therefore:","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"k_i = dfrac1dfrac1k_textmax + dfrac1sigma_i rho_i N_A sqrtdfrac8 k_b Tpi mu_ie^-dfracE_iRT","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"where N_A is Avogadro's number, k_b is the Boltzmann constant, T is the temperature, which is passed as a parameter, E_i is the activation energy and R is the ideal gas constant.","category":"page"},{"location":"tutorials/kinetic-calculators/#Example:-3","page":"Kinetic Calculators","title":"Example:","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"# If using inert species, these need an initial concentration.\npars = ODESimulationParams(\n    tspan = (0.0, 10.0)\n    u0 = Dict(\n        \"CC\" => 1.0,\n        \"N#N\" => 1.0\n    ),\n    solver = ...\n)\n# Set up KPMRun object before this...\ncalc = KPMCollisionCalculator(\n    kpm,\n    inert_species = [\"N#N\"],\n    steric_factor = :basic,\n    uncertainty = false,\n    k_max = 1e12\n)\nsetup_network!(sd, rd, calc)\nk = calc(; T = 300.0)","category":"page"},{"location":"tutorials/ode-solution/#ODE-Solution","page":"ODE Solution","title":"ODE Solution","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"mkpath(\"../assets/tutorials/ode_solution\")","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Kinetic simulations of generated CRNs are a key part of the Kinetica workflow. Aside from enabling computational insight into long-timescale chemical degradation processes through integration of species concentrations with time, they also allow for directed exploration of chemical reaction space (see Iterative CRN Exploration).","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"As such, the efficiency of these simulations is paramount within Kinetica. Aside from building the infrastructure for these simulations on top of extensible, performant Julia packages such as Catalyst.jl, ModelingToolkit.jl and DifferentialEquations.jl, we implement a number of optimisations that make repeated long-timescale simulations possible.","category":"page"},{"location":"tutorials/ode-solution/#Kinetic-Simulation-Basics","page":"ODE Solution","title":"Kinetic Simulation Basics","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Within Kinetica, what we refer to as a 'kinetic simulation' broadly consists of 3 steps:","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"A calculator setup stage, where the chosen kinetic calculator (see section on Kinetic Calculators for further information) is prepared to calculate rate constants on the given CRN.\nConversion of a Kinetica CRN into a system of ODEs that can be integrated with time by the selected ODE solver.\nIntegration of species concentrations over the selected timespan. Depending on how the simulation is formulated, this may include simulataneous integration of experimental conditions and reaction rate constants with time.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"This tutorial will focus on steps 2-3, as Kinetica presents many methods of creating symbolic systems of ODEs and integrating them with time which can be more or less effective given the simulation problem at hand.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"In order to demonstrate how these methods work, we start by considering a simple CRN:","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"A undersetk_-1stackrelk_1rightleftharpoons B + C \nB undersetk_-2stackrelk_2rightleftharpoons D \nC + D undersetk_-3stackrelk_3rightleftharpoons E","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"where A, B, C, D and E are chemical species, and k_1, k_-1 etc. are forward and reverse rate constants for the 3 reactions connecting them.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Assuming these rate constants are static parameters for the duration of a kinetic simulation, Catalyst.jl can be used to convert this CRN into a symbolic ModelingToolkit.jl ODESystem containing the following ODEs:","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"beginsplit\n    fracmathrmd Aleft( t right)mathrmdt  = - k_1 Aleft( t right) + k_- 1 Bleft( t right) Cleft( t right) \n    fracmathrmd Bleft( t right)mathrmdt  = k_1 Aleft( t right) + k_- 2 Dleft( t right) - k_2 Bleft( t right) - k_- 1 Bleft( t right) Cleft( t right) \n    fracmathrmd Cleft( t right)mathrmdt  = k_1 Aleft( t right) + k_- 3 Eleft( t right) - k_- 1 Bleft( t right) Cleft( t right) - k_3 Cleft( t right) Dleft( t right) \n    fracmathrmd Dleft( t right)mathrmdt  = k_2 Bleft( t right) + k_- 3 Eleft( t right) - k_- 2 Dleft( t right) - k_3 Cleft( t right) Dleft( t right) \n    fracmathrmd Eleft( t right)mathrmdt  = - k_- 3 Eleft( t right) + k_3 Cleft( t right) Dleft( t right)\nendsplit","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"This ODESystem can be passed to DifferentialEquations.jl to be integrated over a given timespan. For many CRNs under static experimental conditions, this process is made simple by these packages. ","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"However, when experimental conditions need to vary - almost a certainty over long real-world timescales - this process becomes more difficult as reaction rate constants must also vary with these experimental conditions. The rate constants in the above system of ODEs therefore become symbolic variables rather than parameters and the variable conditions must also be included, forming a much larger system of differential algebraic equations (DAEs):","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"beginsplit\n    fracmathrmd Aleft( t right)mathrmdt  = - k_1left( T right) Aleft( t right) + k_- 1left( T right) Bleft( t right) Cleft( t right) \n    fracmathrmd Bleft( t right)mathrmdt  = k_1left( T right) Aleft( t right) + k_- 2left( T right) Dleft( t right) - k_2left( T right) Bleft( t right) - k_- 1left( T right) Bleft( t right) Cleft( t right) \n    fracmathrmd Cleft( t right)mathrmdt  = k_1left( T right) Aleft( t right) + k_- 3left( T right) Eleft( t right) - k_- 1left( T right) Bleft( t right) Cleft( t right) - k_3left( T right) Cleft( t right) Dleft( t right) \n    fracmathrmd Dleft( t right)mathrmdt  = k_2left( T right) Bleft( t right) + k_- 3left( T right) Eleft( t right) - k_- 2left( T right) Dleft( t right) - k_3left( T right) Cleft( t right) Dleft( t right) \n    fracmathrmd Eleft( t right)mathrmdt  = - k_- 3left( T right) Eleft( t right) + k_3left( T right) Cleft( t right) Dleft( t right) \n    fracmathrmd Tleft( t right)mathrmdt  = textttget_profile(conditions T) \n    fracmathrmd Pleft( t right)mathrmdt  = textttget_profile(conditions P) \n    k_1left( T right)  = A_1 expleft  -fracE_a 1k_BTleft(tright) right  \n    k_-1left( T right)  = A_-1 expleft  -fracE_a -1k_BTleft(tright) right  \n    k_2left( T right)  = A_2 expleft  -fracE_a 2k_BTleft(tright) right  \n    k_-2left( T right)  = A_-2 expleft  -fracE_a -2k_BTleft(tright) right  \n    k_3left( T right)  = A_3 expleft  -fracE_a 3k_BTleft(tright) right  \n    k_-3left( T right)  = A_-3 expleft  -fracE_a -3k_BTleft(tright) right  \nendsplit","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"This system of DAEs is computationally challenging to solve, so we convert it back to an ODESystem by substituting the expressions for the variable rate constants back into each species' ODE. For example, the ODE for the concentration of species A becomes:","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"fracmathrmd Aleft( t right)mathrmdt = - A_1 expleft  -fracE_a 1k_BTleft(tright) right  Aleft( t right) + A_-1 expleft  -fracE_a -1k_BTleft(tright) right  Bleft( t right) Cleft( t right)","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"With the full ODESystem expanded in this way, ModelingToolkit can be used to create a sparse analytic Jacobian and a CRN can be quickly and efficiently integrated with time under variable experimental conditions. This represents what Kinetica calls (for reasons that will become apparrent soon) the complete-time continuously variable rate constant method of kinetic simulation.","category":"page"},{"location":"tutorials/ode-solution/#Chunkwise-Simulation","page":"ODE Solution","title":"Chunkwise Simulation","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Tackling long-timescale simulations with the approach above presents an interesting challenge. When reactions are occurring very quickly (under high temperatures and/or high pressures, for example) and rate constants are very large, ODE solvers capable of adaptive timestepping usually reduce their timesteps to correctly resolve the changes in species concentrations. Within short-timescale simulations where the length of the simulation is only a few orders of magnitude higher than these rate constants, there are no problems. However once we move to longer-timescale simulations, we run into floating point underflow.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"More specifically, once a timestep is complete, the solver adds the timestep to the global simulation time (GST). If the timestep is so small in comparison to the GST that addition to it does not change the GST, underflow occurs. We therefore recommend enabling chunkwise simulations within Kinetica. ","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"This is a technique that splits the global simulation timescale into local chunks of time, each of length tau_c (set by ODESimulationParams.solve_chunkstep). By running back-to-back short simulations where local simulation time (LST) underflow is guaranteed not to occur and accumulating GST separately, we can avoid any underflow and not have to rely on extended precision operations.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Chunkwise-time kinetic simulations are enabled/disabled within the ODESimulationParams parameter block. For further discussion on implementation and necessity, see the section on Implemetation Details - Chunkwise Time.","category":"page"},{"location":"tutorials/ode-solution/#Discretely-Variable-Kinetics","page":"ODE Solution","title":"Discretely Variable Kinetics","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"While the continuously variable rate constant method of kinetic simulation (both in its complete-time and chunkwise-time forms) works for small CRNs, the computational cost of substituting variable rate constants into the ODESystem and creating a sparse analytical Jacobian of the expanded system scales poorly with CRN size. Imagine the system of ODEs needed to describe a CRN with hundreds of species and thousands of reactions, each with their own expanded rate constant! ","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"The continuous formalism is also limited in the range of rate constants that can be used. Since each rate constant must be mathematically embedded within the ODEs it occurs in, rate constants must be expressible purely as functions of experimental conditions (i.e. a quantity that can go in a ConditionSet), with any other quantities precalculated and compiled into these functions during ODESystem compilation. This limits both the level of theory and the level of computation that can occur, as more complicated rate expressions and rate constant calculations based on external programs cannot be used.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Kinetica includes a discrete approximation to continuously variable rate constants that can circumvent both of these issues. It does this by only compiling a cheap static kinetic ODESystem (i.e. one where each rate constant is a single numeric parameter rather than a variable expression) and precalculating all values of the rate constant at times separated by a rate update timestep tau_r. During kinetic simulation, Kinetica discretely updates every rate constant at every tau_r along the GST using DifferentialEquations' callback library. By setting a small enough tau_r, the continuous formalism result can be recovered.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"The discretely variable rate constant method of kinetic simulation has been shown to produce results that are almost indistinguishable from the continuous formalism, while achieving significantly faster compilation and even speeding up ODE solution (see the original Kinetica paper). It is also compatible with the chunkwise time simulations described above, allowing for fast and flexible long-timescale simulations of very large CRNs. ","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Unlike chunkwise simulations, this method is not enabled within the main ODESimulationParams block - instead, it is activated by setting the ts_update keyword argument when constructing a simulation's ConditionSet. This is because each variable condition profile has to know when rate constant updates are going to happen in advance so it can intelligently create arrays of time points to update rate constants at, only where a profile is actually varying. This avoids unnecessary rate constant updates to maintain simulation efficiency. For more information, see the tutorial on Arbitrary Simulation Conditions.","category":"page"},{"location":"tutorials/ode-solution/#Method-Summary","page":"ODE Solution","title":"Method Summary","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Depending on the input parameters used, there are currently 6 methods of the solve_network function that can be triggered. These are outlined below:","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"<table>\n  <tbody>\n    <tr>\n      <th>Kinetics</th>\n      <th>Timestepping</th>\n      <th>Rate Updates</th>\n      <th>Enabled By</th>\n      <th>Uses</th>\n    </tr>\n    <tr>\n      <td>Static</td>\n      <td>Complete</td>\n      <td>N/A</td>\n      <td>\n        <ul>\n          <li>Static conditions only</li>\n          <li><code>solve_chunks=false</code></li>\n        </ul>\n      </td>\n      <td>Very short-timescale simulations where conditions are constant</td>\n    </tr>\n    <tr>\n      <td>Static</td>\n      <td>Chunkwise</td>\n      <td>N/A</td>\n      <td>\n        <ul>\n          <li>Static conditions only</li>\n          <li><code>solve_chunks=true</code></li>\n        </ul>\n      </td>\n      <td>Long-timescale and/or high-rate simulations where conditions are constant</td>\n    </tr>\n    <tr>\n      <td>Variable</td>\n      <td>Complete</td>\n      <td>Continuous</td>\n      <td>\n        <ul>\n          <li>Mixed static/variable conditions</li>\n          <li><code>solve_chunks=false</code></li>\n          <li><code>ConditionSet</code> <b>without</b> <code>ts_update</code> set</li>\n        </ul>\n      </td>\n      <td>Repeated short-timescale simulations of small CRNs under variable conditions</td>\n    </tr>\n    <tr>\n      <td>Variable</td>\n      <td>Complete</td>\n      <td>Discrete</td>\n      <td>\n        <ul>\n          <li>Mixed static/variable conditions</li>\n          <li><code>solve_chunks=false</code></li>\n          <li><code>ConditionSet</code> <b>with</b> <code>ts_update</code> set</li>\n        </ul>\n      </td>\n      <td>Single short-timescale simulations of large CRNs under variable conditions</td>\n    </tr>\n    <tr>\n      <td>Variable</td>\n      <td>Chunkwise</td>\n      <td>Continuous</td>\n      <td>\n        <ul>\n          <li>Mixed static/variable conditions</li>\n          <li><code>solve_chunks=true</code></li>\n          <li><code>ConditionSet</code> <b>without</b> <code>ts_update</code> set</li>\n        </ul>\n      </td>\n      <td>Repeated long-timescale simulations of small CRNs under variable conditions</td>\n    </tr>\n    <tr>\n      <td>Variable</td>\n      <td>Chunkwise</td>\n      <td>Discrete</td>\n      <td>\n        <ul>\n          <li>Mixed static/variable conditions</li>\n          <li><code>solve_chunks=true</code></li>\n          <li><code>ConditionSet</code> <b>with</b> <code>ts_update</code> set</li>\n        </ul>\n      </td>\n      <td>Single long-timescale simulations of small CRNs under variable conditions</td>\n    </tr>\n  </tbody>\n</table>","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"note: Repeated simulations\nIt may be desirable to perform ensemble simulations on a CRN (e.g. with slightly different rate constants). In some cases, the increased compilation cost of the continuous rate update method may be preferable if the CRN being simulated is solved faster with this method than the discrete rate update method, as the CRN may only have to be compiled once and can then be rerun many times. While the underlying DifferentialEquations integrator object can be returned by calling solve_network with return_integrator=true, ensemble calculations are not currently implemented by Kinetica and this exercise is left up to the user. For most other calculations, the discrete rate update method should always be preferred.","category":"page"},{"location":"tutorials/ode-solution/#Running-Kinetic-Simulations","page":"ODE Solution","title":"Running Kinetic Simulations","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"In Getting Started, we demonstrated an example workflow for generating a CRN and running a kinetic simulation on it by creating a number of parameter blocks and passing them to the explore_network function. While this is useful for CRNs that are being explored, kinetic simulations can also be performed independently of exploration, e.g. when a CRN has already been explored.","category":"page"},{"location":"tutorials/ode-solution/#Parameters","page":"ODE Solution","title":"Parameters","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"As with the original tutorial, running a kinetic simulation will require an ODESimulationParams parameter block (see the Solving API page for full documentation). As noted in Getting Started, the first 3 parameters of this block are essential to any kinetic simulation, while the rest have default values and are optional. Nevertheless, these optional parameters are of vital importance to the performance and efficiency of many kinetic simulations:","category":"page"},{"location":"tutorials/ode-solution/#do_jac-and-do_sparse","page":"ODE Solution","title":"do_jac and do_sparse","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"These parameters tell ModelingToolkit whether to generate a symbolic analytical Jacobian and automatically detect its sparsity pattern. Enabling these options (default) can significantly speed up kinetic simulations by eliminating the solver's use of numerical derivatives and allowing for sparse matrix operations. See the ModelingToolkit documentation for more information.","category":"page"},{"location":"tutorials/ode-solution/#abstol-and-reltol","page":"ODE Solution","title":"abstol and reltol","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"These control the absolute/relative tolerances of the ODE solver. These can be reduced to increase the accuracy of the resulting solution at the cost of solution time, as more timesteps will be taken.","category":"page"},{"location":"tutorials/ode-solution/#adaptive_tols-and-update_tols","page":"ODE Solution","title":"adaptive_tols and update_tols","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"These control Kinetica's adaptive solver tolerance optimisation. See the section on Implementation Details - Adaptive Solver Tolerance for more information.","category":"page"},{"location":"tutorials/ode-solution/#solve_chunks-and-solve_chunkstep","page":"ODE Solution","title":"solve_chunks and solve_chunkstep","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"These control Kinetica's chunkwise ODE solution optimisation. See the section above on Chunkwise Simulation for more information.","category":"page"},{"location":"tutorials/ode-solution/#maxiters","page":"ODE Solution","title":"maxiters","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"This parameter allows for more ODE solver iterations to be used when required. This sometimes needs to be increased when performing very long timescale simulations with challenging (high rate) experimental conditions that require many timesteps.","category":"page"},{"location":"tutorials/ode-solution/#ban_negatives","page":"ODE Solution","title":"ban_negatives","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Enabling this forces the ODE solver to reject steps when any species concentrations fall below zero. In most cases, reducing solver tolerances to increase solution accuracy should be preferred.","category":"page"},{"location":"tutorials/ode-solution/#progress","page":"ODE Solution","title":"progress","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Enabling this allows for showing a progress bar during ODE solution. See the tutorial on Logging for more details.","category":"page"},{"location":"tutorials/ode-solution/#save_interval","page":"ODE Solution","title":"save_interval","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"This allows for controlling how often the ODE solver saves species concentrations. While this defaults to saving species concentrations at every timestep (save_interval=nothing), this can lead to high memory consumption and disk space usage during/after long-timescale simulations where many timesteps are taken.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"warning: Set a save interval!\nWhile saving species concentrations at every timestep may be possible within short simulations of small CRNs, save_interval should generally be set to the smallest temporal feature that is required to be analysed in order to not incur large memory costs.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"warning: Saving with chunkwise time\nWhen solve_chunks=true, this parameter behaves slightly differently. If left empty, species concentrations will be saved at the start and end of every chunk. If given a numeric value, this will be interpreted as a value within the local timescale 0.0:save_interval:solve_chunkstep, so providing a value larger than solve_chunkstep will cause nothing to be saved. See the section on Implemetation Details - Chunkwise Time for further details.","category":"page"},{"location":"tutorials/ode-solution/#low_k_cutoff-and-low_k_maxconc","page":"ODE Solution","title":"low_k_cutoff and low_k_maxconc","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"These parameters allows Kinetica to automatically remove reactions with low rate constants from a CRN, optimising CRN compilation and solution. They default to low_k_cutoff=:auto and low_k_maxconc=2.0, which selects conservative values that ensure that only reactions which could never contribute to the current kinetic simulation are removed. ","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"If a numeric value is provided to low_k_cutoff, this is used as the minimum rate constant below which reactions are removed from the CRN. If low_k_cutoff=:none, this behaviour is disabled and no reactions are removed from the CRN. See the section on Implementation Details - Removing Low-Rate Reactions","category":"page"},{"location":"tutorials/ode-solution/#allow_short_u0","page":"ODE Solution","title":"allow_short_u0","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"This parameter allows a vector-valued u0 (as opposed to a Dict-based `u0 shown in previous tutorials) to be shorter than the number of reactions in the current CRN. This can be useful when CRNs are being extended with species that are guaranteed to not exist at the start of a kinetic simulation.","category":"page"},{"location":"tutorials/ode-solution/#Example","page":"ODE Solution","title":"Example","text":"","category":"section"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"We will start by loading in the results from Getting Started and extracting the underlying CRN. For more information on loading saved CRNs, see Saving & Loading.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"using Kinetica\n\nres = load_output(\"../my_CRN_out/direct_network_final.bson\")\nsd, rd = res.sd, res.rd\nnothing # hide","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"note: CRN Representation\nsd and rd above are instances of SpeciesData and RxData respectively. These are the major components of CRNs within Kinetica, and are required for running kinetic simulations - you might not normally see them if you are running explore_network, but they're part of the saved output so that CRNs can be reconstructed once an exploration is complete. For further information, see the section on CRN Representation.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Let's construct another set of parameters for running a kinetic simulation on this CRN. This time, we'll use a different variable temperature profile, and we'll enable the discrete rate update method to speed up ODESystem compilation.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"conditions = ConditionSet(Dict(\n    :T => DoubleRampGradientProfile(;\n        X_start = 500.0,\n        t_start_plateau = 1.0,\n        rate1 = 20.0,\n        X_mid = 1200.0,\n        t_mid_plateau = 3.0,\n        rate2 = -25.0,\n        X_end = 500.0,\n        t_end_plateau = 5.0,\n        t_blend = 0.5\n    )),\n    ts_update = tconvert(1, \"ms\", \"s\")\n)\n\nusing Sundials\n\npars = ODESimulationParams(\n    tspan = (0.0, get_t_final(conditions)),\n    u0 = Dict(\"C\" => 1.0),\n    solver = CVODE_BDF(; linear_solver=:KLU),\n    solve_chunkstep = tconvert(10, \"ms\", \"s\"),\n    save_interval = tconvert(5, \"ms\", \"s\")\n)","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Here we've specified that the rate update timestep tau_r should be 1 ms - that is, all rate constants should be precalculated at 1 ms intervals while the temperature is changing, and should then be discretely updated at these time points during kinetic simulation. We've also specified that the solution chunk length tau_c should be 10 ms, and that the final solution should be saved every 5 ms, as this will be a longer simulation and saving species concentrations at every timestep could become quite expensive.","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"We'll set up the kinetic calculator in the same way as before:","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"using BSON\ncalc_pars = BSON.load(\"../../../examples/getting_started/arrhenius_params.bson\")\ncalc = PrecalculatedArrheniusCalculator(calc_pars[:Ea], calc_pars[:A]; k_max=1e12)","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Now all that's left is to run the simulation. This can be achieved with solve_network:","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"solvemethod = VariableODESolve(pars, conditions, calc)\nres = solve_network(solvemethod, sd, rd)\nnothing # hide","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"note: Under the hood\nWhen you called explore_network beforehand to explore and solve a CRN, the solution was actually being handled by solve_network in exactly the same way as above!","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"As before, we can see what this kinetic simulation was doing by plotting from the ODESolveOutput object res:","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"using Plots\nplot(res)\nsavefig(\"../assets/tutorials/ode_solution/kinetics_plot.svg\"); nothing # hide","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"(Image: )","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"Again, we can also inspect the simulation's temperature profile:","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"conditionsplot(res, :T)\nsavefig(\"../assets/tutorials/ode_solution/temperature_plot.svg\"); nothing # hide","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"(Image: )","category":"page"},{"location":"tutorials/ode-solution/","page":"ODE Solution","title":"ODE Solution","text":"This same methodology can be applied to any CRN under any compatible conditions.","category":"page"},{"location":"tutorials/results-analysis/#Results-Analysis","page":"Results Analysis","title":"Results Analysis","text":"","category":"section"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"mkpath(\"../assets/tutorials/results_analysis\")\nusing Random\nRandom.seed!(12345)","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"Upon completion of a kinetic simulation run by solve_network (or through the end of a CRN exploration using explore_network, which also calls this function), Kinetica returns an ODESolveOutput object. This binds together the CRN that this simulation was run on (after modifications such as those described in Filtering CRNs and Removing Low-Rate Reactions), the parameters the simulation was run with, and the simulation's results. This data can be used for analysing the results of a kinetic simulation.","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"We will demonstrate this analysis using the results of the CRN we generated and simulated in Getting Started:","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"using Kinetica, Plots\nres = load_output(\"../my_CRN_out/direct_network_final.bson\")\nnothing # hide","category":"page"},{"location":"tutorials/results-analysis/#Analysing-the-CRN","page":"Results Analysis","title":"Analysing the CRN","text":"","category":"section"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"The output CRN is stored across two data structures: a SpeciesData for holding information about the species within the CRN, and a RxData for holding information about the reactions between those species. These can be accessed through ODESolveOutput.sd and ODESolveOutput.rd respectively. For more information on these objects, see CRN Representation.","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"sd, rd = res.sd, res.rd\nnothing # hide","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"By default, Kinetica stores information about these species and reactions in a compact form to maintain efficiency when working with large CRNs. For example, reactions are stored as Vectors of integer species IDs. To inspect individual reactions, we can use the print_rxn function:","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"# Print the first reaction in the CRN.\nprint_rxn(sd, rd, 1)\nnothing # hide","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"note: Using format_rxn\nprint_rxn is just a wrapper to print the string returned by format_rxn, which uses the reactants/products and stoichiometries in rd and the species SMILES in sd to generate a human-readable string describing a reaction. If you need to print more information alongside a reaction, consider something like println(\"$(format_rxn(sd, rd, rid)): $(extra_data[rid])\").","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"The total number of reactions in a CRN is stored in RxData.nr, so printing all of the reactions in a CRN is as simple as this loop:","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"for i in 1:rd.nr\n    print_rxn(sd, rd, i)\nend\nnothing # hide","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"Other fields of RxData can also be useful for analysis, such as RxData.mapped_rxns. This field contains the atom-mapped reaction SMILES of all reactions in a CRN, and can be used for constructing multi-species reactant and product geometries with consistent atom indeces (vital for any reaction path techniques):","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"println(\"Atom-mapped reaction SMILES: $(rd.mapped_rxns[1])\\n\")\n\n# Split reaction SMILES into individual SMILES for reactants/products.\nam_reacs, am_prods = String.(split(rd.mapped_rxns[1], \">>\"))\n\n# Generate non-overlapping systems of molecules for reactants and products.\nreac_species = [sd.toStr[sid] for sid in rd.id_reacs[1]]\nreacsys = system_from_smiles(reac_species; dmin=3.0)\nprod_species = [sd.toStr[sid] for sid in rd.id_prods[1]]\nprodsys = system_from_smiles(prod_species; dmin=3.0)\n\n# Remap atom indeces using atom-mapped SMILES and RDKit substructure matching.\nmapped_reacs = atom_map_frame(am_reacs, reacsys)\nmapped_prods = atom_map_frame(am_prods, prodsys)\n\n# Add extra info to frames, convert to ExtXYZ and print.\nmapped_reacs[\"info\"][\"type\"] = \"reactant\"\nmapped_reacs[\"info\"][\"SMILES\"] = join(sort(reac_species), \".\")\nmapped_prods[\"info\"][\"type\"] = \"product\"\nmapped_prods[\"info\"][\"SMILES\"] = join(sort(prod_species), \".\")\nprintln(\"Reaction XYZ:\")\nprint(frame_to_xyz(mapped_reacs))\nprint(frame_to_xyz(mapped_prods))","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"As a result of the atom mapping, the hydrogen atoms which dissociate from the reactant ethane are now consistently indexed between reactant and product geometries.","category":"page"},{"location":"tutorials/results-analysis/#Species-Reaction-Graphs","page":"Results Analysis","title":"Species-Reaction Graphs","text":"","category":"section"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"Kinetica hooks in to the same graph plotting code as Catalyst.jl, which uses Graphviz to generate figures that show the relationship between species and reactions in a CRN. Graph(::SpeciesData, ::RxData) has been extended to allow for easy graph plotting directly from a Kinetica CRN:","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"g = Graph(sd, rd)\nsavegraph(g, \"../assets/tutorials/results_analysis/default_graph.svg\", \"svg\"); nothing # hide","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"(Image: )","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"Graphs generated this way are compatible with Catalyst's graph methods and can be saved to file using Catalyst.savegraph. ","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"note: Catalyst.jl Reexports\nWhile Kinetica doesn't usually reexport any structs or methods from other packages, we make an exception for Catalyst.Graph and Catalyst.savegraph as we implement methods that can coexist and be interchanged with those in Catalyst. This allows Graph(::SpeciesData, ::RxData) to be called as above, but also allows savegraph(::Graph, fname, fmt) to be called without ever calling using Catalyst or needing it explicitly in your Julia project.","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"In addition, Kinetica allows for passing Graphviz attributes directly through to the plotter for extra customisability. These take the form of the graph_attrs, species_attrs, rxn_attrs and edge_attrs keyword arguments to Graph(::SpeciesData, ::RxData), which can be supplied with Dict{Symbol, String}s to modify parameters of the overall graph, the species nodes and the reaction nodes, and the edges respectively:","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"g = Graph(sd, rd;\n    graph_attrs=Dict(\n        :layout => \"sfdp\",\n        :overlap => \"prism\",\n        :overlap_scaling => \"-8\"\n    ), species_attrs=Dict(\n        :shape => \"hexagon\",\n        :color => \"aquamarine1\"\n    ), rxn_attrs=Dict(\n        :shape => \"box\",\n        :color => \"coral\"\n    ), edge_attrs=Dict(\n        :color => \"grey59\"\n    ))\nsavegraph(g, \"../assets/tutorials/results_analysis/modified_graph.svg\", \"svg\"); nothing # hide","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"(Image: )","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"note: On Graphviz Installation\nGraphviz is one of Kinetica's Python dependencies, and as such is always installed at the same time as Kinetica. This is not the case for Catalyst.jl, which either requires a user-installed version of Graphviz, or it uses the Graphviz_jll package. As discussed in the section on the Graphviz dependency, we avoid the JLL due to it missing some key features which Kinetica's CRNs typically need.Kinetica always adds its Python dependencies to the end of the current PATH, so if you have your own installation that you'd like to use, just make sure it's in your PATH before you start Julia!","category":"page"},{"location":"tutorials/results-analysis/#Species-Analysis","page":"Results Analysis","title":"Species Analysis","text":"","category":"section"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"Kinetica makes use of many functions within both RDKit and Open Babel to assist with basic property prediction and conversion between geometry and SMILES. A comprehensive list of functions implemented are available in the Open Babel and RDKit API pages.","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"Kinetica supports cached calculation of properties such as species molecular weights and hard-sphere radii through Open Babel through the get_species_stats! function. This places these properties in the SpeciesData.cache, which is useful for storing per-species values during a calculation.","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"Kinetica also stores species geometries within SpeciesData.xyz. These are stored as ExtXYZ.jl frames and can be manipulated as such.","category":"page"},{"location":"tutorials/results-analysis/#Analysing-the-Kinetic-Simulation","page":"Results Analysis","title":"Analysing the Kinetic Simulation","text":"","category":"section"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"Most of the information regarding the results of a kinetic simulation are stored in ODESolveOutput.sol, which is a DifferentialEquations ODESolution (in most cases, some extensions may apply depending on the simulation method but this can always be interacted as if it is an ODESolution). As such, the DiffEq documentation applies for directly analysing simulation results.","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"However, when plotting simulation results, it can often be useful to have information about the experimental conditions that the simulation took place under, as well as some of the other parameters used in the simulation which are not included within the ODESolution. This includes the names of each of the species, which are only referred to be an integer ID within Kinetica's solution methods. Kinetica therefore includes Plots.jl plot recipes which act on the ODESolveOutput object, as this has access to all of these values alongside the ODESolution. The plots created by these recipes can be modified in the same way as any other Plots.jl figure.","category":"page"},{"location":"tutorials/results-analysis/#Concentration-Time-Plots","page":"Results Analysis","title":"Concentration-Time Plots","text":"","category":"section"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"This is the 'default' plot type for ODESolveOutput, with the call signature:","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"plot(::ODESolveOutput; tunit=\"s\", label_above=0.1, ignore_species=nothing, ignore_below=nothing)","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"where","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"tunit is the unit of time to display on the x-axis;\nlabel_above is a concentration above which species should contribute to the plot's legend and be plotted in a colour (species is grey otherwise);\nignore_species can be a Vector of SMILES strings representing species which should not be plotted (nothing if this is not desired);\nignore_below can be a concentration threshold where species with a maximum concentration below are not plotted (nothing if this is not desired).","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"For example, plotting the same results as in Getting Started, but excluding the radical species from the plot is simple:","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"is_radical(smi) = ('[' in smi) && !(smi == \"[H][H]\")\nradical_species = [spec for spec in [sd.toStr[i] for i in 1:sd.n] if is_radical(spec)]\n\nplot(res; label_above=0.01, ignore_species=radical_species, linewidth=5)\nsavefig(\"../assets/tutorials/results_analysis/kinetics_plot.svg\"); nothing # hide","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"(Image: )","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"note: Using Plots.jl Arguments\nNotice how we've used the linewidth keyword argument here, but this isn't defined explicitly in this plot recipe. This is because Plots.jl allows for modifying figures, both within the original plot call and in subsequent plot! calls - we could've similarly done plot!(linewidth=5) after our original plot call to achieve the same goal.","category":"page"},{"location":"tutorials/results-analysis/#Conditions-Plots","page":"Results Analysis","title":"Conditions Plots","text":"","category":"section"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"Kinetica defines a separate plot recipe for variable condition profiles, conditionsplot:","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"conditionsplot(::Union{::ODESolveOutput, ConditionSet}, ::Symbol; tunit=\"s\")","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"This recipe can take either an ODESolveOutput or a ConditionSet, but it has a second mandatory argument - a Symbol representing the condition profile to plot. For example, if a variable temperature profile is required (and it exists in the ConditionSet being plotted), then this is usually available under :T. Again, tunit is the unit of time to display on the x-axis.","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"# Again, this is compatible with Plots.jl keyword arguments.\nconditionsplot(res, :T; linecolor=:red)\nsavefig(\"../assets/tutorials/results_analysis/temperature_plot.svg\"); nothing # hide","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"(Image: )","category":"page"},{"location":"tutorials/results-analysis/#Final-Concentration-Plots","page":"Results Analysis","title":"Final Concentration Plots","text":"","category":"section"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"It can often be useful to examine the final species concentrations at the end of a kinetic simulation, as these often correspond to experimental observables. Kinetica implements a specialised bar chart recipe for this, finalconcplot:","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"finalconcplot(::ODESolveOutput; \n              quantity=:conc, n_top=10, highlight_radicals=false, \n              ignore_species=nothing, xscale=:identity)","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"where","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"quantity is a Symbol, either :conc or :percent. The former plots species concentrations, while the latter plots percentage concentrations with respect to the overall reaction mixture;\nn_top controls the number of species to include in the plot. These are sorted in decreasing order, with species outside n_top going into their own 'Others' bar at the end. For example, with n_top=10, the 10 species with the highest final concentrations will be plotted, followed by a bar for the combined final concentration of all other species;\nhighlight_radicals colours radical species in red when true, as these are often not desired at the end of simulations;\nignore_species accepts a Vector of SMILES strings for species to exclude from the plot. This can be useful when inert species are present with concentrations that are unimportant to the final state of the CRN (nothing if this is not desired);\nxscale mimics Plots.jl's xscale option for setting the scaling of the x-axis. In this case, only :identity (default) and :log10 are supported, as additional calculations are required to obtain the correct x-axis limits for correct bar chart rendering.","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"finalconcplot(res; quantity=:percent, n_top=5, highlight_radicals=true)\nsavefig(\"../assets/tutorials/results_analysis/concs_plot.svg\"); nothing # hide","category":"page"},{"location":"tutorials/results-analysis/","page":"Results Analysis","title":"Results Analysis","text":"(Image: )","category":"page"},{"location":"api/kinetica/conditions/#Kinetica.jl-API","page":"Conditions","title":"Kinetica.jl API","text":"","category":"section"},{"location":"api/kinetica/conditions/#Conditions","page":"Conditions","title":"Conditions","text":"","category":"section"},{"location":"api/kinetica/conditions/#ConditionSet","page":"Conditions","title":"ConditionSet","text":"","category":"section"},{"location":"api/kinetica/conditions/","page":"Conditions","title":"Conditions","text":"ConditionSet\nget_profile(::ConditionSet, ::Symbol)\nKinetica.get_initial_conditions(::ConditionSet)\nisstatic\nisvariable\nget_tstops(::ConditionSet)\nget_t_final(::ConditionSet)\nsolve_variable_conditions!","category":"page"},{"location":"api/kinetica/conditions/#Kinetica.ConditionSet","page":"Conditions","title":"Kinetica.ConditionSet","text":"conditions = ConditionSet(Dict(\n    :C1 => ConditionType1(...),\n    :C2 => ConditionType2(...))\n    [, ts_update=nothing]\n))\n\nContainer for all conditions in a kinetic simulation.\n\nConditions can be static or variable, and variable conditions can be gradient-based or directly usable.\n\nContains fields for:\n\nSymbolic representation of conditions (symbols)\nCondition profile for each symbol (profiles)\nWhether discrete rate constant updates are enabled for the conditions in this condition set (discrete_updates)\nDiscrete rate constant update timestep, is nothing if discrete_updates = false (ts_update)\n\nConstructor separates condition profiles from their symbols  and parses numeric profiles into StaticConditionProfiles.  Registers AbstractVariableProfiles with Symbolics to allow for proper computation down the chain.\n\nIf ts_update is provided as a keyword argument, creates  tstops arrays within each variable profile for use in  discrete rate update simulations.\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/conditions/#Kinetica.get_profile-Tuple{ConditionSet, Symbol}","page":"Conditions","title":"Kinetica.get_profile","text":"get_profile(cs::ConditionSet, sym::Symbol)\n\nGets the condition profile linked to sym from cs.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.get_initial_conditions-Tuple{ConditionSet}","page":"Conditions","title":"Kinetica.get_initial_conditions","text":"get_initial_conditions(conditions::ConditionSet)\n\nExtract initial values of conditions from conditions.\n\nReturns an array of Pairs linking Symbols to initial values. For AbstractStaticProfiles, initial values are their static values. For AbstractVariableProfiles, initial values are their X_start values.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.isstatic","page":"Conditions","title":"Kinetica.isstatic","text":"isstatic(cs::ConditionSet[, sym::Symbol])\n\nDetermines if condition profiles in a ConditionSet are static.\n\nWhen a Symbol sym is provided, only checks if the profile linked to this Symbol is static. If no Symbol is provided, checks is all profiles are static.\n\nisstatic(profile<:AbstractConditionProfile)\n\nDetermines if a given condition profile is static.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/conditions/#Kinetica.isvariable","page":"Conditions","title":"Kinetica.isvariable","text":"isvariable(cs::ConditionSet[, sym::Symbol])\n\nDetermines if condition profiles in a ConditionSet are variable.\n\nWhen a Symbol sym is provided, only checks if the profile linked to this Symbol is variable. If no Symbol is provided, checks is all profiles are variable.\n\nisvariable(profile<:AbstractConditionProfile)\n\nDetermines if a given condition profile is variable.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/conditions/#Kinetica.get_tstops-Tuple{ConditionSet}","page":"Conditions","title":"Kinetica.get_tstops","text":"get_tstops(cs::ConditionSet)\n\nRetrieves a sorted array of unique time stops from all condition profiles in cs.\n\nShould be used for passing a unified set of time stops to a discrete rate constant update solver. Will throw an error if all condition profiles are static, as they have no tstops.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.get_t_final-Tuple{ConditionSet}","page":"Conditions","title":"Kinetica.get_t_final","text":"get_t_final(cs::ConditionSet)\n\nRetrieves the last necessary time point needed to encompass all variable condition profiles in cs.\n\nWill throw an error if all condition profiles are static, they have no set endpoints.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.solve_variable_conditions!","page":"Conditions","title":"Kinetica.solve_variable_conditions!","text":"solve_variable_conditions!(cs::ConditionSet, pars::ODESimulationParams[, reset=false, solver=OwrenZen5(), solve_kwargs])\n\nSolves all variable condition profiles over the timespan in pars.tspan.\n\nPlaces all condition profile solutions in their sol field. In the case of AbstractDirectProfiles, this creates a DiffEqArray to mimic the regular DiffEq solver interface.\n\nIf condition profiles already exist, they will not be overwritten unless reset=true. \n\nThe solver and solve_kwargs arguments are used when solving gradient profiles. The OwrenZen5 solver has shown to be a stable, accurate solver capable of handling sudden gradient changes, and is a sensible default. solve_kwargs is a Dict of keyword arguments that get passed to the  solve call, with default state:\n\nsolve_kwargs=Dict{Symbol, Any}(\n    :abstol => 1e-6,\n    :reltol => 1e-4\n)\n\nThese have been shown to be sensible defaults for most gradient profiles.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/conditions/#Static-Condition-Profiles","page":"Conditions","title":"Static Condition Profiles","text":"","category":"section"},{"location":"api/kinetica/conditions/","page":"Conditions","title":"Conditions","text":"Kinetica.StaticConditionProfile","category":"page"},{"location":"api/kinetica/conditions/#Kinetica.StaticConditionProfile","page":"Conditions","title":"Kinetica.StaticConditionProfile","text":"Definition for static condition profile.\n\nConditions defined this way are static for the duration of a simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/conditions/#Variable-Condition-Profiles","page":"Conditions","title":"Variable Condition Profiles","text":"","category":"section"},{"location":"api/kinetica/conditions/","page":"Conditions","title":"Conditions","text":"Kinetica.create_discrete_tstops!","category":"page"},{"location":"api/kinetica/conditions/#Kinetica.create_discrete_tstops!","page":"Conditions","title":"Kinetica.create_discrete_tstops!","text":"create_discrete_tstops!(profile<:AbstractVariableProfile, ts_update<:AbstractFloat)\n\nCreates a custom array of time stops within profile.tstops.\n\nThis array contains a time stop every ts_update, but attempts to intellegently avoid unnecessary time stops in areas where they are not needed, i.e. when the given profile is stationary.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/conditions/#Directly-Variable-Condition-Profiles","page":"Conditions","title":"Directly Variable Condition Profiles","text":"","category":"section"},{"location":"api/kinetica/conditions/","page":"Conditions","title":"Conditions","text":"Kinetica.solve_variable_condition!(::Kinetica.AbstractDirectProfile, ::ODESimulationParams)\nNullDirectProfile\nNullDirectProfile()\nLinearDirectProfile\nLinearDirectProfile()","category":"page"},{"location":"api/kinetica/conditions/#Kinetica.solve_variable_condition!-Tuple{Kinetica.AbstractDirectProfile, ODESimulationParams}","page":"Conditions","title":"Kinetica.solve_variable_condition!","text":"solve_variable_condition!(profile<:AbstractDirectProfile, pars::ODESimulationParams[, reset=false])\n\nGenerates a solution for the specified directly-variable condition profile.\n\nFor profiles with direct functions, this requires calculating values for the specified pars.tspan and wrapping them within a DiffEqArray for compatibility with other interfaces (plotting, interpolation, etc.).\n\nArguments sym, solver and solve_kwargs are provided for compatibility with unified callers, do nothing and should be ignored.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.NullDirectProfile","page":"Conditions","title":"Kinetica.NullDirectProfile","text":"NullDirectProfile(; X_start, t_end)\n\nContainer for null direct profile data and condition function.\n\nThis condition profile should only be used for debugging, as it has a condition function which always returns the initial condition. If only this constant condition is  required, StaticODESolve should always be used with a StaticConditionProfile instead of a VariableODESolve with this condition profile.\n\nContains fields for:\n\nCondition function (f)\nInitial value of condition (X_start)\nTime to stop calculation (t_end)\nTimes for the ODE solver to ensure calculation at (tstops)\nProfile solution, constructed by call to solve_variable_condition! (sol)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/conditions/#Kinetica.NullDirectProfile-Tuple{}","page":"Conditions","title":"Kinetica.NullDirectProfile","text":"NullDirectProfile(; X_start, t_end)\n\nContainer for null direct profile data and condition function.\n\nThis condition profile should only be used for debugging, as it has a condition function which always returns the initial condition. If only this constant condition is  required, StaticODESolve should always be used with a StaticConditionProfile instead of a VariableODESolve with this condition profile.\n\nContains fields for:\n\nCondition function (f)\nInitial value of condition (X_start)\nTime to stop calculation (t_end)\nTimes for the ODE solver to ensure calculation at (tstops)\nProfile solution, constructed by call to solve_variable_condition! (sol)\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.LinearDirectProfile","page":"Conditions","title":"Kinetica.LinearDirectProfile","text":"LinearDirectProfile(; rate, X_start, X_end)\n\nContainer for linear condition ramp profile data and condition function.\n\nThis condition profile represents a linear condition increase/decrease from X_start to X_end. Determines the simulation end time from the provided conditions and rate, then constructs the condition function (which is a linear y = mx + c function).\n\nContains fields for:\n\nCondition function (f)\nRate of change of condition (rate)\nInitial value of condition (X_start)\nFinal value of condition (X_end)\nTime to stop calculation (t_end)\nTimes for the ODE solver to ensure calculation at (tstops)\nProfile solution, constructed by call to solve_variable_condition! (sol)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/conditions/#Kinetica.LinearDirectProfile-Tuple{}","page":"Conditions","title":"Kinetica.LinearDirectProfile","text":"LinearDirectProfile(; rate, X_start, X_end)\n\nContainer for linear condition ramp profile data and condition function.\n\nThis condition profile represents a linear condition increase/decrease from X_start to X_end. Determines the simulation end time from the provided conditions and rate, then constructs the condition function (which is a linear y = mx + c function).\n\nContains fields for:\n\nCondition function (f)\nRate of change of condition (rate)\nInitial value of condition (X_start)\nFinal value of condition (X_end)\nTime to stop calculation (t_end)\nTimes for the ODE solver to ensure calculation at (tstops)\nProfile solution, constructed by call to solve_variable_condition! (sol)\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Gradient-Variable-Condition-Profiles","page":"Conditions","title":"Gradient-Variable Condition Profiles","text":"","category":"section"},{"location":"api/kinetica/conditions/","page":"Conditions","title":"Conditions","text":"Kinetica.solve_variable_condition!(::Kinetica.AbstractGradientProfile, ::ODESimulationParams)\nLinearGradientProfile\nLinearGradientProfile()\nDoubleRampGradientProfile\nDoubleRampGradientProfile()","category":"page"},{"location":"api/kinetica/conditions/#Kinetica.solve_variable_condition!-Tuple{Kinetica.AbstractGradientProfile, ODESimulationParams}","page":"Conditions","title":"Kinetica.solve_variable_condition!","text":"solve_variable_condition!(profile<:AbstractGradientProfile, pars::ODESimulationParams[, sym=nothing, reset=false, solver, solve_kwargs])\n\nGenerates a solution for the specified gradient-variable condition profile.\n\nFor gradient-based profiles, this requires constructing an ODEProblem around their MTK-derived symbolic gradient expressions and solving over the timespan in pars.\n\nThe ODE solver and the arguments passed to the solve() call can be controlled with the solver and solve_kwargs arguments respectively. If sym is passed a Symbol, this will bind the solution result to that symbol in the underlying ODESolution.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.LinearGradientProfile","page":"Conditions","title":"Kinetica.LinearGradientProfile","text":"LinearGradientProfile(; rate, X_start, X_end)\n\nContainer for linear condition ramp profile data and condition gradient function.\n\nThis condition profile represents a linear condition increase/decrease from X_start to X_end. Determines  the simulation end time from the provided conditions and gradient, then constructs the condition gradient  function (which returns rate for every timestep).\n\nContains fields for:\n\nCondition gradient function (grad)\nRate of change of condition (rate)\nInitial value of condition (X_start)\nFinal value of condition (X_end)\nTime to stop calculation (t_end)\nTimes for the ODE solver to ensure calculation at (tstops)\nProfile solution, constructed by call to solve_variable_condition! (sol)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/conditions/#Kinetica.LinearGradientProfile-Tuple{}","page":"Conditions","title":"Kinetica.LinearGradientProfile","text":"LinearGradientProfile(; rate, X_start, X_end)\n\nContainer for linear condition ramp profile data and condition gradient function.\n\nThis condition profile represents a linear condition increase/decrease from X_start to X_end. Determines  the simulation end time from the provided conditions and gradient, then constructs the condition gradient  function (which returns rate for every timestep).\n\nContains fields for:\n\nCondition gradient function (grad)\nRate of change of condition (rate)\nInitial value of condition (X_start)\nFinal value of condition (X_end)\nTime to stop calculation (t_end)\nTimes for the ODE solver to ensure calculation at (tstops)\nProfile solution, constructed by call to solve_variable_condition! (sol)\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.DoubleRampGradientProfile","page":"Conditions","title":"Kinetica.DoubleRampGradientProfile","text":"DoubleRampGradientProfile(; X_start, t_start_plateau, rate1, X_mid, t_mid_plateau, rate2, X_end, t_end_plateau[, t_blend])\n\nContainer for double condition ramp profile data and condition gradient function.\n\nThis condition profile represents two condition ramps with adjustable condition plateaus before, after and in between the ramps, i.e.\n\n              ------   X_mid\n      rate1  /      \\\n            /        \\  rate2\nX_start ----          \\\n                       ----- X_end\n\nThe profile starts at X_start and maintains that value for t_start_plateau. The condition then ramps with gradient rate1 to condition value X_mid. This value is maintained for t_mid_plateau. The condition then ramps with gradient rate2 to condition value X_end. This value is maintained for t_end_plateau until the calculated time t_end.\n\nTo smooth out gradient discontinuities, a blending time t_blend can be passed to linearly interploate between plateaus and ramps, forming a smooth function of time. Larger values of t_blend yield smoother functions but decrease accuracy of the ramps, so should be used carefully.\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/conditions/#Kinetica.DoubleRampGradientProfile-Tuple{}","page":"Conditions","title":"Kinetica.DoubleRampGradientProfile","text":"DoubleRampGradientProfile(; X_start, t_start_plateau, rate1, X_mid, t_mid_plateau, rate2, X_end, t_end_plateau[, t_blend])\n\nContainer for double condition ramp profile data and condition gradient function.\n\nThis condition profile represents two condition ramps with adjustable condition plateaus before, after and in between the ramps, i.e.\n\n              ------   X_mid\n      rate1  /      \\\n            /        \\  rate2\nX_start ----          \\\n                       ----- X_end\n\nThe profile starts at X_start and maintains that value for t_start_plateau. The condition then ramps with gradient rate1 to condition value X_mid. This value is maintained for t_mid_plateau. The condition then ramps with gradient rate2 to condition value X_end. This value is maintained for t_end_plateau until the calculated time t_end.\n\nTo smooth out gradient discontinuities, a blending time t_blend can be passed to linearly interploate between plateaus and ramps, forming a smooth function of time. Larger values of t_blend yield smoother functions but decrease accuracy of the ramps, so should be used carefully.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/arbitrary-conditions/#Arbitrary-Simulation-Conditions","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"using Kinetica, Plots\nmkpath(\"../assets/tutorials/arbitrary_conditions\")\ncspars = ODESimulationParams(\n    tspan = (0.0, 10.0),\n    u0 = [0.0],\n    solver = nothing\n)","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"Alongside the modular kinetic calculator interface, the ability to pass arbitrary combinations of simulation conditions through to be used in CRN integration is one of the key elements of extensibility and customisation within Kinetica.","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"By only requiring that conditions use consistent symbolic names at their definition and within a kinetic calculator, any variable condition profile, defined either directly or by its gradient with respect to time, can be symbolically bound to any quantity of interest.","category":"page"},{"location":"tutorials/arbitrary-conditions/#[ConditionSet](@ref)","page":"Arbitrary Simulation Conditions","title":"ConditionSet","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"At the core of this system is the ConditionSet, which acts as an aggregator for individula condition profiles and their symbols. At their definition, ConditionSets take a dictionary of Symbol => Profile() mappings. Each Symbol can realistically be anything that Julia allows, but by convention (and for compatibility with most calculator implementations) we stick to the usual abbreviations for common conditions - :T for temperature, :P for pressure, :V for volume, etc. Each condition profile can be one of three options:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"A Number representing a static value for the given condition to take for the duration of the simulation. Internally this is converted into a Kinetica.StaticConditionProfile, but this is just a container for the number within.\nA directly variable condition profile, e.g. LinearDirectProfile. These are variable condition profiles where the condition is implemented directly as a function of time.\nA gradient-variable condition profile, e.g. LinearGradientProfile. These are variable condition profiles where the condition is implemented indirectly through its gradient with respect to time. These profiles must be numerically integrated (handled automtically within Kinetica) before they can be used.","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"The ConditionSet constructor takes an optional keyword argument, ts_update. If provided, this argument causes any kinetic simulations done with this ConditionSet to use the discrete rate update approximation, which is usually desired in any moderate to large-scale CRN simulations. For more information, see the tutorial on ODE Solution.","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"A ConditionSet which implements static simulation volume, linearly increasing temperature and linearly decreasing pressure with a rate constant update timestep of 1 ms could therefore look like the following:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"conditions = ConditionSet(Dict(\n    :V => 1000.0,\n    :T => LinearDirectProfile(;\n        rate = 20.0,\n        X_start = 300.0,\n        X_end = 500.0\n    ),\n    :P => LinearGradientProfile(;\n        rate = -50.0,\n        X_start = 1e5,\n        X_end = 9e4\n    )),\n    ts_update = tconvert(1.0, \"ms\", \"s\")\n)","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"note: Converting times\nBy default, Kinetica works in units of seconds (this can be changed within the kinetic calculator being used). While the conversion above may be a bit redundant, the tconvert function can be used to quickly convert between commonly used time units.","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"warning: Discrete Rate Approximation Behaviour\nThe behaviour of the ts_update argument is subject to change in the near future. This will likely not be a dramatic change, but it may be worth bearing in mind.","category":"page"},{"location":"tutorials/arbitrary-conditions/#Useful-Functions","page":"Arbitrary Simulation Conditions","title":"Useful Functions","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"Once constructed, ConditionSets can be queried in a number of ways. To fetch any of the profiles within, get_profile can be called:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"get_profile(conditions, :T)","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"To test if a given condition is static or variable, the isstatic and isvariable funcitons can be called:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"println(\"Temperature profile is static: $(isstatic(conditions, :T))\")\nprintln(\"Pressure profile is variable: $(isvariable(conditions, :P))\")","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"To get the final time at which all condition profiles have stopped varying, get_t_final can be called. This returns the maximum value of each condition profile's t_end attribute (see below):","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"get_t_final(conditions)","category":"page"},{"location":"tutorials/arbitrary-conditions/#Condition-Profile-Showcase","page":"Arbitrary Simulation Conditions","title":"Condition Profile Showcase","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"Below are the currently implemented variable condition profiles, along with examples of their shapes. Condition profiles are being added as we need them, so this library is currently quite small. You can help us out by adding new profiles and submitting a pull request (see the Development section on Condition Profiles), or by requesting them to be added on our Issues page!","category":"page"},{"location":"tutorials/arbitrary-conditions/#Directly-Variable-Condition-Profiles","page":"Arbitrary Simulation Conditions","title":"Directly Variable Condition Profiles","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/#[LinearDirectProfile](@ref)","page":"Arbitrary Simulation Conditions","title":"LinearDirectProfile","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"This profile represents a linear change from one value to another. It has a piecewise linear condition function, defined as follows for the arbitrary condition X:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"Xleft( t right) = \n    begincases\n        textttX_start  textif  t leq 00 \n        textttX_start + tleft( textttrate right)  textif  t  00 text and  t leq t_textend \n        textttX_end  textif  t  t_textend \n    endcases","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"where t_textend = left( textttX_end - textttX_start right)  textttrate. For example:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"# This is not being run in an example block with lines hidden because there\n# is seemingly no way of not having any kind of return block, and redefining\n# the functions within profiles prints to stderr, which is returned when the\n# example returns nothing.\ncs = ConditionSet(Dict(\n    :T => LinearDirectProfile(;\n        X_start = 300.0,\n        X_end = 500.0,\n        rate=20.0)\n))\ncspars.tspan = (0.0, get_t_final(cs))\nsolve_variable_conditions!(cs, cspars)\nplot(get_profile(cs, :T).sol, label=\"T\", xlabel=\"t\")\nsavefig(\"../assets/tutorials/arbitrary_conditions/lineardirectprofile.svg\")","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"cs = ConditionSet(Dict(\n    :T => LinearDirectProfile(;\n        X_start = 300.0,\n        X_end = 500.0,\n        rate=20.0)\n))","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"(Image: )","category":"page"},{"location":"tutorials/arbitrary-conditions/#Gradient-Variable-Condition-Profiles","page":"Arbitrary Simulation Conditions","title":"Gradient-Variable Condition Profiles","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/#[LinearGradientProfile](@ref)","page":"Arbitrary Simulation Conditions","title":"LinearGradientProfile","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"The gradient-based implementation of LinearDirectProfile. Either can be used, they should be equally accurate. Mostly serves as an example of how gradient profiles differ in implementation to their directly variable counterparts. It has a piecewise linear gradient function, defined as follows for the arbitrary condition X:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"fracmathrmd Xleft( t right)mathrmdt = \n    begincases\n        00  textif  t leq 00 \n        textttrate  textif  t  00 text and  t leq t_textend \n        00  textif  t  t_textend \n    endcases","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"where t_textend = left( textttX_end - textttX_start right)  textttrate. For example:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"cs = ConditionSet(Dict(\n    :P => LinearGradientProfile(;\n        X_start = 1e5,\n        X_end = 9e4,\n        rate=-50.0)\n))\ncspars.tspan = (0.0, get_t_final(cs))\nsolve_variable_conditions!(cs, cspars)\nplot(get_profile(cs, :P).sol)\nsavefig(\"../assets/tutorials/arbitrary_conditions/lineargradientprofile.svg\")","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"cs = ConditionSet(Dict(\n    :P => LinearGradientProfile(;\n        X_start = 1e5,\n        X_end = 9e4,\n        rate=-50.0)\n))","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"(Image: )","category":"page"},{"location":"tutorials/arbitrary-conditions/#[DoubleRampGradientProfile](@ref)","page":"Arbitrary Simulation Conditions","title":"DoubleRampGradientProfile","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"This profile represents two linear condition ramps, each of which can have either a positive or a negative gradient, separated by a plateau of variable time. The profile also begins and ends with variable-length condition plateaus to enable equilibration at the initial and final values. It has a piecewise linear gradient function, defined as follows for the arbitrary condition X:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"fracmathrmd Xleft( t right)mathrmdt = \n    begincases\n        00  textif  t  t_r1 textstart \n        textttrate1  textif  t_r1 textstart leq t  t_r1 textend \n        00  textif  t_r1 textend leq t  t_r2 textstart \n        textttrate2  textif  t_r2 textstart leq t  t_r2 textend \n        00  textif  t geq t_r2 textend \n    endcases","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"where textttrate1 and textttrate2 are the rates of change of the two linear ramps, and t_r1 textstart, t_r1 textend, t_r2 textstart and t_r2 textend are the respective start- and end-times of the first and second ramps, determined by the lengths of the starting, middle and ending plateaus.","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"The profile features an optional argument t_blend, which can be used to create smooth transitions between the otherwise discontinuous gradient changes through linear interpolation. For example:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"cs = ConditionSet(Dict(\n    :K => DoubleRampGradientProfile(;\n        X_start = 100.0,\n        t_start_plateau = 3.0,\n        rate1 = 10.0,\n        X_mid = 250.0,\n        t_mid_plateau = 5.0,\n        rate2 = -25.0,\n        X_end = 50.0,\n        t_end_plateau = 10.0,\n        t_blend = 0.5)\n))\ncspars.tspan = (0.0, get_t_final(cs)) # hide\nsolve_variable_conditions!(cs, cspars) # hide\nplot(get_profile(cs, :K).sol) # hide\nsavefig(\"../assets/tutorials/arbitrary_conditions/doublerampgradientprofile.svg\"); nothing # hide","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"(Image: )","category":"page"},{"location":"api/kinetica/utilities/#Kinetica.jl-API","page":"Utilities","title":"Kinetica.jl API","text":"","category":"section"},{"location":"api/kinetica/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"api/kinetica/utilities/","page":"Utilities","title":"Utilities","text":"tconvert\ncreate_savepoints\nformat_rxn\nprint_rxn","category":"page"},{"location":"api/kinetica/utilities/#Kinetica.tconvert","page":"Utilities","title":"Kinetica.tconvert","text":"tconvert(t<:Real, from_unit::String, to_unit::String)\n\nConverts a time from one unit (from_unit) to another (to_unit).\n\nSupported units (with accepted abbreviations) are:\n\npicoseconds (ps)\nnanoseconds (ns)\nmicroseconds (us)\nmilliseconds (ms)\nseconds (s)\nminutes (mins)\nhours (hrs)\ndays\nmonths (mts)\nyears (yrs)\n\nWill throw an error if unsupported units are provided.\n\n\n\n\n\ntconvert(from_unit::String, to_unit::String)\n\nReturns tconvert(1.0, from_unit, to_unit).\n\nUseful for just getting a conversion factor between time units,  rather than converting a specific time directly.\n\n\n\n\n\ntconvert(t::Vector{<:Real}, from_unit::String, to_unit::String)\n\nConverts a vector of times from one unit (from_unit) to another (to_unit).\n\nSupported units (with accepted abbreviations) are:\n\npicoseconds (ps)\nnanoseconds (ns)\nmicroseconds (us)\nmilliseconds (ms)\nseconds (s)\nminutes (mins)\nhours (hrs)\ndays\nmonths (mts)\nyears (yrs)\n\nWill throw an error if unsupported units are provided.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/utilities/#Kinetica.create_savepoints","page":"Utilities","title":"Kinetica.create_savepoints","text":"create_savepoints(start, stop, step)\n\nCreates a range of savepoints, ensuring that the final time is included.\n\nSafely modifies step to account for small floating point errors introduced by calling tconvert.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/utilities/#Kinetica.format_rxn","page":"Utilities","title":"Kinetica.format_rxn","text":"format_rxn(sd::SpeciesData, rd::RxData, rid::Int)\n\nNicely formats a string describing the reaction at rid.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/utilities/#Kinetica.print_rxn","page":"Utilities","title":"Kinetica.print_rxn","text":"print_rxn(sd::SpeciesData, rd::RxData, rid::Int)\n\nPrints the reaction at ID rid with SMILES names for species.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/utilities/#Logging","page":"Utilities","title":"Logging","text":"","category":"section"},{"location":"api/kinetica/utilities/","page":"Utilities","title":"Utilities","text":"start_log\nend_log\nflush_log","category":"page"},{"location":"api/kinetica/utilities/#Kinetica.start_log","page":"Utilities","title":"Kinetica.start_log","text":"start_log(logdir::String[, label::String=\"Kinetica\", min_level=logging.Info])\n\nCreates a SimpleLogger for logging to a file in logdir.\n\nFilename of the log can be customised using label. All new logfiles will have dates attached.\n\nExample\n\n# Creates a new logfile in `logdir/MyLog_yymmdd-HHMMSS.log`\nlogger = start_log(logdir; label=\"MyLog\")\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/utilities/#Kinetica.end_log","page":"Utilities","title":"Kinetica.end_log","text":"end_log(logger<:AbstractLogger)\nend_log(logger::MinLevelLogger)\n\nCloses the IOStream attached to logger.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/utilities/#Kinetica.flush_log","page":"Utilities","title":"Kinetica.flush_log","text":"flush_log()\n\nFlushes the IOStream attached to the currently scoped logger.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/openbabel/#Kinetica.jl-API","page":"Open Babel","title":"Kinetica.jl API","text":"","category":"section"},{"location":"api/kinetica/openbabel/#Open-Babel","page":"Open Babel","title":"Open Babel","text":"","category":"section"},{"location":"api/kinetica/openbabel/#Conversion","page":"Open Babel","title":"Conversion","text":"","category":"section"},{"location":"api/kinetica/openbabel/#Property-Calculation","page":"Open Babel","title":"Property Calculation","text":"","category":"section"},{"location":"api/kinetica/openbabel/","page":"Open Babel","title":"Open Babel","text":"get_species_stats!","category":"page"},{"location":"api/kinetica/openbabel/#Kinetica.get_species_stats!","page":"Open Babel","title":"Kinetica.get_species_stats!","text":"get_species_stats!(sd::SpeciesData[, refresh=false])\n\nGets statistics about the species in sd.\n\nCalculates values for the following useful statistics, which are placed in the species data cache at sd.cache with a key for each property:\n\nAverage COM-atom radius of species (:radii)\nMolecular weight of species (:weights)\n\nOnly calculates statistics for species without defined values, unless refresh=true which causes all statistics for every species to be updated.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/rdkit/#Kinetica.jl-API","page":"RDKit","title":"Kinetica.jl API","text":"","category":"section"},{"location":"api/kinetica/rdkit/#RDKit","page":"RDKit","title":"RDKit","text":"","category":"section"},{"location":"tutorials/iterative-exploration/#Iterative-CRN-Exploration","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"","category":"section"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"The iterative CRN exploration method (IterativeExplore) allows for CRNs to be efficiently explored by only attempting to find reactions involving kinetically viable species. In the vast majority of cases, this produces CRNs with more thoroughly sampled reactions per species than the direct exploration method (DirectExplore, demonstrated in Getting Started).","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"(Image: )","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"The figure above shows the main methodological differences between the direct and iterative exploration methods. In the direct method (a), as many reactions as possible are explored outwards from a starting system of species. This is done by successive iterations of stochastic mechanism generation with CDE's single-ended graph-driven sampling (SE-GDS) method. Each random mechanism is of length n_r, controlled within Kinetica by the radius parameter in a CDE parameter block. ","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"CRNs are built by adding all new reactions from each mechanism to the current SpeciesData and RxData (see CRN Representation for details). Mechanism generation proceeds until a user-defined number of CDE iterations have passed without any new reactions being added to the CRN (controlled by the rxn_convergence_threshold parameter of DirectExplore).","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"The direct method has a number of flaws when applied to large CRNs - it is capable of simulataneously under-exploring reactions between species many reactive steps away from the starting system, and it over-explores species and reactions that may never form/occur due to the kinetics of the CRN as a whole. This is the rationale behind the iterative exploration method.","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"In the iterative method (b), exploration proceeds in levels. Each level consists of the following steps:","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"A system of species is created. CDE requires species to be input within a single XYZ file, so care must be taken to place species in cartesian space such that they are separated (not considered to be bonded to one another). \nThis is performed by optimisation of a spring-particle system that moves species' centres of mass (see Molecule System).\nReactions of species within this system are explored. This is usually set such that only adjacent reactions - those that are a single reaction away from reactants within the given species system - are explored, as this avoids the most unneccessary exploration. \nThis is first done by finding all same-species reactions, both unimolecular and bimolecular, then finding all different-species reactions. This occurs in dedicated subspaces, which are then collated to form the overall level.\nEach subspace is considered to be converged in the same way as a direct method CRN - once a user-defined number of CDE iterations have passed without any new reactions being discovered (controlled by the rxn_convergence_threshold parameter of IterativeExplore).\nA kinetic simulation is run with the full CRN explored so far. This is done to identify species which exist at a high concentration at some point during the time period of interest, as these species are the most likely to react since they are most prevalent in the reaction mixture.\nThese high concentration species are referred to as seed species within Kinetica, as they are used to grow the next level of exploration.\nSpecies are selected as seeds if they have a maximum concentration above the seed_conc parameter of IterativeExplore.\nThe seed species are collated and the next level begins at step 1.","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"The iterative exploration method stops generating new levels of reactions once seed_convergence_threshold levels of exploration have passed without the seed system changing. This indicates that the remaining seeds are the high concentration species that should exist within the full CRN.","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"By only exploring down reactive pathways that are kinetically viable, the iterative exploration method avoids the combinatorial explosion of possible reactions that the direct method faces. This comes with the benefit of avoiding exploration of reactions that cannot occur because their reactants are never formed, speeding up kinetic simulations dramatically.","category":"page"},{"location":"tutorials/iterative-exploration/#Example","page":"Iterative CRN Exploration","title":"Example","text":"","category":"section"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"From a user's perspective, running a CRN exploration with the iterative method is almost identical to running one with the direct method. The simulation conditions, parameters and calculator are all defined in the same way, but an IterativeExplore parameter block is used instead of a DirectExplore block:","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"crn_dir = \"./my_iterative_CRN\"\n\nexploremethod = IterativeExplore(\n    rdir_head = crn_dir,\n    reac_smiles = [\"C\"],\n    rxn_convergence_threshold = 5,\n    seed_convergence_threshold = 3,\n    seed_conc = 0.05,\n    independent_blacklist = [\"[H]\"],\n    cde = CDE(\n        template_dir = \"../../examples/cde_template\",\n        radius = 1\n    )\n)","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"Most of the new parameters here are defined above, with exception of the independent_blacklist parameter. This defines a list of SMILES species names which should not be subjected to same-species reactions within their own subspace. The hydrogen radical is shown here as an example, as it cannot break down any more and the only reactions which consume it are the opposites of those that create it.","category":"page"},{"location":"tutorials/iterative-exploration/#Setting-seed_conc","page":"Iterative CRN Exploration","title":"Setting seed_conc","text":"","category":"section"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"The value of the seed_conc parameter is crucial in iterative explorations, effectively determining the accuracy of the resulting CRN. Set too high, very few species will ever have maximum concentrations above it and CRN levels will not contain many reactions, leading to a CRN that converges very quickly but is not sampled enough to be accurate. If seed_conc is set too low however, too many species will become seeds and individual levels will struggle to converge due to the breadth of reactions that must be sampled.","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"Finding the 'correct' value of seed_conc is therefore not a simple task - it is highly dependent on the species being reacted and the conditions and kinetic calculator that the simulations which guide the CRN exploration are using. We therefore recommend that multiple iterative explorations are run with decreasing values of seed_conc until an acceptable CRN accuracy has been found (i.e. the CRN is as complete as it needs to be for your use case). It can help if you have some experimental results for a related initial system under similar conditions to compare against.","category":"page"},{"location":"tutorials/filtering-crns/#Filtering-CRNs","page":"Filtering CRNs","title":"Filtering CRNs","text":"","category":"section"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"Sometimes, certain chemical reactions are known to be unwanted in a CRN before any kinetic simulations are run. For example, it may be desirable to place a limit on the size of chemical species within a CRN by removing any reactions which create species above this size.","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"Kinetica enables this reaction filtering through an easily extensible system that can scale to as many arbitrary filters as desired. This is done by constructing a RxFilter. This is essentially a Vector of functions, each of which takes the current CRN in the form (SpeciesData, RxData) and returns a boolean mask over the reactions in the given RxData.","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"To demonstrate, let's construct an RxFilter which removes all reactions involving double bonds from a CRN. We'll use the CRN we created in Getting Started by loading the results file and extracting the SpeciesData and RxData:","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"using Kinetica\nres = load_output(\"../my_CRN_out/direct_network_final.bson\")\nsd, rd = res.sd, res.rd\nnothing # hide","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"If we inspect the reactions in this CRN, we can see that quite a few of them involve double bonds (represented in SMILES by an equals sign = between two elements):","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"for i in 1:rd.nr\n    print_rxn(sd, rd, i)\nend\nnothing # hide","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"To create our RxFilter, we must first write a function that identifies reactions which involve double bonds, then writes a boolean mask which indicates that these reactions should be removed. Remember that this function must take the current CRN in the form (SpeciesData, RxData):","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"function db_filter(sd, rd)\n    # Create a mask where no reactions are removed.\n    mask = [false for _ in 1:rd.nr]\n\n    # Iterate through products of reactions.\n    for (i, rx_reac_ids) in enumerate(rd.id_reacs)\n        for reac_species_id in rx_reac_ids\n            # Set mask at this reaction to true if there are double bonds.\n            # We can determine this easily by the presence of '=' in a species' SMILES.\n            if '=' in sd.toStr[reac_species_id]\n                mask[i] = true\n                break\n            end\n        end\n    end\n    \n    # Do the same for products of reactions.\n    for (i, rx_prod_ids) in enumerate(rd.id_prods)\n        # Skip already masked reactions.\n        if mask[i] continue end\n        for prod_species_id in rx_prod_ids\n            if '=' in sd.toStr[prod_species_id]\n                mask[i] = true\n                break\n            end\n        end\n    end\n\n    return mask\nend","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"We can turn this into a RxFilter like so:","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"filter = RxFilter([db_filter])","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"note: Inverting Filters\nWe have created a filter that will remove reactions where the mask is true, however sometimes it may be more convenient to write filters that only keep reactions where the mask is true. This is supported by passing the keyword argument keep_filtered=true (false by default) to RxFilter during its construction.","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"Filters are applied automatically when running a kinetic simulation, as long as they are provided when constructing the intermediate StaticODESolve/VariableODESolve object:","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"# conditions = ConditionSet(...)\n# pars = ODESimulationParams(...)\n# calculator = ...\nsolvemethod = VariableODESolve(pars, conditions, calculator, filter)\n# res = solve_network(solvemethod, sd, rd)","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"Under the hood, this is just calling a simple procedure: filter is queried to construct a combined mask from all filter functions given the current CRN, and splice!(::RxData, ::Vector{Int}) is called to remove the masked reactions from the CRN. We can replicate this to see how the CRN is modified by our filter:","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"mask = get_filter_mask(filter, sd, rd)\n# Create a copy of RxData to avoid modifying it.\nfiltered_rd = deepcopy(rd)\nsplice!(filtered_rd, findall(mask))\n\nfor i in 1:filtered_rd.nr\n    print_rxn(sd, filtered_rd, i)\nend\nnothing # hide","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"note: Using findall(mask)\nNote that we can't just pass the mask directly to the splice! function - instead, we must pass it through findall. This converts the BitVector mask into a Vector{Int} containing the indices of reactions where the mask is true, which is compatible with splice!.","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"We've now successfully masked out all of the reactions that involve double bonds from our CRN! However, let's say we also want to remove all reactions that consume methane (C in SMILES). We could extend our db_filter function above, but it would start to become quite large. Instead, we can create a new function for this new filter and let the RxFilter do the work of combining the resulting masks together:","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"function methane_filter(sd, rd)\n    mask = [false for _ in 1:rd.nr]\n    for (i, rx_reac_ids) in enumerate(rd.id_reacs)\n        for reac_species_id in rx_reac_ids\n            if sd.toStr[reac_species_id] == \"C\"\n                mask[i] = true\n                break\n            end\n        end\n    end\n    return mask\nend\n\n# Create a new filter that uses both filter functions.\nfilter = RxFilter([db_filter, methane_filter])\n\n# Create a new combined mask to act on the original CRN.\nmask = get_filter_mask(filter, sd, rd)\n\n# Filter the original CRN with both filters.\nfiltered_rd = deepcopy(rd)\nsplice!(filtered_rd, findall(mask))\n\nfor i in 1:filtered_rd.nr\n    print_rxn(sd, filtered_rd, i)\nend\nnothing # hide","category":"page"},{"location":"tutorials/filtering-crns/","page":"Filtering CRNs","title":"Filtering CRNs","text":"Notice that now we've also filtered out all reactions where methane (C) was a reactant! We can combine as many filter functions as we want in this way to remove arbitrary sets of reactions from a CRN as needed.","category":"page"},{"location":"api/kineticakpm/#KineticaKPM.jl-API","page":"KineticaKPM.jl","title":"KineticaKPM.jl API","text":"","category":"section"},{"location":"api/kineticakpm/#KPM-Runner","page":"KineticaKPM.jl","title":"KPM Runner","text":"","category":"section"},{"location":"api/kineticakpm/","page":"KineticaKPM.jl","title":"KineticaKPM.jl","text":"KPMRun","category":"page"},{"location":"api/kineticakpm/#KineticaKPM.KPMRun","page":"KineticaKPM.jl","title":"KineticaKPM.KPMRun","text":"kpm = KPMRun(model_path)\n\nKPM runner for prediction of reaction activation energies.\n\nHandles instantiation of the underlying Scikit-Learn model in Python, and can be called to use this model for predictions.\n\n\n\n\n\n","category":"type"},{"location":"api/kineticakpm/#KPM-Calculators","page":"KineticaKPM.jl","title":"KPM Calculators","text":"","category":"section"},{"location":"api/kineticakpm/","page":"KineticaKPM.jl","title":"KineticaKPM.jl","text":"KPMBasicCalculator\nKPMCollisionCalculator\nKPMCollisionEntropyCalculator","category":"page"},{"location":"api/kineticakpm/#KineticaKPM.KPMBasicCalculator","page":"KineticaKPM.jl","title":"KineticaKPM.KPMBasicCalculator","text":"Basic KPM kinetic calculator for reactions.\n\nKinetic calculator that uses KPM to predict activation energies for reactions and uses these predictions within the Arrhenius equation to calculate rate constants.\n\nBasic calculator uses a flat RT/h Arrhenius prefactor for all reactions. This is usually not accurate enough to enable sensible kinetic simulations.\n\nImplemented conditions:\n\nTemperature (T, unit: K)\n\nRequires:\n\nReaction energies (rd.dH, unit: eV)\nTrained KPM model (kpm.model_path, loaded when KPMRun is instantiated)\n\nHas support for dispatching with/without a maximum rate constant k_max and scaling by time unit t_unit (assuming rates are provided in units of /s).\n\n\n\n\n\n","category":"type"},{"location":"api/kineticakpm/#KineticaKPM.KPMCollisionCalculator","page":"KineticaKPM.jl","title":"KineticaKPM.KPMCollisionCalculator","text":"Collision theory-based KPM kinetic calculator for reactions.\n\nKinetic calculator that uses KPM to predict activation energies for reactions and uses these predictions within the Arrhenius equation to calculate rate constants.\n\nCollision theory-based calculator approximates Arrhenius prefactors on a per-reaction basis with a hard sphere approximation of collision frequency. This is most accurate for small, spherical reactants, and becomes less realistic the further from this ideal the reactants get.\n\nAdditionally, allows for using one of a selection of steric factors for correcting discrepancies between collision theory prefactors and real Arrhenius prefactors.\n\nImplemented conditions:\n\nTemperature (T, unit: K)\n\nRequires:\n\nReaction energies (rd.dH, unit: eV)\nTrained KPM model (kpm.model_path, loaded when KPMRun is instantiated)\n\nHas support for dispatching with/without a maximum rate constant k_max and scaling by time unit t_unit (assuming rates are provided in units of /s).\n\n\n\n\n\n","category":"type"},{"location":"api/kineticakpm/#KineticaKPM.KPMCollisionEntropyCalculator","page":"KineticaKPM.jl","title":"KineticaKPM.KPMCollisionEntropyCalculator","text":"Collision theory-based KPM kinetic calculator for reactions, with translational entropy.\n\nKinetic calculator that uses KPM to predict activation energies for reactions and uses these predictions within the Arrhenius equation to calculate rate constants.\n\nCollision theory-based calculator approximates Arrhenius prefactors on a per-reaction basis with a hard sphere approximation of collision frequency. This is most accurate for small, spherical reactants, and becomes less realistic the further from this ideal the reactants get.\n\nAdditionally, calculates translational entropy change for each reaction to correct for lack of entropic contribution in collision theory prefactors.\n\nImplemented conditions:\n\nTemperature (T, unit: K)\n\nRequires:\n\nReaction energies (rd.dH, unit: eV)\nTrained KPM model (kpm.model_path, loaded when KPMRun is instantiated)\n\nHas support for dispatching with/without a maximum rate constant k_max and scaling by time unit t_unit (assuming rates are provided in units of /s).\n\n\n\n\n\n","category":"type"},{"location":"api/kineticakpm/#Property-Calculation","page":"KineticaKPM.jl","title":"Property Calculation","text":"","category":"section"},{"location":"api/kineticakpm/","page":"KineticaKPM.jl","title":"KineticaKPM.jl","text":"KineticaKPM.calc_collision_params\nKineticaKPM.calc_steric_factors","category":"page"},{"location":"api/kineticakpm/#KineticaKPM.calc_collision_params","page":"KineticaKPM.jl","title":"KineticaKPM.calc_collision_params","text":"μ, σ = calc_collision_params(rd, sd[, easy_units])\n\nCalculates the collision theory parameters for given reactions.\n\nCollision theory requires calculation of a reduced mass μ and a collision cross-section σ for each pair of reactants in a reaction.\n\nCalculates these values, using an 'average collision partner' for unimolecular reactions. Possible to get around this by implementing a non-reactive collision partner with unit concentration to all  unimolecular reactions, effectively making them bimolecular for the purposes of these calculations.\n\nMust be preceded by a call to get_frag_stats!() to populate species weights and radii.\n\n\n\n\n\n","category":"function"},{"location":"api/kineticakpm/#KineticaKPM.calc_steric_factors","page":"KineticaKPM.jl","title":"KineticaKPM.calc_steric_factors","text":"ρ = calc_steric_factors(rd, sd, steric_factor)\n\nCalculates steric factors for all reactions in rd, using the requested steric factor function.\n\nValid steric factors are\n\n:basic - Calculates steric factors as 1/(α_A * α_B), where α_i = n_i² + 5r_i(n_i - 1).\n:exp - Calculates steric factors as 1/(α_A * α_B)^β, where α_i = n_i² + 5r_i(n_i - 1). Requires passing a value of β via params\n:logistic - Calculates steric factors with an adjustable bivariate logistic distribution. Requires passing a value of β via params\n:dlogistic - Calculates steric factors with 2 adjustable bivariate logistic distributions. Requires passing a vector of [βassoc, βdissoc] via params\n:none - Makes all steric factors equal to 1, removing them from the rate equation.\n\n\n\n\n\nρ = calc_steric_factors(rd, sd, Val(:none))\n\nMakes all steric factors equal to 1, removing them from the rate equation.\n\n\n\n\n\nρ = calc_steric_factors(rd, uniq_frags, Val(:basic))\n\nCalculates steric factors as 1/(α_A * α_B), where α_i = n_i + 5r_i(n_i - 1).\n\n\n\n\n\nρ = calc_steric_factors(rd, uniq_frags, Val(:exp), β)\n\nCalculates steric factors as 1/(α_A * α_B)^β, where α_i = n_i² + 5r_i(n_i - 1).\n\n\n\n\n\nρ = calc_steric_factors(rd, uniq_frags, Val(:logistic), β)\n\nCalculates steric factors on an adjustable bivariate logistic distribution.\n\nThe steric factor ρ for a reaction is calculated as\n\nρ = D / ((1+exp(βα_A))(1+exp(βα_B)))\n\nwhere \n\nD = (1+exp(β))^2, \nα_i = n_i + 5r_i(n_i-1),\n\nand A and B are the bimolecular reactants.\n\n\n\n\n\nρ = calc_steric_factors(rd, uniq_frags, Val(:dlogistic), β_assoc, β_dissoc)\n\nCalculates steric factors on 2 adjustable bivariate logistic distributions.\n\nCreates 2 logistic distributions: one for associative reactions, and the other for dissociative reactions. The gradient of each distribution can be tuned with its respective β parameter.\n\nThe steric factor ρ for an associative reaction is calculated as\n\nρ = D_assoc / ((1+exp(β_assoc*α_A))(1+exp(β_assoc*α_B)))\n\nwhile the steric factor for a dissociative reaction is calculated as\n\nρ = D_dissoc / ((1+exp(β_dissoc*α_A))(1+exp(β_dissoc*α_B)))\n\nwhere \n\nD_assoc = (1+exp(β_assoc))^2, \nD_dissoc = (1+exp(β_dissoc))^2,\nα_i = n_i + 5r_i(n_i-1),\n\nand A and B are the bimolecular reactants. Reactions which are neither associative nor dissociative use the associative steric factor by default.\n\n\n\n\n\n","category":"function"},{"location":"#Kinetica.jl-Documentation","page":"Home","title":"Kinetica.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kinetica.jl is a Julia package for performing automated exploration of chemical reaction networks (CRNs) and integrating these networks in time. In particular, it features:","category":"page"},{"location":"#Arbitrary-simulation-conditions","page":"Home","title":"Arbitrary simulation conditions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kinetica.jl is built around giving users complete freedom over kinetic simulations. As such any combination of customisable simulation conditions, static or variable, can be utilised by binding symbolic variable names to flexible parametric condition profiles.","category":"page"},{"location":"#Kinetics-driven-CRN-exploration","page":"Home","title":"Kinetics-driven CRN exploration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Chemical space exploration can be performed with a fully random approach, sampling every reaction within a defined number of intermediates from a starting system. This can be very difficult to sample completely and is often inefficient. We provide a focused kinetics-driven approach that selectively explores reaction space in places relevant to the given simulation conditions.","category":"page"},{"location":"#Flexible-kinetic-simulation","page":"Home","title":"Flexible kinetic simulation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"By leveraging packages from Julia's SciML organization (including DifferentialEquations.jl, ModelingToolkit.jl and Catalyst.jl), users can perform difficult long-timescale integrations of generated CRNs under challenging variable experimental conditions. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We supplement this with a discrete approximation to variable rate constant simulations that greatly improves overall solution efficiency and allows for previously inaccessible levels of theory to be incorporated into variable kinetic calculations.","category":"page"},{"location":"#Modular-kinetic-calculators","page":"Home","title":"Modular kinetic calculators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Extending user control over kinetic simulations, Kinetica.jl makes use of a modular calculator interface for rate constant calculations. This allows for a wide variety of techniques to be utilised within kinetic simulations, ranging from expensive DFT-based approaches to fast ML-based approximations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We currently provide the KineticaKPM.jl package for calculating rate constants from ML-predicted activation energies, and aim to release further calculator packages in the future. However, the calculator interface allows for simple user definition of new methods too.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kinetica.jl can be installed through the Julia package manager by adding the KinetcaRegistry package registry:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.Registry.add(RegistrySpec(url=\"https://github.com/Kinetica-jl/KineticaRegistry\"))\nPkg.add(\"Kinetica\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will fetch the latest version of Kinetica.jl, as well as all of its dependencies.","category":"page"},{"location":"#Other-Kinetica-Packages","page":"Home","title":"Other Kinetica Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This process is the same for other Kinetica extension packages, such as KineticaKPM.jl, which can be installed in the same way, e.g.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"KineticaKPM\")","category":"page"},{"location":"#Python-Dependencies","page":"Home","title":"Python Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kinetica makes use of Python packages such as RDKit and Open Babel internally for extracting information from molecular geometries. Installation of these packages is handled automatically thanks to CondaPkg.jl, which creates a conda environment that is isolated to the current project and the packages within it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This conda environment is composable at runtime, so if you were to have both Kinetica.jl and KineticaKPM.jl in the same Julia project, the Python dependencies of both packages would be automatically assembled into a dedicated conda environment that is then used internally by both packages through PythonCall.jl. ","category":"page"},{"location":"#xTB","page":"Home","title":"xTB","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"While not a direct dependency, some parts of Kinetica's CRN exploration routines (which act through the CDE code) require an electronic structure code to perform geometry optimisations and energy calculations. Since only approximate geometries and energies are required within CDE, we recommend using the GFN2-xTB method within the Extended Tight-Binding (xTB) package by Bannwarth et. al. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"An xTB package is included with Kinetica.jl's Python dependencies and will be installed automatically. While not available on your system's PATH by default, it will be accessible to Kinetica. If you wish to also use Kinetica's installed xTB binary outside of Kinetica, an alias can be created (assuming you are in your Julia project's directory) with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"alias xtb=\"$(julia --project -e 'using CondaPkg; print(CondaPkg.which(\"xtb\"))')\"","category":"page"},{"location":"#Graphviz","page":"Home","title":"Graphviz","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Graphviz is an open source software suite for graph visualisation. Kinetica provides an interface to Graphviz through Catalyst.jl (see Results Analysis) and bundles it as a Python dependency, the same as xTB above.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Graphviz executables are similarly not added to your system's PATH but are available to Kinetica, and the same aliasing procedure as above can be applied if access to these executables is desired outside of Kinetica.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Why not Graphviz_jll?\nSome readers may note that Graphviz is also distributed as a JLL package through the Julia package manager, and installing it this way may be simpler than treating it as a Python dependency. However, Graphviz_jll.jl is currently compiled without some optional dependencies such as GTS, making it much less useful for graphing large CRNs. We therefore fall back to the Conda package for the time being.","category":"page"},{"location":"#Citing-Kinetica","page":"Home","title":"Citing Kinetica","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use any of the Kinetica packages in your work, please cite the following:","category":"page"},{"location":"#Kinetica.jl","page":"Home","title":"Kinetica.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Gilkes, J., Storr, M. T., Maurer, R. J., & Habershon, S. (2024). Predicting Long-Time-Scale Kinetics under Variable Experimental Conditions with Kinetica.jl. Journal of Chemical Theory and Computation, 20(12), 5196–5214. https://doi.org/10.1021/acs.jctc.4c00333","category":"page"},{"location":"#KineticaKPM.jl","page":"Home","title":"KineticaKPM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Paper coming soon!","category":"page"},{"location":"api/kinetica/solving/#api_solving","page":"Solving","title":"Kinetica.jl API","text":"","category":"section"},{"location":"api/kinetica/solving/#Simulation-Parameters","page":"Solving","title":"Simulation Parameters","text":"","category":"section"},{"location":"api/kinetica/solving/","page":"Solving","title":"Solving","text":"ODESimulationParams","category":"page"},{"location":"api/kinetica/solving/#Kinetica.ODESimulationParams","page":"Solving","title":"Kinetica.ODESimulationParams","text":"Keyword-defined container for ODE-driven simulation parameters.\n\nContains fields for:\n\nSimulation timespan (must match time unit used in an attached calculator) (tspan)\nInitial concentrations of species, either as a Dict of certain species or a Vector of all species (u0)\nDifferentialEquations ODE solver (solver)\nWhether to use ModelingToolkit to formulate an analytical Jacobian (do_jac=true)\nWhether to use ModelingToolkit to formulate a sparse problem (do_sparse=true)\nAbsolute tolerance of ODE solver (abstol=1e-10)\nRelative tolerance of ODE solver (reltol=1e-8)\nWhether to use adaptive solver tolerance (adaptive_tols=true)\nWhether to update solver tolerances after successful solve with adaptive tolerance (update_tols=false)\nWhether to break solution into chunks of size solve_chunkstep to avoid floating point underflow (solve_chunks=true)\nGlobal timestep at which solution should be reinitialised when solve_chunks=true (solve_chunkstep=1e-3)\nMaximum number of ODE solver iterations (maxiters=1e5)\nWhether to explicitly disallow negative values in the solver (ban_negatives=false)\nWhether to display progress bars - requires TerminalLogger initialisation (progress=false)\nTime interval to interpolate solution data on (save_interval=nothing)\nCutoff below which reactions with low rate constants are removed from the network (low_k_cutoff=:auto)\nMaximum species concentrationto multiply maximum reaction rates by un low rate cutoff (low_k_maxconc=2.0)\nWhether to allow a vector u0 to be shorter than the number of species in the network (allow_short_u0=false)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/solving/#Kinetic-Calculators-(Kinetica.jl)","page":"Solving","title":"Kinetic Calculators (Kinetica.jl)","text":"","category":"section"},{"location":"api/kinetica/solving/","page":"Solving","title":"Solving","text":"allows_continuous\nsetup_network!\nhas_conditions\nBase.splice!(calc::cType, rids::Vector{Int}) where {cType <: Kinetica.AbstractKineticCalculator}\nBase.splice!(rd::RxData, calculator::cType, rids::Vector{Int}) where {cType <: Kinetica.AbstractKineticCalculator}\nPrecalculatedArrheniusCalculator","category":"page"},{"location":"api/kinetica/solving/#Kinetica.allows_continuous","page":"Solving","title":"Kinetica.allows_continuous","text":"allows_continuous(calculator<:AbstractKineticCalculator)\n\nIndicates whether a calculator is allowed to function in continuous variable rate constant simulations.\n\nShould only ever return true for calculators with analytic expressions for rate constants, as only these can be encoded within Symbolics and MTK.\n\nCalculators relying on external function calls should therefore return false, as these calls cannot be encoded. These calculators will only be functional for discrete rate constant update simulations.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/solving/#Kinetica.setup_network!","page":"Solving","title":"Kinetica.setup_network!","text":"setup_network!(sd::SpeciesData, rd::RxData, calculator<:AbstractKineticCalculator)\n\nSets up a network for calculation with the provided calculator.\n\nMust be implemented for each calculator. Called at the start of a kinetic simulation to check compatibility of network with calculator, and to populate network-dependent fields within the calculator.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/solving/#Kinetica.has_conditions","page":"Solving","title":"Kinetica.has_conditions","text":"has_conditions(calculator<:AbstractKineticCalculator, symbols::Vector{Symbol})\n\nChecks if the provided calculator permits calculations with the conditions in symbols.\n\nImplemented as a method for every calculator type. If any of the symbolic experimental conditions in symbols are not listed in the calculator's method, this returns false.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/solving/#Base.splice!-Union{Tuple{cType}, Tuple{cType, Vector{Int64}}} where cType<:Kinetica.AbstractKineticCalculator","page":"Solving","title":"Base.splice!","text":"splice!(calculator, rids)\n\nRemoves all information from the reactions at rids from calculator.\n\nUseful in conjunction with splice!(rd, rids) for removing e.g. low-rate reactions that have been removed from a network from that network's calculator.\n\nRelies on a calculator-specific implementation, as it directly modifies fields of that calculator.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/solving/#Base.splice!-Union{Tuple{cType}, Tuple{RxData, cType, Vector{Int64}}} where cType<:Kinetica.AbstractKineticCalculator","page":"Solving","title":"Base.splice!","text":"splice!(rd, calculator, rids)\n\nConvenience wrapper for deleting reaction data from both a network and its calculator.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/solving/#Kinetica.PrecalculatedArrheniusCalculator","page":"Solving","title":"Kinetica.PrecalculatedArrheniusCalculator","text":"PrecalculatedArrheniusCalculator(Ea, A[, k_max=nothing, t_unit=\"s\"])\n\nArrhenius theory kinetic calculator for precalculated reactions.\n\nKinetic calculator that uses the Arrhenius equation to determine rates of reaction. Requires prior specification of reaction activation energies (Ea) and Arrhenius prefactors (A), will not calculate/predict these internally.\n\nImplemented conditions:\n\nTemperature (T, unit: K)\n\nRequires:\n\nActivation energies (Ea, unit: J/mol)\nArrhenius prefactors (A, unit: mol dm^-3 s^-1 assuming bimolecular reactions)\n\nHas support for dispatching with/without a maximum rate constant k_max and scaling by time unit t_unit (assuming rates are provided in units of /s).\n\n\n\n\n\n(calc::PrecalculatedArrheniusCalculator)(; T)\n\nCalculate rates with precalculated Arrhenius theory kinetic calculator.\n\nRequires temperature (T) as a keyword argument.\n\nAutomatically dispatches to a method with correct formula for k_max-aware calculation if this is defined in the underlying PrecalculatedArrheniusCalculator.\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/solving/#Solvers","page":"Solving","title":"Solvers","text":"","category":"section"},{"location":"api/kinetica/solving/","page":"Solving","title":"Solving","text":"StaticODESolve\nVariableODESolve\nsolve_network","category":"page"},{"location":"api/kinetica/solving/#Kinetica.StaticODESolve","page":"Solving","title":"Kinetica.StaticODESolve","text":"StaticODESolve(pars::ODESimulationParams, conditions::ConditionSet, calculator<:AbstractKineticCalculator[, filter::RxFilter])\n\nStatic kinetic CRN solver type.\n\nCombines all parameter inputs, conditions, a calculator and a set of reaction filters into a single type to be passed to the solver.\n\nAll conditions in the provided ConditionSet must be static  (defined as a single number), and also must be compatible with the provided calculator.\n\nAllows for optional specification of RxFilter. If not defined, creates a filter that allows all reactions.\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/solving/#Kinetica.VariableODESolve","page":"Solving","title":"Kinetica.VariableODESolve","text":"VariableODESolve(pars::ODESimulationParams, conditions::ConditionSet, calculator<:AbstractKineticCalculator[, filter::RxFilter])\n\nVariable kinetic CRN solver type.\n\nCombines all parameter inputs, conditions, a calculator and a set of reaction filters into a single type to be passed to the solver.\n\nConditions in the provided ConditionSet must be compatible with the calculator and can be a combination of static and  variable. However, this will throw an error if all conditions  are static, as a StaticODESolve should be used instead.\n\nAllows for optional specification of RxFilter. If not defined, creates a filter that allows all reactions.\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/solving/#Kinetica.solve_network","page":"Solving","title":"Kinetica.solve_network","text":"solve_network(method::StaticODESolve, sd::SpeciesData, rd::RxData[, copy_network=true, return_integrator=false])\n\nSolve a network with static kinetics.\n\nAutomatically dispatches to the correct method based on the value of method.pars.solve_chunks, as chunkwise solution requires a significantly different approach.\n\nSetting copy_network=true generates a deepcopy of the original network in rd and sd and uses these in the solution, to avoid side effects from calculators modifying the original network that is passed in. The copied (modified) network is returned as part of the  resulting ODESolveOutput.\n\nSetting return_integrator=true sets up and returns the underlying integrator without solving (i.e. at  t = method.pars.tspan[1]), allowing for manual stepping through the solution. Note that chunkwise solutions implement many reinitialisations of this integrator, which will have to be mirrored in the calling script to get the same results.\n\n\n\n\n\nsolve_network(method::VariableODESolve, sd::SpeciesData, rd::RxData[, copy_network=true, return_integrator=false])\n\nSolve a network with variable kinetics.\n\nAutomatically dispatches to the correct method based on the value of method.pars.solve_chunks and  method.conditions.ts_update, as chunkwise and discrete solutions require significantly different approaches.\n\nSetting copy_network=true generates a deepcopy of the original network in rd and sd and uses these in the solution, to avoid side effects from calculators modifying the original network that is passed in. The copied (modified) network is returned as part of the  resulting ODESolveOutput.\n\nSetting return_integrator=true sets up and returns the underlying integrator without solving (i.e. at  t = method.pars.tspan[1]), allowing for manual stepping through the solution. Note that chunkwise solutions implement many reinitialisations of this integrator, which will have to be mirrored in the calling script to get the same results.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/solving/#Reaction-Filtering","page":"Solving","title":"Reaction Filtering","text":"","category":"section"},{"location":"api/kinetica/solving/","page":"Solving","title":"Solving","text":"RxFilter","category":"page"},{"location":"api/kinetica/solving/#Kinetica.RxFilter","page":"Solving","title":"Kinetica.RxFilter","text":"RxFilter(filters[, keep_filtered=false])\n\nData container for CRN filters.\n\nDefines a set of functions which can be used on a network to construct a set of masks of reactions. These reactions can then be excluded from a network, or their inverse can be taken to exclude all other reactions form a network.\n\nContains fields for:\n\nArray of filter functions, each taking a tuple of ::SpeciesData and ::RxData as arguments (filters)\nWhether to remove or keep masked reactions (keep_filtered)\n\nCan be constructed blank (rf = RxFilter()) to obtain a mask of all reactions, which are then kept. Can also be constructed as  rf = RxFilter(filters) to default to removing the filtered reactions.\n\n\n\n\n\n","category":"type"}]
}
