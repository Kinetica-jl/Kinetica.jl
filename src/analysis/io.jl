abstract type AbstractOutputData end

"""
Data container for output of network ODE solutions.

Binds together all data required for analysis of network
ODE solution results. Used as an input for many of the
automated plotting functions in KineticaCore.

Also used for results IO, can be completely deconstructed
into a package-independent dictionary tree for saving as
binary JSON (BSON) with `save_output`. Can be reconstructed
from such a BSON file with `load_output`.
"""
struct ODESolveOutput{sType} <: AbstractOutputData
    sd::SpeciesData
    rd::RxData
    sol::sType
    pars::ODESimulationParams
    conditions::ConditionSet
end

function ODESolveOutput(solvemethod::AbstractODESolveMethod, sol::SciMLBase.AbstractODESolution, sd::SpeciesData, rd::RxData)
    return ODESolveOutput(
        sd,
        rd,
        sol,
        solvemethod.pars,
        solvemethod.conditions
    )
end


"""
    save_output(out, saveto)

Saves the output of a network ODE solution to BSON file.

Avoids massive file sizes and attempts to maintain forward
compatibility by breaking down large structs into their base
arrays and values, such that they can be reconstructed when
loaded back in.

The resulting BSON file is therefore a dictionary tree, which
can be read in using only Julia's base library and OrderedCollections
if all else fails using `BSON.load` directly.

However, the original `ODESolveOutput` can be mostly reconstructed
by instead calling `load_output()`. Some data is necessarily lost
or converted to a Symbol for reference - mostly data concerning
the internals of `ODESolution`s. 
"""
function save_output(out::ODESolveOutput, saveto::String)
    sol_vcs = typeof(out.sol) <: ODESolutionVC ? out.sol.vcs : nothing
    sol_k = typeof(out.sol.k) <: ODESolution ? Dict(
                                                    :u => out.sol.k.u,
                                                    :t => out.sol.k.t,
                                                    :syms => out.sol.k.prob.f.syms
                                               ) : nothing
    condition_profiles = []
    for profile in out.conditions.profiles
        pType = typeof(profile)
        if pType <: AbstractStaticProfile
            pdict = Dict(
                :pType => Symbol(pType),
                :value => profile.value
            )
        elseif pType <: AbstractVariableProfile
            pdict = OrderedDict(fieldnames(pType) .=> getfield.(Ref(profile), fieldnames(pType)))
            if typeof(profile.sol) <: SciMLBase.AbstractODESolution
                pdict[:sol] = Dict(
                    :u => profile.sol.u,
                    :t => profile.sol.t
                )
                pdict[:pType] = Symbol(pType)
            end
            if pType <: AbstractDirectProfile
                pdict[:f] = nothing
            elseif pType <: AbstractGradientProfile
                pdict[:grad] = nothing
            end
        else
            error("Unknown condition profile type for saving.")
        end
        push!(condition_profiles, pdict)
    end

    savedict = Dict(
        :KineticaCoreVersion => version,
        :sd => Dict(
            :toInt => out.sd.toInt,
            :n => out.sd.n,
            :xyz => out.sd.xyz
        ),
        :rd => Dict(
            :nr => out.rd.nr,
            :mapped_rxns => out.rd.mapped_rxns,
            :id_reacs => out.rd.id_reacs,
            :id_prods => out.rd.id_prods,
            :stoic_reacs => out.rd.stoic_reacs,
            :stoic_prods => out.rd.stoic_prods,
            :dH => out.rd.dH,
            :rhash => out.rd.rhash
        ),
        :pars => Dict(
            :tspan => out.pars.tspan,
            :u0 => out.pars.u0,
            :solver => Symbol(typeof(out.pars.solver)),
            :jac => out.pars.jac,
            :sparse => out.pars.sparse,
            :adaptive_tols => out.pars.adaptive_tols,
            :update_tols => out.pars.update_tols,
            :solve_chunks => out.pars.solve_chunks,
            :solve_chunkstep => out.pars.solve_chunkstep,
            :maxiters => out.pars.maxiters,
            :ban_negatives => out.pars.ban_negatives,
            :progress => out.pars.progress,
            :save_interval => out.pars.save_interval,
            :low_k_cutoff => out.pars.low_k_cutoff,
            :allow_short_u0 => out.pars.allow_short_u0
        ),
        :sol => Dict(
            :u => out.sol.u,
            :t => out.sol.t,
            :vcs => sol_vcs,
            :k => sol_k
        ),
        :conditions => Dict(
            :symbols => out.conditions.symbols,
            :profiles => condition_profiles,
            :discrete_updates => out.conditions.discrete_updates,
            :ts_update => out.conditions.ts_update
        )
    )

    bson(saveto, savedict)
end


"""
    out = load_output(outfile)

Loads in the results generated by `save_output` from a network ODE solution.

Reconstructs an `ODESolveOutput` from a dictionary tree in
the BSON file `outfile`. Note that some data is lost in the
serialisation process, see the documentation of `save_output`
for details.
"""
function load_output(outfile::String)
    savedict = BSON.load(outfile)
    if savedict[:KineticaCoreVersion] < version
        @warn "Loaded network output was made in a previous version of KineticaCore, reconstructed output may not be fully compatible."
    elseif savedict[:KineticaCoreVersion] > version
        @warn "Loaded network output was made in a newer version of KineticaCore, reconstructed output may not be fully compatible."
    end

    sd_iType = typeof(savedict[:sd][:n])
    sd_toStr = Dict{sd_iType, String}(value => key for (key, value) in savedict[:sd][:toInt])
    sd = SpeciesData(
        savedict[:sd][:toInt],
        sd_toStr,
        savedict[:sd][:n],
        savedict[:sd][:xyz],
        Dict()
    )
    # For some reason ExtXYZ dicts can get a bit type unstable, species arrays need special handling.
    for i in 1:sd.n
        sd.xyz[i]["arrays"]["species"] = [elem for elem in sd.xyz[i]["arrays"]["species"]]
    end

    rd_iType = typeof(savedict[:rd][:nr])
    rd_mapped_rxns = get(savedict[:rd], :mapped_rxns, String[])
    if length(rd_mapped_rxns) == 0
        @warn "No reaction atom maps found in output."
    end
    rd = RxData(
        savedict[:rd][:nr], String[rxn for rxn in rd_mapped_rxns],
        Vector{rd_iType}[reac for reac in savedict[:rd][:id_reacs]], 
        Vector{rd_iType}[prod for prod in savedict[:rd][:id_prods]],
        Vector{rd_iType}[sreac for sreac in savedict[:rd][:stoic_reacs]], 
        Vector{rd_iType}[sprod for sprod in savedict[:rd][:stoic_prods]],
        savedict[:rd][:dH], 
        Vector{UInt8}[hash for hash in savedict[:rd][:rhash]]
    )

    pars_fields = fieldnames(ODESimulationParams)
    pars_dict = savedict[:pars]
    for param in keys(pars_dict)
        if !(param in pars_fields)
            pval = pop!(pars_dict, param)
            @warn "Unknown parameter in savedict[:pars] ($param, value: $pval), removing from constructed ODESimulationParams."
        end
    end
    pars = ODESimulationParams(; pars_dict...)

    sol_k = isnothing(savedict[:sol][:k]) ? nothing : 
        ODESolution{typeof(savedict[:sol][:k][:u]), 2}(
            savedict[:sol][:k][:u],
            nothing,
            nothing,
            savedict[:sol][:k][:t],
            nothing,
            DummyODEProblem(; u0=savedict[:sol][:k][:u][1], 
                tspan=[savedict[:sol][:k][:t][begin], savedict[:sol][:k][:t][end]], 
                syms=savedict[:sol][:k][:syms]),
            nothing,
            SciMLBase.LinearInterpolation(savedict[:sol][:k][:t], savedict[:sol][:k][:u]),
            false,
            0,
            nothing,
            nothing,
            ReturnCode.Default
        )
    if !isnothing(savedict[:sol][:vcs])
        sol = build_vc_solution(
            DummyODEProblem(; 
                u0=savedict[:sol][:u][1], 
                tspan=[savedict[:sol][:t][begin], savedict[:sol][:t][end]]
            ), 
            nothing, 
            savedict[:sol][:t], savedict[:sol][:u], savedict[:sol][:vcs];
            k=sol_k)
    else
        sol = SciMLBase.build_solution(
            DummyODEProblem(; 
                u0=savedict[:sol][:u][1],
                tspan=[savedict[:sol][:t][begin], savedict[:sol][:t][end]]
            ),
            nothing,
            savedict[:sol][:t], savedict[:sol][:u];
            k=sol_k)
    end

    profiles = AbstractConditionProfile[]
    for profile_dict in savedict[:conditions][:profiles]
        pType = pop!(profile_dict, :pType)
        if :sol in keys(profile_dict)
            profile_dict[:sol] = SciMLBase.build_solution(
                DummyODEProblem(; 
                    u0=[profile_dict[:X_start]], 
                    tspan=[profile_dict[:sol][:t][begin], profile_dict[:sol][:t][end]]
                ),
                nothing,
                profile_dict[:sol][:t],
                profile_dict[:sol][:u]
            )
        end
        if :f in keys(profile_dict)
            profile_dict[:f] = loaded_profile_null_func
        end
        if :grad in keys(profile_dict)
            profile_dict[:grad] = loaded_profile_null_func
        end
        profile = eval(Meta.parse(String(pType)))(values(profile_dict)...)
        push!(profiles, profile)
    end
    conditions = ConditionSet(
        Symbol[sym for sym in savedict[:conditions][:symbols]],
        profiles,
        savedict[:conditions][:discrete_updates],
        savedict[:conditions][:ts_update]
    )

    out = ODESolveOutput(sd, rd, sol, pars, conditions)
    return out
end


function loaded_profile_null_func()
    throw(ErrorException("Condition profile function saving is not supported. Condition function must be manually rebuilt."))
end
loaded_profile_null_func(t) = loaded_profile_null_func()