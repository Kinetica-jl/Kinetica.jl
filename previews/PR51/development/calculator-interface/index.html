<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Calculator Interface · Kinetica.jl</title><meta name="title" content="Calculator Interface · Kinetica.jl"/><meta property="og:title" content="Calculator Interface · Kinetica.jl"/><meta property="twitter:title" content="Calculator Interface · Kinetica.jl"/><meta name="description" content="Documentation for the Kinetica.jl package and its modular kinetic calculators."/><meta property="og:description" content="Documentation for the Kinetica.jl package and its modular kinetic calculators."/><meta property="twitter:description" content="Documentation for the Kinetica.jl package and its modular kinetic calculators."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Kinetica.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Kinetica.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting-started/">Getting Started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/arbitrary-conditions/">Arbitrary Simulation Conditions</a></li><li><a class="tocitem" href="../../tutorials/ode-solution/">ODE Solution</a></li><li><a class="tocitem" href="../../tutorials/kinetic-calculators/">Kinetic Calculators</a></li><li><a class="tocitem" href="../../tutorials/iterative-exploration/">Iterative CRN Exploration</a></li><li><a class="tocitem" href="../../tutorials/results-analysis/">Results Analysis</a></li><li><a class="tocitem" href="../../tutorials/filtering-crns/">Filtering CRNs</a></li><li><a class="tocitem" href="../../tutorials/saving-loading/">Saving &amp; Loading</a></li><li><a class="tocitem" href="../../tutorials/logging/">Logging</a></li></ul></li><li><span class="tocitem">Developing with Kinetica</span><ul><li><a class="tocitem" href="../crn-representation/">CRN Representation</a></li><li><a class="tocitem" href="../condition-profiles/">Condition Profiles</a></li><li class="is-active"><a class="tocitem" href>Calculator Interface</a><ul class="internal"><li><a class="tocitem" href="#Implementation-Example"><span>Implementation Example</span></a></li></ul></li><li><a class="tocitem" href="../ase-calculator-builders/">ASE Calculator Builders</a></li><li><a class="tocitem" href="../implementation-details/">Implementation Details</a></li></ul></li><li><span class="tocitem">API</span><ul><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Kinetica.jl</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/kinetica/exploration/">Exploration</a></li><li><a class="tocitem" href="../../api/kinetica/solving/">Solving</a></li><li><a class="tocitem" href="../../api/kinetica/conditions/">Conditions</a></li><li><a class="tocitem" href="../../api/kinetica/analysis/">Analysis</a></li><li><a class="tocitem" href="../../api/kinetica/openbabel/">Open Babel</a></li><li><a class="tocitem" href="../../api/kinetica/rdkit/">RDKit</a></li><li><a class="tocitem" href="../../api/kinetica/utilities/">Utilities</a></li><li><input class="collapse-toggle" id="menuitem-5-1-8" type="checkbox"/><label class="tocitem" for="menuitem-5-1-8"><span class="docs-label">ASE Interface</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/kinetica/ase_calculator/calculator/">Kinetic Calculator</a></li><li><a class="tocitem" href="../../api/kinetica/ase_calculator/optimisation/">Optimisation</a></li><li><a class="tocitem" href="../../api/kinetica/ase_calculator/builders/">Builders</a></li><li><a class="tocitem" href="../../api/kinetica/ase_calculator/utilities/">Utilities</a></li></ul></li><li><a class="tocitem" href="../../api/kinetica/autode/">autodE Interface</a></li></ul></li><li><a class="tocitem" href="../../api/kineticakpm/">KineticaKPM.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developing with Kinetica</a></li><li class="is-active"><a href>Calculator Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Calculator Interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Kinetica-jl/Kinetica.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Calculator-Interface"><a class="docs-heading-anchor" href="#Calculator-Interface">Calculator Interface</a><a id="Calculator-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Calculator-Interface" title="Permalink"></a></h1><p>For an introduction to Kinetica&#39;s kinetic calculators, which allow rate constant calculation under arbitrary experimental conditions of interest, see the tutorial on <a href="../../tutorials/kinetic-calculators/#Kinetic-Calculators">Kinetic Calculators</a>. This page details the underlying implementation of these calculators in order to facilitate extension and development of new calculators.</p><p>All kinetic calculators implemented in Kinetica and its modules follow the same basic interface. They should consist of:</p><ul><li>A (mutable) <code>struct</code> which holds all of the data that the calculator needs to calculate rate constants. This must be a subtype of <code>Kinetica.AbstractKineticCalculator</code>. Mutability is not a prerequisite, but is suggested as many calculators are designed to be updated further down the calculation chain.</li><li>An outer constructor which simplifies construction of the main struct, potentially offering optional arguments such as the ability to change the time unit the calculator works in. While not strictly necessary, this is recommended.</li><li>A method of the <a href="../../api/kinetica/solving/#Kinetica.setup_network!"><code>setup_network!</code></a> function which can be called with the calculator being implemented. This handled compatibility checking with the current CRN, as well as any additional calculation that needs to take place on a per-reaction basis (and therefore cannot be done during calculator construction).</li><li>A method of <a href="../../api/kinetica/solving/#Base.splice!-Union{Tuple{cType}, Tuple{cType, Vector{Int64}}} where cType&lt;:Kinetica.AbstractKineticCalculator"><code>splice!(calc::cType, rids::Vector{Int}) where cType&lt;:Kinetica.AbstractKineticCalculator</code></a> which can be called with the calculator being implemented. This enables data about unnecessary reactions to be deleted, mirroring the funcitonality of <a href="../../api/kinetica/exploration/#Base.splice!-Tuple{RxData, Vector{Int64}}"><code>splice!(::RxData, ::Vector{Int})</code></a> for deletion of reactions from the current CRN.</li><li>A method of <a href="../../api/kinetica/solving/#Kinetica.allows_continuous"><code>allows_continuous</code></a> for the calculator being implemented, which specifies if the calculator is allowed to be used in continuous rate update simulations (see <a href="../../tutorials/ode-solution/#ODE-Solution">ODE Solution</a>).</li><li>A method of <a href="../../api/kinetica/solving/#Kinetica.has_conditions"><code>has_conditions</code></a> for the calculator being implemented, which checks if the experimental conditions in the current kinetic simulation are compatible with the calculator.</li><li>Functors of the calculator being implemented which calculate the rate constant of every reaction in the current CRN at a given set of experimental conditions. These must accept the experimental conditions of interest as keyword arguments.</li></ul><p>As long as these are implemented, a new calculator will slot in seamlessly to Kinetica&#39;s arbitrary variable condition and CRN simulation frameworks.</p><h2 id="Implementation-Example"><a class="docs-heading-anchor" href="#Implementation-Example">Implementation Example</a><a id="Implementation-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-Example" title="Permalink"></a></h2><p>We will demonstrate the implementation of a new kinetic calculator with a somewhat contrived example that should nevertheless demonstrate all of the above points. This calculator will return rate constants that:</p><ul><li>Are dependent on temperature <code>:T</code> and pressure <code>:P</code> as experimental conditions,</li><li>Can be calculated with or without a maximum rate constant <code>k_max</code>,</li><li>Take a base rate constant <code>k_base</code> and multiply it by the ratio of products to reactants in a given reaction, under the formula</li></ul><p class="math-container">\[k_r = \frac{n_p}{n_r}k_{\text{base}} \exp\left[-\frac{P}{10T}\right]\]</p><p>where <span>$n_p$</span> is the number of product molecules in a given reaction, and <span>$n_r$</span> is the number of reactant molecules.</p><ul><li>Assuming the above equation yields rate constants in time units of <span>$s^{-1}$</span>, can be modified to work under other time units.</li></ul><p>This rate constant contains no physical meaning, but will illustrate all of the requirements of a kinetic calculator very well.</p><h3 id="Calculator-Struct"><a class="docs-heading-anchor" href="#Calculator-Struct">Calculator Struct</a><a id="Calculator-Struct-1"></a><a class="docs-heading-anchor-permalink" href="#Calculator-Struct" title="Permalink"></a></h3><p>First, we must create the main calculator struct, which will hold user-facing parameters such as <code>k_base</code> and <code>k_max</code> that are set at calculator construction and are not intended to be modified much down the line, as well as internal parameters such as <code>n_reacs</code> and <code>n_prods</code> which are reaction-specific and will be calculated later. Assuming we&#39;re naming this calculator <code>MyNewCalculator</code>, this can be done as follows:</p><pre><code class="language-julia hljs">using Kinetica

mutable struct MyNewCalculator{kmType, uType, tType} &lt;: Kinetica.AbstractKineticCalculator
    k_base::uType
    n_reacs::Vector{Int}
    n_prods::Vector{Int}
    k_max::kmType
    t_unit::String
    t_mult::tType
end</code></pre><p>Here we&#39;ve defined a <a href="https://docs.julialang.org/en/v1/manual/types/#Parametric-Types">Parametric Type</a>, which allows us to both specialise to the numeric types of species concentrations <code>uType</code> (assuming we represent <code>k_base</code> with the same numeric type as our species concentrations) and of simulation time <code>tType</code>, as well as allowing us to use multiple dispatch based on whether or not we have a <code>k_max</code> using <code>kmType</code> down the line. These parameters are not necessary to create a functioning calculator, but we include them here for consistency with how most of Kinetica&#39;s calculators are curently implemented.</p><h3 id="Outer-Constructor"><a class="docs-heading-anchor" href="#Outer-Constructor">Outer Constructor</a><a id="Outer-Constructor-1"></a><a class="docs-heading-anchor-permalink" href="#Outer-Constructor" title="Permalink"></a></h3><p>While it&#39;s nice to keep the information for both what our time unit is <code>t_unit</code> and what it does to our rates <code>t_mult</code> for reference, one quantity can be derived from the other and therefore both do not need to be provided to construct our calculator. We may also want to establish some sensible defaults for both <code>k_max</code> and <code>t_unit</code> to avoid having to input them every time we need to construct a calculator. Finally, we also don&#39;t need to provide values to CRN-specific fields such as <code>n_reacs</code> and <code>n_prods</code> at construction time. These features can be achieved by implementing an outer constructor:</p><pre><code class="language-julia hljs">function MyNewCalculator(k_base::uType; k_max::Union{uType, Nothing}=nothing,
                         t_unit=&quot;s&quot;) where {uType &lt;: AbstractFloat}

    t_mult = tconvert(t_unit, &quot;s&quot;)
    return MyNewCalculator(k_base, Int[], Int[], k_max, t_unit, t_mult)
end</code></pre><p>With this, we&#39;ve now created a default state so that when a user calls <code>calc = MyNewCalculator(k_base)</code>, the calculator creates empty arrays for <code>n_reacs</code> and <code>n_prods</code>, and automatically assumes there is no upper rate constant limit and we&#39;re working in rate units where time is measured in seconds. This instance of the calculator will be of type <code>MyNewCalculator{Nothing, uType, tType}</code>, allowing us to dispatch on a rate constant equation which excludes <code>k_max</code>. We&#39;ve also enforced that the type of <code>k_max</code> (when provided) must be the same as that of <code>k_base</code> by making this constructor a <a href="https://docs.julialang.org/en/v1/manual/methods/#Parametric-Methods">Parametric Method</a>, and that this type must be a subtype of <code>AbstractFloat</code>.</p><h3 id="Simulation-Setup"><a class="docs-heading-anchor" href="#Simulation-Setup">Simulation Setup</a><a id="Simulation-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-Setup" title="Permalink"></a></h3><p>So far we&#39;ve taken care of the parameters that are specific to a given instance of our calculator, but what about the parameters that are specific to a CRN being simulated? In the above outer constructor, we&#39;ve left <code>n_reacs</code> and <code>n_prods</code> (which represent the number of reactant and product molecules in each reaction) as empty integer arrays. We need these values to calculate our rate constants, so we&#39;ll need to populate these arrays within <a href="../../api/kinetica/solving/#Kinetica.setup_network!"><code>setup_network!</code></a>.</p><p><a href="../../api/kinetica/solving/#Kinetica.setup_network!"><code>setup_network!</code></a> is a function that is always called early in a kinetic simulation under <a href="../../api/kinetica/solving/#Kinetica.solve_network"><code>solve_network</code></a>. It takes the current CRN as a set of <a href="../../api/kinetica/exploration/#Kinetica.SpeciesData"><code>SpeciesData</code></a> and <a href="../../api/kinetica/exploration/#Kinetica.RxData"><code>RxData</code></a> objects, along with the given kinetic calculator, and modifies the internal state of the calculator to work with the CRN - in our example here, it will calculate and update <code>n_reacs</code> and <code>n_prods</code>:</p><pre><code class="language-julia hljs">function setup_network!(sd::SpeciesData, rd::RxData, calc::MyNewCalculator)
    n_reacs = zeros(Int, rd.nr)
    n_prods = zeros(Int, rd.nr)
    # Number of reactant/product molecules is the sum of the
    # reactant/product stoichiometries for each reaction.
    for i in 1:rd.nr
        n_reacs[i] = sum(rd.stoic_reacs[i])
        n_prods[i] = sum(rd.stoic_prods[i])
    end

    calc.n_reacs = n_reacs
    calc.n_prods = n_prods
    return
end</code></pre><div class="admonition is-warning" id="Fixed-Argument-Structure-628a635d2d8ef1d9"><header class="admonition-header">Fixed Argument Structure<a class="admonition-anchor" href="#Fixed-Argument-Structure-628a635d2d8ef1d9" title="Permalink"></a></header><div class="admonition-body"><p>As <a href="../../api/kinetica/solving/#Kinetica.setup_network!"><code>setup_network!</code></a> is intended to be called automatically as part of a chain of functions, it must always use the same call signature of <code>(sd, rd, calc)</code>, even when one or more of these arguments is unused, as <code>sd</code> is here. Similarly, even if no calculator setup is required, an empty method <strong>must</strong> be implemented here so that normal CRN simulation can proceed.</p></div></div><h3 id="Calculator-Splicing"><a class="docs-heading-anchor" href="#Calculator-Splicing">Calculator Splicing</a><a id="Calculator-Splicing-1"></a><a class="docs-heading-anchor-permalink" href="#Calculator-Splicing" title="Permalink"></a></h3><p>Sometimes, reactions are removed from CRNs as part of the kinetic simulation workflow (e.g. as part of a low-rate reaction cleanup, see <code>low_k_cutoff</code> in <a href="../../tutorials/ode-solution/#ODE-Solution">ODE Solution</a>). Since this occurs <strong>after</strong> the calculator setup done in <a href="../../api/kinetica/solving/#Kinetica.setup_network!"><code>setup_network!</code></a>, any reactions removed from a CRN&#39;s <a href="../../api/kinetica/exploration/#Kinetica.RxData"><code>RxData</code></a> through <a href="../../api/kinetica/exploration/#Base.splice!-Tuple{RxData, Vector{Int64}}"><code>splice!(::RxData, ::Vector{Int})</code></a> must similarly be removed from any reaction-specific fields in the calculator (in our case, <code>n_reacs</code> and <code>n_prods</code>). This is done through a custom method of <a href="../../api/kinetica/solving/#Base.splice!-Union{Tuple{cType}, Tuple{cType, Vector{Int64}}} where cType&lt;:Kinetica.AbstractKineticCalculator"><code>splice!(calc::cType, rids::Vector{Int}) where cType&lt;:Kinetica.AbstractKineticCalculator</code></a>:</p><pre><code class="language-julia hljs">function Base.splice!(calc::MyNewCalculator, rids::Vector{Int})
    # Splice the underlying reaction-specific arrays.
    splice!(calc.n_reacs, rids)
    splice!(calc.n_prods, rids)
    return
end</code></pre><div class="admonition is-warning" id="Required-Implementation-b38f8c3e0e267a4d"><header class="admonition-header">Required Implementation<a class="admonition-anchor" href="#Required-Implementation-b38f8c3e0e267a4d" title="Permalink"></a></header><div class="admonition-body"><p>As with <a href="../../api/kinetica/solving/#Kinetica.setup_network!"><code>setup_network!</code></a>, a method of <a href="../../api/kinetica/solving/#Base.splice!-Union{Tuple{cType}, Tuple{cType, Vector{Int64}}} where cType&lt;:Kinetica.AbstractKineticCalculator"><code>splice!(calc::cType, rids::Vector{Int}) where cType&lt;:Kinetica.AbstractKineticCalculator</code></a> <strong>must</strong> be implemented for every kinetic calculator, as it can be called as part of <a href="../../api/kinetica/solving/#Kinetica.solve_network"><code>solve_network</code></a>. </p></div></div><h3 id="Continuous-Rate-Tagging"><a class="docs-heading-anchor" href="#Continuous-Rate-Tagging">Continuous Rate Tagging</a><a id="Continuous-Rate-Tagging-1"></a><a class="docs-heading-anchor-permalink" href="#Continuous-Rate-Tagging" title="Permalink"></a></h3><p>Some calculators may have rate constant calculation functions that contain calls to external programs or are otherwise incompatible with representation as a <a href="https://github.com/JuliaSymbolics/Symbolics.jl">Symbolics.jl</a>-based expression through <a href="https://github.com/SciML/ModelingToolkit.jl">ModelingToolkit.jl</a>. These calculators are not compatible with the continuous rate update formalism and must be run through discrete rate update simulations instead (see <a href="../../tutorials/ode-solution/#ODE-Solution">ODE Solution</a> for details).</p><p>Kinetica prevents these calculators from being passed to an incompatible solution algorithm by checking the calculator&#39;s <a href="../../api/kinetica/solving/#Kinetica.allows_continuous"><code>allows_continuous</code></a> method. This simply returns a <code>Bool</code> stating whether the calculator should be allowed within continuous formalism simulaitons. In our example here, the rate constant function that we are going to implement can be represented in symbolic algebra by Symbolics, so we simply add:</p><pre><code class="language-julia hljs">allows_continuous(::MyNewCalculator) = true</code></pre><div class="admonition is-info" id="Which-rate-expressions-are-allowed?-d0c2d5e407d902f"><header class="admonition-header">Which rate expressions are allowed?<a class="admonition-anchor" href="#Which-rate-expressions-are-allowed?-d0c2d5e407d902f" title="Permalink"></a></header><div class="admonition-body"><p>If you&#39;re new to Symbolics or ModelingToolkit, it may be unclear which rate expressions are or are not compatible with the continuous formalism. In some cases this may require some trial and error, but in most, if you can write out the algebraic form of the rate expression by hand, it can be made to be compatible. If you need to use loops, this won&#39;t work (vectorised operations are okay though). Don&#39;t worry if your rate expression isn&#39;t compatible - the discrete rate update formalism is usually much quicker to compile, and sometimes it&#39;s quicker to solve too!</p></div></div><h3 id="Argument-Pre-Checking"><a class="docs-heading-anchor" href="#Argument-Pre-Checking">Argument Pre-Checking</a><a id="Argument-Pre-Checking-1"></a><a class="docs-heading-anchor-permalink" href="#Argument-Pre-Checking" title="Permalink"></a></h3><p>It&#39;s often useful to check far in advance if a kientic calculator is actually capable of working with the experimental conditions you&#39;re throwing at it. This is performed automatically by a method of <a href="../../api/kinetica/solving/#Kinetica.has_conditions"><code>has_conditions</code></a> when the calculator and the <a href="../../api/kinetica/conditions/#ConditionSet"><code>ConditionSet</code></a> first meet, in the inner constructor of <a href="../../api/kinetica/solving/#Kinetica.StaticODESolve"><code>StaticODESolve</code></a>/<a href="../../api/kinetica/solving/#Kinetica.VariableODESolve"><code>VariableODESolve</code></a>.</p><p>We must therefore implement such a method for our calculator, which lets Kinetica know which symbolic conditions are acceptable:</p><pre><code class="language-julia hljs">function has_conditions(::MyNewCalculator, symbols::Vector{Symbol})
    return all([sym in [:T, :P] for sym in symbols])
end</code></pre><p>This way, if we were to provide a <code>:V</code> condition in our <a href="../../api/kinetica/conditions/#ConditionSet"><code>ConditionSet</code></a> which our calculator wouldn&#39;t know what to do with, this would be caught early instead of causing problems deep into a difficult to diagnose <a href="../../api/kinetica/solving/#Kinetica.solve_network"><code>solve_network</code></a> call.</p><h3 id="Rate-Constant-Calculation"><a class="docs-heading-anchor" href="#Rate-Constant-Calculation">Rate Constant Calculation</a><a id="Rate-Constant-Calculation-1"></a><a class="docs-heading-anchor-permalink" href="#Rate-Constant-Calculation" title="Permalink"></a></h3><p>Finally, with the rest of the calculator out of the way, we can write our actual rate expressions. These are written as <a href="https://docs.julialang.org/en/v1/manual/methods/#Function-like-objects">functors</a> of our main calculator struct. Here, we will define two functors and allow Julia to dispatch to the correct one based on the type of calculator it receives. If the calculator&#39;s <code>kmType</code> is the same as its <code>uType</code>, we know that a value was provided for <code>k_max</code> and we need to dispatch on a modified version of the rate expression. Otherwise, if <code>kmType</code> is <code>Nothing</code>, we know there&#39;s no <code>k_max</code> and we can dispatch on the normal rate expression:</p><pre><code class="language-julia hljs"># Dispatching without k_max awareness.
function (calc::MyNewCalculator{Nothing, uType, tType})(; T::Number, P::Number) where {uType, tType}
    k_r = (calc.n_prods ./ calc.n_reacs) .* calc.k_base * exp(-P/(10*T)) * calc.t_mult
    return k_r
end

# Dispatching with k_max awareness.
function (calc::MyNewCalculator{uType, uType, tType})(; T::Number, P::Number) where {uType, tType}
    k_r = (calc.n_prods ./ calc.n_reacs) .* calc.k_base * exp(-P/(10*T)) * calc.t_mult
    return 1.0 ./ ((1.0 / calc.k_max) .+ (1.0 ./ k_r))
end</code></pre><p>Vitally important here are:</p><ul><li>Experimental conditions must be passed in as <strong>keyword arguments</strong>, as Kinetica splats an array of <code>Pair</code>s of condition <code>Symbol</code>s and their values (static parameters or variable expressions) into the calculator internally to enable arbirtary conditions to be passed to arbitrary calculators. This is accomplished by indicating that there are no positional arguments with a semicolon before listing the conditions.</li><li>Calculator functors return rate constants for <strong>all</strong> reactions in a CRN simultaneously, so rate constant expressions typically make use of vectorised operations to make neat one-liners like those above.</li></ul><h3 id="Checking-Our-Work"><a class="docs-heading-anchor" href="#Checking-Our-Work">Checking Our Work</a><a id="Checking-Our-Work-1"></a><a class="docs-heading-anchor-permalink" href="#Checking-Our-Work" title="Permalink"></a></h3><p>That&#39;s it! Now we have everything implemented for a working (albeit non-physical and mostly useless) kinetic calculator. We can make sure it works by running all the above functions on a small CRN. We&#39;ll use the CRN that was created for <a href="../../getting-started/#Getting-Started">Getting Started</a>:</p><pre><code class="language-julia hljs">res = load_output(&quot;../my_CRN_out/direct_network_final.bson&quot;)
sd, rd = res.sd, res.rd

# Test added methods.
calc = MyNewCalculator(2e5)
println(&quot;Calculator allows continuous formalism: $(allows_continuous(calc))&quot;)
println(&quot;Calculator accepts conditions Z, P, V: $(has_conditions(calc, [:Z, :P, :V]))&quot;)
println(&quot;Calculator accepts conditions T, P: $(has_conditions(calc, [:T, :P]))&quot;)
setup_network!(sd, rd, calc)
@assert length(calc.n_reacs) == length(calc.n_prods) == rd.nr
println(&quot;Pre-splice calculator contains info on $(rd.nr) reactions&quot;)
splice!(rd, calc, collect(1:5)) # Remove first 5 reactions from rd and calc
@assert length(calc.n_reacs) == length(calc.n_prods) == rd.nr
println(&quot;Post-splice calculator contains info on $(rd.nr) reactions&quot;)

# Default calculator implementation.
calc = MyNewCalculator(2e5)
setup_network!(sd, rd, calc)
k_default = calc(; T=1000.0, P=1e5)

# Calculator with rate constants capped to 10 s-1
calc = MyNewCalculator(2e5; k_max=10.0)
setup_network!(sd, rd, calc)
k_capped = calc(; T=1000.0, P=1e5)

# Compare default and capped rate constants.
using Printf
println(&quot;\nRID  k_default  k_capped&quot;)
for i in 1:rd.nr
    println(&quot;$(rpad(string(i), 3, &#39; &#39;))  $(@sprintf(&quot;%.9f&quot;, k_default[i]))  $(@sprintf(&quot;%.9f&quot;, k_capped[i]))&quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Calculator allows continuous formalism: true
Calculator accepts conditions Z, P, V: false
Calculator accepts conditions T, P: true
Pre-splice calculator contains info on 30 reactions
Post-splice calculator contains info on 25 reactions

RID  k_default  k_capped
1    4.539992976  3.122417586
2    18.159971905  6.448860093
3    4.539992976  3.122417586
4    4.539992976  3.122417586
5    4.539992976  3.122417586
6    18.159971905  6.448860093
7    18.159971905  6.448860093
8    18.159971905  6.448860093
9    4.539992976  3.122417586
10   9.079985952  4.758905995
11   9.079985952  4.758905995
12   4.539992976  3.122417586
13   9.079985952  4.758905995
14   18.159971905  6.448860093
15   18.159971905  6.448860093
16   9.079985952  4.758905995
17   4.539992976  3.122417586
18   18.159971905  6.448860093
19   4.539992976  3.122417586
20   9.079985952  4.758905995
21   9.079985952  4.758905995
22   4.539992976  3.122417586
23   18.159971905  6.448860093
24   18.159971905  6.448860093
25   4.539992976  3.122417586</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../condition-profiles/">« Condition Profiles</a><a class="docs-footer-nextpage" href="../ase-calculator-builders/">ASE Calculator Builders »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Wednesday 4 June 2025 02:08">Wednesday 4 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
