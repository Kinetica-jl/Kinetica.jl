var documenterSearchIndex = {"docs":
[{"location":"development/condition-profiles/#Condition-Profiles","page":"Condition Profiles","title":"Condition Profiles","text":"","category":"section"},{"location":"tutorials/logging/#Logging","page":"Logging","title":"Logging","text":"","category":"section"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"Kinetica makes use of multiple logging functions from the JuliaLogging organisation to handle writing logs of varying detail levels to the console and to file, as well as to handle various optional progress bars for tracking ODE solution progress.","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"By default, running Kinetica functions such as explore_network will output a text stream containing important information about the task at hand to stdout. An example of this can be seen in the 'Running the Simulation' section of Getting Started. This will always log at the Info level, so detailed debugging messages will not be present.","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"To log to a file and/or enable Debug-level logging, Kinetica provides a shorthand function for setting up the correct logger, start_log:","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"using Logging: with_logger, Debug, Info\nlogger = start_log(\"./\"; min_level=Info, label=\"MyLog\")","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"This creates a nicely formatted logger of the requested level at the path ./MyLog_yymmdd-HHMMSS.log, inserting the date and time of creation into the yymmdd and HHMMSS fields respectively. If debug logging is required, min_level=Debug should be set instead.","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"To use this logger on a set of expressions, correctly formatting log messages and sending them to the requested log file, it needs to wrap the expressions in a with_logger function:","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"with_logger(logger) do\n    global res = explore_network(exploremethod, solvemethod, \"./my_CRN_out\")\nend","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"Note the use of the global keyword here - if this is a top-level script, the with_logger function will create a new scope that contains the variable res, which will be lost to the global (script-level) scope once it is exited. By making this variable global, it ensures we don't lose simulation results while logging!","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"Once you've finished logging within a script, call end_log to safely close the log file:","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"end_log(logger)","category":"page"},{"location":"tutorials/logging/#Progress-Bars","page":"Logging","title":"Progress Bars","text":"","category":"section"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"When solving ODEs, Kinetica can both make use of DifferentialEquations.jls native progress bar implementation and set up its own, depending on the solve type requested. Both depend on TerminalLoggers.jl in the background, but if we were to wrap a progress bar into a text log, we'd get a bit of a mess!","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"Kinetica works around this by always passing progress bars within ODE solution calls to the global logger. While the logger variable we defined above is a local logger that needs to be called within a with_logger wrapper, the global logger is specified over the entire session and can be accessed from anywhere in the code. It is therefore enough to define the global logger at the start of a Kinetica script, and the solvers will handle the rest. As in DifferentialEquations.jl, this is done by specifying the following:","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"using Logging: global_logger\nusing TerminalLoggers: TerminalLogger\nglobal_logger(TerminalLogger())","category":"page"},{"location":"tutorials/logging/","page":"Logging","title":"Logging","text":"To enable progress bars during ODE solution, the progress parameter of ODESimulationParams needs to be set to true.","category":"page"},{"location":"api/kinetica/exploration/#Kinetica.jl-API","page":"Exploration","title":"Kinetica.jl API","text":"","category":"section"},{"location":"api/kinetica/exploration/#CRN-Representation","page":"Exploration","title":"CRN Representation","text":"","category":"section"},{"location":"api/kinetica/exploration/#Representing-Chemical-Species","page":"Exploration","title":"Representing Chemical Species","text":"","category":"section"},{"location":"api/kinetica/exploration/","page":"Exploration","title":"Exploration","text":"SpeciesData\nBase.push!(::SpeciesData, ::String, ::Dict{String, Any})\nBase.push!(::SpeciesData, ::Vector{String}, ::Vector{Any})\nBase.push!(::SpeciesData, ::String)\npush_unique!","category":"page"},{"location":"api/kinetica/exploration/#Kinetica.SpeciesData","page":"Exploration","title":"Kinetica.SpeciesData","text":"Bidirectional String-Int dictionary for chemical species.\n\nContains fields for:\n\nSMILES string -> integer ID dictionary (toInt)\nInteger ID -> SMILES string dictionary (toStr)\nNumber of species (n)\nExtXYZ structures of species (xyz)\nDictionary of per-species cached values (cache)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/exploration/#Base.push!-Tuple{SpeciesData, String, Dict{String, Any}}","page":"Exploration","title":"Base.push!","text":"push!(sd, smi, xyz)\n\nAdd a species to SpeciesData.\n\nDoes not account for smi already existing within sd. To ensure no overlap, use push_unique!.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/exploration/#Base.push!-Tuple{SpeciesData, Vector{String}, Vector{Any}}","page":"Exploration","title":"Base.push!","text":"push!(sd, smis, xyzs)\n\nAdd an array of species to SpeciesData.\n\nDoes not account for smi already existing within sd. To ensure no overlap, use push_unique!.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/exploration/#Base.push!-Tuple{SpeciesData, String}","page":"Exploration","title":"Base.push!","text":"push!(sd, xyz_file[, fix_radicals])\n\nAdd all species in xyz_file to sd.\n\nDoes not account for smi already existing within sd. To ensure no overlap, use push_unique!.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/exploration/#Kinetica.push_unique!","page":"Exploration","title":"Kinetica.push_unique!","text":"push_unique!(sd, smi, xyz)\n\nAdd a species SMILES to a SpeciesData, as long as it does not already exist there.\n\n\n\n\n\npush_unique!(sd, xyz_file[, fix_radicals])\n\nAdd species in xyz_file to sd, as long as they do not already exist there.\n\n\n\n\n\npush_unique!(sd, smis, xyzs)\n\nAdd an array of species to SpeciesData, as long as each does not already exist there.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Representing-Reactions","page":"Exploration","title":"Representing Reactions","text":"","category":"section"},{"location":"api/kinetica/exploration/","page":"Exploration","title":"Exploration","text":"RxData\nBase.push!(::RxData{iType, fType}, ::SpeciesData, ::Vector{Vector{String}}, ::Vector{Vector{String}}, ::Vector{Dict{String, Any}}, ::Vector{Dict{String, Any}}, ::Vector{fType}) where {iType, fType <: AbstractFloat}\nBase.splice!(::RxData, ::Vector{Int})","category":"page"},{"location":"api/kinetica/exploration/#Kinetica.RxData","page":"Exploration","title":"Kinetica.RxData","text":"Data container for reactions.\n\nShould be constructed alongside a SpeciesData for mapping species IDs to SMILES strings.\n\nContains fields for:\n\nNumber of reactions encountered (nr)\nAtom-mapped reaction SMILES for unambiguous linking of atom indices in reactants and products (mapped_rxns)\nUnique IDs of reactants for each reaction (id_reacs)\nUnique IDs of products for each reaction (id_prods)\nStoichiometries of reactants for each reaction (stoic_reacs)\nStoichiometries of products for each reaction (stoic_prods)\nReaction enthalpies (dH)\nReaction hashes, used for unique identification (rhash)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/exploration/#Base.push!-Union{Tuple{fType}, Tuple{iType}, Tuple{RxData{iType, fType}, SpeciesData, Vector{Vector{String}}, Vector{Vector{String}}, Vector{Dict{String, Any}}, Vector{Dict{String, Any}}, Vector{fType}}} where {iType, fType<:AbstractFloat}","page":"Exploration","title":"Base.push!","text":"push!(rd, sd, reacs, prods, rsys, psys, dH[, unique_rxns, max_molecularity])\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/exploration/#Base.splice!-Tuple{RxData, Vector{Int64}}","page":"Exploration","title":"Base.splice!","text":"splice!(rd, rids)\n\nRemoves reactions at indeces rids from rd.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/exploration/#CRN-Initialisation","page":"Exploration","title":"CRN Initialisation","text":"","category":"section"},{"location":"api/kinetica/exploration/","page":"Exploration","title":"Exploration","text":"init_network","category":"page"},{"location":"api/kinetica/exploration/#Kinetica.init_network","page":"Exploration","title":"Kinetica.init_network","text":"sd, rd = init_network([iType, fType])\n\nInitialises an empty reaction network.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#CDE-Interface","page":"Exploration","title":"CDE Interface","text":"","category":"section"},{"location":"api/kinetica/exploration/","page":"Exploration","title":"Exploration","text":"CDE\nKinetica.ingest_cde_run","category":"page"},{"location":"api/kinetica/exploration/#Kinetica.CDE","page":"Exploration","title":"Kinetica.CDE","text":"cde = CDE(rdir, template_dir, init_xyz, env[, sampling_seed, radius])\n\nCDE runner. Initialised through struct, run through functor.\n\nStruct contains fields for:\n\nCDE template directory (template_dir)\nEnvironmental multithreading number of threads (Optional, defaults to 1 thread; env_threads)\nPath to CDE executable (Optional, defaults to CDE packaged within CDEjll; `cdeexec`)\nSeed for CDE's RNG (Optional, setting to 0 indicates seed should be random; sampling_seed)\nRadius for exploration of breakdown space (Optional, Default = 50; radius)\nNumber of mechanisms to generate within a single CDE run (Optional, Default = 1; nrxn)\nNumber of parallel CDE runs to execute (Optional, Default = 1; parallel_runs)\nMaximum number of parallel CDE executables to run at any time (Optional, Default = 1; parallel_exes)\nWhether to write CDE's stdout to file (Optional, Default = false; write_stdout)\nWhether to write CDE's stderr to file (Optional, Default = false; write_stderr)\nWhether to allow functions to continue running if CDE errors are detected (Optional, Default = false; allow_errors)\n\nAdditionally, some fields are usually modified within Kinetica, and are not intended to be changed by users.\n\nMain reaction directory (rdir)\nXYZ file of starting molecule/material (init_xyz)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/exploration/#Kinetica.ingest_cde_run","page":"Exploration","title":"Kinetica.ingest_cde_run","text":"reac_smis, reac_xyzs, reac_systems, prod_smis, prod_xyzs, prod_systems, dH = ingest_cde_run(rdir, rcount[, fix_radicals])\n\nReads in the results from a CDE run.\n\nSeparates out fragment species from each available reaction's reactants and products, forming arrays of their SMILES strings and ExtXYZ geometries.\n\nOBCanonicalRadicals can be enabled to tidy up radical SMILES using the fix_radicals parameter.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Exploration","page":"Exploration","title":"Exploration","text":"","category":"section"},{"location":"api/kinetica/exploration/","page":"Exploration","title":"Exploration","text":"DirectExplore\nIterativeExplore\nexplore_network","category":"page"},{"location":"api/kinetica/exploration/#Kinetica.DirectExplore","page":"Exploration","title":"Kinetica.DirectExplore","text":"Container for parameters used in direct CRN exploration.\n\nContains fields for:\n\nTop level of CRN exploration directory (rdir_head)\nSMILES string(s) of main breakdown reactant(s) being studied (reac_smiles)\nCDE instance (cde)\nMaximum number of iterations to perform (maxiters)\nNumber of iterations with no change in reactions to consider as converged (rxn_convergence_threshold)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/exploration/#Kinetica.IterativeExplore","page":"Exploration","title":"Kinetica.IterativeExplore","text":"Container for parameters used in iterative kinetics-based CRN exploration.\n\nContains fields for:\n\nTop level of CRN exploration directory (rdir_head)\nSMILES string(s) of main breakdown reactant(s) being studied (reac_smiles)\nCDE instance (cde)\nMaximum number of iterations to perform (maxiters)\nNumber of subspace iterations with no change in reactions to consider a subspace converged (rxn_convergence_threshold)\nNumber of level iterations with no change in seeds to consider the network converged (seed_convergence_threshold)\nConcentration above which species will be selected as seeds each level (seed_conc)\nBlacklist of species to avoid doing independent subspace explorations on (independent_blacklist)\nInert species that should not be considered for reaction (inert_species)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/exploration/#Kinetica.explore_network","page":"Exploration","title":"Kinetica.explore_network","text":"res = explore_network(exploremethod::Union{DirectExplore, IterativeExplore}, solvemethod[, savedir])\n\nRuns network exploration with one of the available methods.\n\nIf exploremethod isa DirectExplore, runs a single-level network exploration to attempt to locate all relevant reactions in a radius of exploremethod.cde.radius species from the starting system.\n\nIf exploremethod isa IterativeExplore, runs a multi-level iterative network exploration using kinetic simulations to identify seed species for successive levels, in order to fully characterise the reaction space relevant to the conditions in solvemethod.conditions.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Molecule-System","page":"Exploration","title":"Molecule System","text":"","category":"section"},{"location":"api/kinetica/exploration/","page":"Exploration","title":"Exploration","text":"system_from_smiles\nsystem_from_mols\nKinetica.molsys_opt","category":"page"},{"location":"api/kinetica/exploration/#Kinetica.system_from_smiles","page":"Exploration","title":"Kinetica.system_from_smiles","text":"system_from_smiles(smiles[, saveto, dmin])\n\nForms a single XYZ system out of the molecules in smiles.\n\nUseful for making unified molecular systems with no overlap for feeding into CDE. dmin represents the minimum  molecule-molecule distance that should be allowed.\n\nIf the argument saveto is provided, outputs the optimised system to a file at this path. If not, returns the optimised system as a single ExtXYZ dict.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Kinetica.system_from_mols","page":"Exploration","title":"Kinetica.system_from_mols","text":"\n\n\n\n","category":"function"},{"location":"api/kinetica/exploration/#Kinetica.molsys_opt","page":"Exploration","title":"Kinetica.molsys_opt","text":"tmols = molsys_opt(mols, dmin, maxiters)\n\nOptimises positions of molecules in mols to ensure they are all at least dmin Angstroms apart.\n\nCreates and solves an N-body spring-driven particle system and transforms molecular coordinates to these particles to check for proximity.\n\n\n\n\n\n","category":"function"},{"location":"development/crn-representation/#crn_representation_page","page":"CRN Representation","title":"CRN Representation","text":"","category":"section"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"note: In Progress\nThis page is still under construction. Check back later!","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"When adding new reactions to a CRN, Kinetica performs a few checks. Reactions are discarded if they:","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"Only contain conformational changes. Species are internally represented by SMILES, so any changes not representable by SMILES (e.g. single bond rotations) lead to species being classed as the same. Note that E/Z isomers and enantiomers are distinct from one another in SMILES.\nExceed the maximum molecularity. By default this is 2, so only unimolecular and bimolecular reactions are allowed to enter a CRN. This is controllable by the max_molecularity argument when constructing or pushing to RxData.\nAlready exist in the RxData they are being added to. This is checked by comparing a reaction's unique hash to those currently in the CRN.","category":"page"},{"location":"development/crn-representation/","page":"CRN Representation","title":"CRN Representation","text":"<!– Need to mention how reverse reactions are automatically added during CDE ingest somewhere. –>","category":"page"},{"location":"tutorials/saving-loading/#Saving-and-Loading","page":"Saving & Loading","title":"Saving & Loading","text":"","category":"section"},{"location":"api/kinetica/analysis/#Kinetica.jl-API","page":"Analysis","title":"Kinetica.jl API","text":"","category":"section"},{"location":"api/kinetica/analysis/#Analysis","page":"Analysis","title":"Analysis","text":"","category":"section"},{"location":"api/kinetica/analysis/","page":"Analysis","title":"Analysis","text":"ODESolveOutput","category":"page"},{"location":"api/kinetica/analysis/#Kinetica.ODESolveOutput","page":"Analysis","title":"Kinetica.ODESolveOutput","text":"Data container for output of network ODE solutions.\n\nBinds together all data required for analysis of network ODE solution results. Used as an input for many of the automated plotting functions in KineticaCore.\n\nAlso used for results IO, can be completely deconstructed into a package-independent dictionary tree for saving as binary JSON (BSON) with save_output. Can be reconstructed from such a BSON file with load_output.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Here we will demonstrate how to perform a simple CRN exploration using Kinetica. Simulations within Kinetica are designed to be run as a script, consisting of the following elements:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Parameter blocks,\nSimulation,\nAnalysis.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"We will begin by going through a basic example of each of these elements. Further details can be found in the Tutorials section of this documentation. ","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If you are attempting to recreate this tutorial for yourself, it relies on a few input files that are separate to any of the main code repositories. These files can be found in the examples directory of this documentation's repository, which can be accessed by cloning this repository:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"git clone https://github.com/Kinetica-jl/KineticaDocs.jl.git\ncd KineticaDocs.jl/examples","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"To start with the tutorial, load the main Kinetica.jl package:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using Kinetica","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"We'll also set a seed for Julia's random number generation, to ensure that this tutorial is fully reproducible. This can be ignored in regular use, but is useful here if you want to compare your results to those obtained here.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using Random\nRandom.seed!(12345)\nnothing # hide","category":"page"},{"location":"getting-started/#Parameter-Blocks","page":"Getting Started","title":"Parameter Blocks","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The initial part of Kinetica simulation scripts usually consist of 3-4 blocks of parameters, depending on whether or not the simulation consists of only a kinetic calculation on a pre-existing CRN or if it also requires a CRN exploration before such a calculation can take place.","category":"page"},{"location":"getting-started/#Simulation-Conditions","page":"Getting Started","title":"Simulation Conditions","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The first parameter block should be a ConditionSet, which defines the experimental conditions a kinetic calculation should take place under. This block is usually defined first as later parameters often depend on it.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"ConditionSet blocks allow for flexible definitions of any number of arbitrary conditions, each of which can be static (constant) or variable (time-dependent). For this simple CRN exploration, we will define a ConditionSet that specifies a linear temperature increase, from 300 K at time t = 0.0 to 1000 K at a rate of 50 K/s. Kinetica comes with a library of variable condition profiles, allowing this ConditionSet to be simply defined as follows:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"conditions = ConditionSet(Dict(\n    :T => LinearGradientProfile(;\n        rate = 50.0,\n        X_start = 500.0,\n        X_end = 1200.0\n    )\n))","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This generates a LinearDirectProfile for the linear temperature increase we are interested in, and binds it to the symbol :T for use within kinetic calculators. Further information on the types of condition profiles implemented in Kinetica can be found in the tutorial on Arbitrary Simulation Conditions.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"We will be able to visualise this condition profile shortly, but we must first define a parameter block of ODE solution parameters.","category":"page"},{"location":"getting-started/#Kinetic-Simulation-Parameters","page":"Getting Started","title":"Kinetic Simulation Parameters","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The ODESimulationParams block defines all of the parameters needed when converting a CRN to a system of ODEs and integrating it in time. This includes parameters such as the simulation timespan, initial concentrations of reactants and the ODE solver being used.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For the purposes of this tutorial, we will construct the following ODESimulationParams block:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using OrdinaryDiffEq\nusing Sundials\n\npars = ODESimulationParams(\n    tspan = (0.0, get_t_final(conditions)),\n    u0 = Dict(\"C\" => 1.0),\n    solver = CVODE_BDF(; linear_solver=:KLU)\n)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This block details the three essential parameters for any simulation in Kinetica:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"tspan: Simulation timespan (in seconds, unless otherwise specified within kinetic calculator). Must be a tuple of (start_time, end_time). Here, we fetch the end time directly from the ConditionSet defined above using get_t_final(conditions), which calculates the time at which all defined conditions have reached their final state.\nu0: Dictionary of initial concentrations. Here we define that kinetic simulations should start with 1.0 mol dm^-3 of methane (C in SMILES notation), and no other reactants.\nsolver: ODE solution algorithm to use, from those available in DifferentialEquations.jl. Here we load in the CVODE_BDF solver from the Sundials.jl library, as this has been the best general-purpose solver in our testing. The KLU linear solver allows this ODE solver to work with sparse arrays, which are enabled by default.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Further details of the parameters available in this block can be found in the ODE Solution section.","category":"page"},{"location":"getting-started/#CRN-Exploration-Parameters","page":"Getting Started","title":"CRN Exploration Parameters","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"In order to perform a CRN exploration, an exploration method must be chosen. Kinetica currently provides two: DirectExplore and IterativeExplore. For now we will use the former, as it is simpler.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"DirectExplore explores all chemical reactions within a given radius of the starting reactants, irrespective of whether or not they will occur within a later kinetic simulation under the selected environmental conditions. This method is best suited to small CRNs under kinetically slow conditions, where few reactions are possible and complete sampling of all available reactions is easy.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Reactions are sampled using CDE, an external code for graph-droven sampling of reactions that is included with Kinetica.jl. CDE has its own parameters which must be set, but these are usually very similar for most CRN explorations. As such, a directory of template inputs must be provided for CDE to function. We provide such a template directory with this documentation, which can be used to run this tutorial. If you have cloned this documentation's repository, as suggested at the start of this tutorial, these files are in KineticaDocs.jl/examples/cde_template.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Once this is done, the exploration parameters can be set up as follows:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"crn_dir = \"./my_CRN\"\n\nexploremethod = DirectExplore(\n    rdir_head = crn_dir,\n    reac_smiles = [\"C\"],\n    rxn_convergence_threshold = 5,\n    cde = CDE(\n        template_dir = \"../../examples/cde_template\",\n        radius = 5,\n        sampling_seed = 1\n    )\n)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The parameters defined in this block are as follows:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"rdir_head : This is the directory in which the raw CRN exploration files will be stored. We have defined crn_dir above because it will be useful to reference later. ","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"warning: I/O intensity\nMany CDE runs can be quite I/O-heavy, so it is useful to place this directory on a fast, directly-attached drive. Running the CRN exploration out of a network-attached spinning hard drive will probably be a bad time.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"reac_smiles: Array of SMILES strings representing reactants in the initial reactant system. These will be fed to CDE to generate reactions. In this case, we will generate all reactions that can occur between two methane molecules.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"note: The Iterative method works differently!\nWatch out for the meaning of these parameters changing slightly between DirectExplore and IterativeExplore. They can serve the same purpose, but methodologically do different things under the hood. See the tutorial on Iterative CRN Exploration for more information.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"rxn_convergence_threshold: How many CDE iterations to perform with no new reactions discovered before considering the CRN converged.\ncde: CDE parameter block using the example input templates (change this path to the directory you saved yours into). This defines a reactive radius of 5, meaning that all reactions within 5 steps of the reactant system will be generated. The sampling_seed parameter is usually not set, but we will set it here to make this tutorial reproducible. More information on this sub-block is also given in the Iterative CRN Exploration tutorial.","category":"page"},{"location":"getting-started/#Kinetic-Calculator","page":"Getting Started","title":"Kinetic Calculator","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The final parameter block to set up is the simulation's kinetic calculator. This is an object capable of calculating rate constants for every reaction in a CRN under a given set of conditions. Kinetic calculators are one of the core points of modularity in Kinetica, with extension packages like KineticaKPM.jl extending the functionality of the main code by adding in more calculators for different requirements.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The main Kinetica.jl package only includes one kinetic calculator, the PrecalculatedArrheniusCalculator. This calculator calculates temperature-dependent rate constants using the Arrhenius equation:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"k = Ae^-dfracE_aRT","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The PrecalculatedArrheniusCalculator requires vectors of Arrhenius prefactors A and activation energies Ea for all reactions before the code is executed, and as such is typically only used when a CRN has been generated and these values have been determined outside Kinetica. However, for the purposes of this tutorial (where the random seed for CDE's reaction generation has been set, see above), we know the reactions that are going to be generated in advance, so we have provided approximate values to input into this calculator. These values are in KineticaDocs.jl/examples/getting_started/arrhenius_params.bson, and can be loaded in with:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using BSON\ncalc_pars = BSON.load(\"../../examples/getting_started/arrhenius_params.bson\")","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"again, replacing this path with the equivalent path on your computer. The calculator for this CRN can now be constructed:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"calc = PrecalculatedArrheniusCalculator(calc_pars[:Ea], calc_pars[:A]; k_max=1e12)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For more advanced calculators that allow on-the-fly calculation of rate constants as reactions are generated, see the tutorial on Kinetic Calculators.","category":"page"},{"location":"getting-started/#Simulation","page":"Getting Started","title":"Simulation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Now that all of the parameter blocks have been constructed, we can start generating and simulating CRNs!","category":"page"},{"location":"getting-started/#Visualising-Condition-Profiles","page":"Getting Started","title":"Visualising Condition Profiles","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"First, now that we have both a ConditionSet and a ODESimulationParams block, we can have a look at the variable temperature profile that we created. To begin, we need to construct a DifferentialEquations ODESolution for this profile. Kinetica provides a shortcut for this, with a one-liner that constructs ODEProblems and solves them for every variable condition in a ConditionSet:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"solve_variable_conditions!(conditions, pars)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"note: Not neccessary in regular use!\nWe are manually triggering the solution of the ConditionSet here to visualise how the constructed temperature profile will look in the final simulation. However, calling solve_variable_conditions! as above is not neccessary in all Kinetica scripts. This function is normally run automatically before integrating the CRN ODEs, and does not typically need to be called like this.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"With this in place, we can now plot our temperature profile's ODESolution to see how the simulation temperature is going to vary with time:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"mkpath(\"assets/getting-started\") # hide\nusing Plots\nplot(get_profile(conditions, :T).sol)\nsavefig(\"assets/getting-started/Tprofile.svg\"); nothing # hide","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"As expected, the temperature profile we constructed goes from 300 K to 1000 K at a rate of 50 K/s. Provided we are happy with this, we can continue to perform a CRN exploration and a kinetic simulation.","category":"page"},{"location":"getting-started/#Running-the-Simulation","page":"Getting Started","title":"Running the Simulation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"CRN exploration and kinetic simulation are wrapped under a single function call: explore_network. This takes the exploration parameters, the simulation parameters and calculator (which we will wrap under a single variable), and optionally a directory to save the finished results to. These results will additionally be returned by the function. To run the entire simulation, we simply call the following:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"solvemethod = VariableODESolve(pars, conditions, calc)\nmkdir(\"./my_CRN_out\") # hide\nres = explore_network(exploremethod, solvemethod, \"./my_CRN_out\")\nnothing # hide","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"note: Checkpoints and Restarts\nIn the event that a Kinetica CRN exploration fails before completion, all is not lost! As long as you still have the original head directory that the CRN was being explored in (crn_dir in this tutorial), both of Kinetica's exploration algorithms will detect where you left off and restart from there seamlessly. In the iterative exploration algorithm, Kinetica also creates checkpoint files with current CRN state and kinetic simulation results. We'll cover this in detail in the tutorial on Saving & Loading.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The resulting ODESolveOutput object contains the explored CRN, the kinetic simulation results, and all of the parameters and conditions that went into it. These can be easily and efficiently saved and loaded as needed (see Saving & Loading).","category":"page"},{"location":"getting-started/#Analysis","page":"Getting Started","title":"Analysis","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The ODESolveOutput object has plot recipes defined for easy plotting using Plots.jl, allowing complex figures and statistics to be shown with a single line of code. To begin, we can look at how the concentrations of all of the species found during CRN generation vary over time under the variable temperature profile we specified. This is achieved by simply running","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"plot(res)\nsavefig(\"assets/getting-started/kinetics_plot.svg\"); nothing # hide","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This CRN presents some interesting results! Accoding to the kinetics enforced by the calculator we have used, methane will not start breaking down into any of the free radical species discovered within this CRN until t approx 5 text s. We could check the temperature that this occurs at by referencing the temperature profile we plotted abovem but this is also accessible from res by running","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"conditionsplot(res, :T)\nsavefig(\"assets/getting-started/Tprofile_2.svg\"); nothing # hide","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Notice how, because we used the conditionsplot() function, the correct symbolically-indexed condition profile was obtained and axis labels were set accordingly.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If we want to obtain the numeric value of the temperature at t approx 5 text s, we can interpolate this directly:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Tprofile = get_profile(res.conditions, :T)\nTprofile.sol(5.0)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If we had multiple variable condition profiles, the above could also be done for them by simply passing in their bound symbols.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Similarly, we can also obtain the concentrations of all of the species in the reaction mixture at any time in the simulation through interpolation:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"res.sol(5.0)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"It is also very useful to analyse the final concentrations of species at the end of a kinetic simulation. Kinetica defines another plot recipe for this:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"finalconcplot(res)\nsavefig(\"assets/getting-started/concs_plot.svg\"); nothing # hide","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"getting-started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Now you're familiar with the basics of network exploration and kinetic simulation within Kinetica, you can learn more by looking through the other tutorials! ","category":"page"},{"location":"development/calculator-interface/#Calculator-Interface","page":"Calculator Interface","title":"Calculator Interface","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/#Kinetic-Calculators","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"Kinetica allows for any and all rate constant expressions to be used within kinetic simulations through its modular kinetic calculator interface. This allows users and developers alike to quickly define a set of functions which are dependent on a CRN (through a SpeciesData and an RxData) and some arbitrary experimental conditions which the simulation takes place under, such as temperature and pressure, and to calculate rate constants. For more information on how kinetic calculators are implemented, see Calculator Interface.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"Kinetica features a single base calculator, the PrecalculatedArrheniusCalculator. This calculator relies on having Arrhenius prefactors and activation energies precalculated for every reaction in a CRN, and serves mostly as a test calculator and an implementation example. ","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"Other more useful calculators are provided as modular addon packages that extend Kinetica.jl (e.g. KineticaKPM.jl). Some calculators have extensive dependencies, so this modularisation allows for picking and choosing only the calculators required for a specific project rather than having every available calculator in one bloated Julia/Python environment.","category":"page"},{"location":"tutorials/kinetic-calculators/#Manually-Calling-Calculators","page":"Kinetic Calculators","title":"Manually Calling Calculators","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"The examples below all show how calculators can be manually called to calculate rate constants. This is useful when these values are required, e.g. for analysis, but is not required during kinetic simulations. Passing a calculator into explore_network or solve_network via a VariableODESolve struct (see the 'Running the Simulation' section of Getting Started) is enough to set up the calculator and evaluate rate constants as many times as is required by the simulation.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"In the event that a calculator is required to be called manually, the process is very simple. Once the calculator has been instantiated, it should be passed to its setup_network! function. All kinetic calculators implement such a function, which checks the values provided to the calculator are compatible with a given SpeciesData and RxData and does any necessary pre-calculation such that the calculator can perform the minimum computation when rate constants are requested. Once setup, the calculator object can be called as a functor with its implemented experimental conditions as keyword arguments to evaluate the rate constants of all reactions in the given CRN at the provided values of the conditions. Examples of this process can be found below.","category":"page"},{"location":"tutorials/kinetic-calculators/#Calculator-Showcase","page":"Kinetic Calculators","title":"Calculator Showcase","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"In all of the examples below, sd and rd refer to instances of SpeciesData and RxData respectively. These are the internal representations of species and reactions within Kinetica, see the page on CRN Representation for further information.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"note: This section is growing!\nKinetica currently has only a handful of kinetic calculators available. We are adding more as we need them, but if you require a specific implementation then please let us know on our Issues page. Alternatively, calculators aren't too hard to implement yourself, and custom calculators can be dropped into kinetic simulations just like the ones presented here. See Calculator Interface for details.","category":"page"},{"location":"tutorials/kinetic-calculators/#Kinetica.jl","page":"Kinetic Calculators","title":"Kinetica.jl","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/#[PrecalculatedArrheniusCalculator](@ref)","page":"Kinetic Calculators","title":"PrecalculatedArrheniusCalculator","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"This calculator is dependent on temperature as an experimental condition, and takes a vector of Arrhenius prefactors and a vector of activation energies, each with an entry for each reaction in a given CRN, and calculates rate constants with the Arrhenius equation. It also accepts an optional maximum rate constant k_max which takes over through partial diffusion control. The calculated rate constant for reaction i is therefore: ","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"k_i = dfrac1dfrac1k_textmax + dfrac1A_ie^-dfracE_iRT","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"where A_i is the ith Arrhenius prefactor, E_i is the ith activation energy, R is the ideal gas constant and T is the temperature, which must be passed in as a parameter.","category":"page"},{"location":"tutorials/kinetic-calculators/#Example:","page":"Kinetic Calculators","title":"Example:","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"# Get Arrhenius prefactors A and activation energies Ea from elsewhere...\n# Length of A and Ea should match rd.nr.\ncalc = PrecalculatedArrheniusCalculator(Ea, A; k_max = 1e12)\nsetup_network!(sd, rd, calc)\nk = calc(; T = 300.0)","category":"page"},{"location":"tutorials/kinetic-calculators/#KineticaKPM.jl","page":"Kinetic Calculators","title":"KineticaKPM.jl","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"The calculators in KineticaKPM all use KineticPredictorModel (KPM), a Python code for predicting activation energies using a simple neural network, as a driver for rate constant calculation using the Arrhenius equation. Arrhenius prefactors are estimated through a variety of methods depending on the calculator used.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"The calculators in this package require an instance of KPMRun, which acts as an interface to the KPM package and handles conversion of the current CRN into reactions which it can predict activation energies for. This is simply constructed by calling the following:","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"kpm = KPMRun(\"/path/to/kpm_model.npz\")","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"where the KPM model .npz file should be obtained separately through training a model with the main Python package.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"All calculators in this package accept an optional maximum rate constant k_max which takes over through partial diffusion control. They are also all capable of returning rate constants with Measurements.jl uncertainties, derived from the standard deviation between activation energy predictions within an ensemble of neural networks. While these can be used manually, they are not currently supported within any of the ODE solution methods in Kinetica.","category":"page"},{"location":"tutorials/kinetic-calculators/#[KPMBasicCalculator](@ref)","page":"Kinetic Calculators","title":"KPMBasicCalculator","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"This calculator is dependent on temperature as an experimental condition. It estimates Arrhenius prefactors as","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"A = dfracRTh","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"for all reactions, where R is the ideal gas constant, T is the temperature, which must be passed as a parameter, and h is the Planck constant. The resulting rate constant for reaction i is therefore:","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"k_i = dfrac1dfrac1k_textmax + dfrac1dfracRThe^-dfracE_iRT","category":"page"},{"location":"tutorials/kinetic-calculators/#Example:-2","page":"Kinetic Calculators","title":"Example:","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"# Set up KPMRun object before this...\ncalc = KPMBasicCalculator(kpm; uncertainty = false, k_max = 1e12)\nsetup_network!(sd, rd, calc)\nk = calc(; T = 300.0)","category":"page"},{"location":"tutorials/kinetic-calculators/#[KPMCollisionCalculator](@ref)","page":"Kinetic Calculators","title":"KPMCollisionCalculator","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"This calculator is dependent on temperature as an experimental condition. It estimates Arrhenius prefactors using collision theory, a hard-sphere approximation of collision frequency. All unimolecular reactions therefore require a collision partner for reactions to occur, which can be passed through the inert_species argument. If this is given, setup_network! will modify all unimolecular reactions to become bimolecular with the provided collision partners. Otherwise, an average collision partner will be calculated from the species in the CRN and rates will be calculated assuming a concentration of 1 mol dm^-3 of this 'species'.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"The calculator computes two properties for each reaction: the reduced mass mu and the collision cross section sigma. For collision partners A and B, these are defined as","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"mu = dfracm_A m_Bm_A + m_B\nsigma = pi left( r_A + r_B right)^2","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"where m_A and m_B are the masses of A and B respectively and r_A and r_B are the hard sphere radii of A and B respectively.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"The calculator optionally allows for specification of a 'steric factor' rho. Collision theory is known to overestimate rate constants, but there is no perfect mathematical relationship that can calculate how much this overestimate is by. The steric factors implemented here attempt to establish an empirical correction to the collision theory rate constant based on a variety of information about each species. See KineticaKPM.calc_steric_factors for further information.","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"The resulting rate constant for reaction i is therefore:","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"k_i = dfrac1dfrac1k_textmax + dfrac1sigma_i rho_i N_A sqrtdfrac8 k_b Tpi mu_ie^-dfracE_iRT","category":"page"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"where N_A is Avogadro's number, k_b is the Boltzmann constant, T is the temperature, which is passed as a parameter, E_i is the activation energy and R is the ideal gas constant.","category":"page"},{"location":"tutorials/kinetic-calculators/#Example:-3","page":"Kinetic Calculators","title":"Example:","text":"","category":"section"},{"location":"tutorials/kinetic-calculators/","page":"Kinetic Calculators","title":"Kinetic Calculators","text":"# If using inert species, these need an initial concentration.\npars = ODESimulationParams(\n    tspan = (0.0, 10.0)\n    u0 = Dict(\n        \"CC\" => 1.0,\n        \"N#N\" => 1.0\n    ),\n    solver = ...\n)\n# Set up KPMRun object before this...\ncalc = KPMCollisionCalculator(\n    kpm,\n    inert_species = [\"N#N\"],\n    steric_factor = :basic,\n    uncertainty = false,\n    k_max = 1e12\n)\nsetup_network!(sd, rd, calc)\nk = calc(; T = 300.0)","category":"page"},{"location":"tutorials/ode-solution/#ODE-Solution","page":"ODE Solution","title":"ODE Solution","text":"","category":"section"},{"location":"tutorials/results-analysis/#Results-Analysis","page":"Results Analysis","title":"Results Analysis","text":"","category":"section"},{"location":"api/kinetica/conditions/#Kinetica.jl-API","page":"Conditions","title":"Kinetica.jl API","text":"","category":"section"},{"location":"api/kinetica/conditions/#Conditions","page":"Conditions","title":"Conditions","text":"","category":"section"},{"location":"api/kinetica/conditions/#ConditionSet","page":"Conditions","title":"ConditionSet","text":"","category":"section"},{"location":"api/kinetica/conditions/","page":"Conditions","title":"Conditions","text":"ConditionSet\nConditionSet(::Dict{Symbol, <:Any})\nget_profile(::ConditionSet, ::Symbol)\nKinetica.get_initial_conditions(::ConditionSet)\nisstatic\nisvariable\nget_tstops(::ConditionSet)\nget_t_final(::ConditionSet)\nsolve_variable_conditions!","category":"page"},{"location":"api/kinetica/conditions/#Kinetica.ConditionSet","page":"Conditions","title":"Kinetica.ConditionSet","text":"Container for all conditions in a kinetic simulation.\n\nConditions can be static or variable, and variable conditions can be gradient-based or directly usable.\n\nContains fields for:\n\nSymbolic representation of conditions (symbols)\nCondition profile for each symbol (profiles)\nWhether discrete rate constant updates are enabled for the conditions in this condition set (discrete_updates)\nDiscrete rate constant update timestep, is nothing if discrete_updates = false (ts_update)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/conditions/#Kinetica.ConditionSet-Tuple{Dict{Symbol}}","page":"Conditions","title":"Kinetica.ConditionSet","text":"conditions = ConditionSet(Dict(\n    :C1 => ConditionType1(...),\n    :C2 => ConditionType2(...))\n    [, ts_update]\n))\n\nOuter constructor for ConditionSet..\n\nSeparates condition profiles from their symbols and parses numeric profiles into StaticConditionProfiles. Registers AbstractVariableProfiles with Symbolics to allow for proper computation down the chain.\n\nIf ts_update is provided, creates tstops arrays within each variable profile for use in discrete rate update  simulations.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.get_profile-Tuple{ConditionSet, Symbol}","page":"Conditions","title":"Kinetica.get_profile","text":"profile = get_profile(cs, sym)\n\nGets the condition profile linked to sym from cs.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.get_initial_conditions-Tuple{ConditionSet}","page":"Conditions","title":"Kinetica.get_initial_conditions","text":"initial_conditions = get_initial_conditions(conditions)\n\nExtract initial conditions from ConditionSet.\n\nReturns an array of Pairs linking Symbols to initial values. For AbstractStaticProfiles, initial values are their static values. For AbstractVariableProfiles, initial values are their X_start values.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.isstatic","page":"Conditions","title":"Kinetica.isstatic","text":"isstatic(cs[, sym])\n\nDetermines if condition profiles in a ConditionSet are static.\n\nWhen a Symbol sym is provided, only checks if the profile linked to this Symbol is static. If no Symbol is provided, checks is all profiles are static.\n\nisstatic(profile)\n\nDetermines if a given condition profile is static.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/conditions/#Kinetica.isvariable","page":"Conditions","title":"Kinetica.isvariable","text":"isvariable(cs[, sym])\n\nDetermines if condition profiles in a ConditionSet are variable.\n\nWhen a Symbol sym is provided, only checks if the profile linked to this Symbol is variable. If no Symbol is provided, checks is all profiles are variable.\n\nisvariable(profile)\n\nDetermines if a given condition profile is variable.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/conditions/#Kinetica.get_tstops-Tuple{ConditionSet}","page":"Conditions","title":"Kinetica.get_tstops","text":"tstops = get_tstops(cs)\n\nRetrieves a sorted array of unique time stops from all condition profiles in cs.\n\nShould be used for passing a unified set of time stops to a discrete rate constant update solver. Will throw an error if all condition profiles are static, as they have no tstops.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.get_t_final-Tuple{ConditionSet}","page":"Conditions","title":"Kinetica.get_t_final","text":"t_final = get_t_final(cs)\n\nRetrieves the last necessary time point needed to encompass all variable condition profiles in cs.\n\nWill throw an error if all condition profiles are static, they have no set endpoints.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.solve_variable_conditions!","page":"Conditions","title":"Kinetica.solve_variable_conditions!","text":"solve_variable_conditions!(cs, pars[, reset, solver, solve_kwargs])\n\nSolves all variable condition profiles over the timespan in pars.tspan.\n\nPlaces all condition profile solutions in their sol field. In the case of AbstractDirectProfiles, this creates a DiffEqArray to mimic the regular DiffEq solver interface.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/conditions/#Static-Condition-Profiles","page":"Conditions","title":"Static Condition Profiles","text":"","category":"section"},{"location":"api/kinetica/conditions/","page":"Conditions","title":"Conditions","text":"Kinetica.StaticConditionProfile","category":"page"},{"location":"api/kinetica/conditions/#Kinetica.StaticConditionProfile","page":"Conditions","title":"Kinetica.StaticConditionProfile","text":"\n\n\n\n","category":"type"},{"location":"api/kinetica/conditions/#Directly-Variable-Condition-Profiles","page":"Conditions","title":"Directly Variable Condition Profiles","text":"","category":"section"},{"location":"api/kinetica/conditions/","page":"Conditions","title":"Conditions","text":"Kinetica.solve_variable_condition!(::Kinetica.AbstractDirectProfile, ::ODESimulationParams)\nNullDirectProfile\nNullDirectProfile()\nLinearDirectProfile\nLinearDirectProfile()","category":"page"},{"location":"api/kinetica/conditions/#Kinetica.solve_variable_condition!-Tuple{Kinetica.AbstractDirectProfile, ODESimulationParams}","page":"Conditions","title":"Kinetica.solve_variable_condition!","text":"solve_variable_condition!(profile<:AbstractDirectProfile, pars[, reset, solver, solve_kwargs])\n\nGenerates a solution for the specified directly-variable condition profile.\n\nFor profiles with direct functions, this requires calculating values for the specified pars.tspan and wrapping them within a DiffEqArray for compatibility with other interfaces (plotting, interpolation, etc.).\n\nArguments solver and solve_kwargs are provided for compatibility with callers, do nothing and should be ignored.\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.NullDirectProfile","page":"Conditions","title":"Kinetica.NullDirectProfile","text":"Container for null direct profile data and condition function.\n\nThis condition profile should only be used for debugging, as it has a condition function which always returns the initial condition. If only this constant condition is  required, the regular ODESolve should always be used  instead of an ODEConditionSolve with this condition  profile.\n\nContains fields for:\n\nCondition function (f)\nInitial value of condition (X_start)\nTime to stop calculation (t_end)\nTimes for the ODE solver to ensure calculation at (tstops)\nProfile solution, constructed by call to solve_variable_condition! (sol)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/conditions/#Kinetica.NullDirectProfile-Tuple{}","page":"Conditions","title":"Kinetica.NullDirectProfile","text":"condition_profile = NullDirectProfile(; X, t_end)\n\nOuter constructor for null condition direct profile.\n\nShould only be used for testing purposes (see struct documentation).\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.LinearDirectProfile","page":"Conditions","title":"Kinetica.LinearDirectProfile","text":"Container for linear condition ramp profile data and condition function.\n\nThis condition profile represents a linear condition increase/decrease from X_start to X_end.\n\nContains fields for:\n\nCondition function (f)\nRate of change of condition (rate)\nInitial value of condition (X_start)\nFinal value of condition (X_end)\nTime to stop calculation (t_end)\nTimes for the ODE solver to ensure calculation at (tstops)\nProfile solution, constructed by call to solve_variable_condition! (sol)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/conditions/#Kinetica.LinearDirectProfile-Tuple{}","page":"Conditions","title":"Kinetica.LinearDirectProfile","text":"condition_profile = LinearDirectProfile(; rate, X_start, X_end)\n\nOuter constructor for linear condition ramp direct profile.\n\nDetermines the simulation end time from the provided conditions and rate, then constructs the condition function (which is a linear y = mx + c function).\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Gradient-Variable-Condition-Profiles","page":"Conditions","title":"Gradient-Variable Condition Profiles","text":"","category":"section"},{"location":"api/kinetica/conditions/","page":"Conditions","title":"Conditions","text":"LinearGradientProfile\nLinearGradientProfile()\nDoubleRampGradientProfile\nDoubleRampGradientProfile()","category":"page"},{"location":"api/kinetica/conditions/#Kinetica.LinearGradientProfile","page":"Conditions","title":"Kinetica.LinearGradientProfile","text":"Container for linear condition ramp profile data and condition gradient function.\n\nThis condition profile represents a linear condition increase/decrease from X_start to X_end.\n\nContains fields for:\n\nCondition gradient function (grad)\nRate of change of condition (rate)\nInitial value of condition (X_start)\nFinal value of condition (X_end)\nTime to stop calculation (t_end)\nTimes for the ODE solver to ensure calculation at (tstops)\nProfile solution, constructed by call to solve_variable_condition! (sol)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/conditions/#Kinetica.LinearGradientProfile-Tuple{}","page":"Conditions","title":"Kinetica.LinearGradientProfile","text":"condition_profile = LinearGradientProfile(; rate, X_start, X_end)\n\nOuter constructor for linear condition ramp gradient profile.\n\nDetermines the simulation end time from the provided conditions and gradient, then constructs the condition gradient function  (which returns rate for every timestep).\n\n\n\n\n\n","category":"method"},{"location":"api/kinetica/conditions/#Kinetica.DoubleRampGradientProfile","page":"Conditions","title":"Kinetica.DoubleRampGradientProfile","text":"Container for double condition ramp profile data and condition gradient function.\n\nThis condition profile represents two condition ramps with adjustable condition plateaus before, after and in between the ramps, i.e.\n\n              ------   X_mid\n      rate1  /      \\\n            /        \\  rate2\nX_start ----          \\\n                       ----- X_end\n\nThe profile starts at X_start and maintains that value for t_start_plateau. The condition then ramps with gradient rate1 to condition value X_mid. This value is maintained for t_mid_plateau. The condition then ramps with gradient rate2 to condition value X_end. This value is maintained for t_end_plateau until the calculated time t_end.\n\nTo smooth out gradient discontinuities, a blending time t_blend can be passed to linearly interploate between plateaus and ramps, forming a smooth function of time. Larger values of t_blend yield smoother functions but decrease accuracy of the ramps, so should be used carefully.\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/conditions/#Kinetica.DoubleRampGradientProfile-Tuple{}","page":"Conditions","title":"Kinetica.DoubleRampGradientProfile","text":"condition_profile = DoubleRampGradientProfile(; X_start, t_start_plateau, rate1, X_mid, t_mid_plateau, rate2, X_end, t_end_plateau[, t_blend])\n\nOuter constructor for double condition ramp gradient profile.\n\nDetermines the simulation end time from the provided conditions and gradients, then constructs the condition gradient function  (which returns rate for every timestep).\n\nIf t_blend is passed, constructs a smooth approximation of the otherwise discontinuous gradient function.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/arbitrary-conditions/#Arbitrary-Simulation-Conditions","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"using Kinetica, Plots\nmkpath(\"../assets/tutorials/arbitrary_conditions\")\ncspars = ODESimulationParams(\n    tspan = (0.0, 10.0),\n    u0 = [0.0],\n    solver = nothing\n)","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"Alongside the modular kinetic calculator interface, the ability to pass arbitrary combinations of simulation conditions through to be used in CRN integration is one of the key elements of extensibility and customisation within Kinetica.","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"By only requiring that conditions use consistent symbolic names at their definition and within a kinetic calculator, any variable condition profile, defined either directly or by its gradient with respect to time, can be symbolically bound to any quantity of interest.","category":"page"},{"location":"tutorials/arbitrary-conditions/#[ConditionSet](@ref)","page":"Arbitrary Simulation Conditions","title":"ConditionSet","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"At the core of this system is the ConditionSet, which acts as an aggregator for individula condition profiles and their symbols. At their definition, ConditionSets take a dictionary of Symbol => Profile() mappings. Each Symbol can realistically be anything that Julia allows, but by convention (and for compatibility with most calculator implementations) we stick to the usual abbreviations for common conditions - :T for temperature, :P for pressure, :V for volume, etc. Each condition profile can be one of three options:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"A Number representing a static value for the given condition to take for the duration of the simulation. Internally this is converted into a Kinetica.StaticConditionProfile, but this is just a container for the number within.\nA directly variable condition profile, e.g. LinearDirectProfile. These are variable condition profiles where the condition is implemented directly as a function of time.\nA gradient-variable condition profile, e.g. LinearGradientProfile. These are variable condition profiles where the condition is implemented indirectly through its gradient with respect to time. These profiles must be numerically integrated (handled automtically within Kinetica) before they can be used.","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"The ConditionSet constructor takes an optional keyword argument, ts_update. If provided, this argument causes any kinetic simulations done with this ConditionSet to use the discrete rate update approximation, which is usually desired in any moderate to large-scale CRN simulations. For more information, see the tutorial on ODE Solution.","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"A ConditionSet which implements static simulation volume, linearly increasing temperature and linearly decreasing pressure with a rate constant update timestep of 1 ms could therefore look like the following:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"conditions = ConditionSet(Dict(\n    :V => 1000.0,\n    :T => LinearDirectProfile(;\n        rate = 20.0,\n        X_start = 300.0,\n        X_end = 500.0\n    ),\n    :P => LinearGradientProfile(;\n        rate = -50.0,\n        X_start = 1e5,\n        X_end = 9e4\n    )),\n    ts_update = tconvert(1.0, \"ms\", \"s\")\n)","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"note: Converting times\nBy default, Kinetica works in units of seconds (this can be changed within the kinetic calculator being used). While the conversion above may be a bit redundant, the tconvert function can be used to quickly convert between commonly used time units.","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"warning: Discrete Rate Approximation Behaviour\nThe behaviour of the ts_update argument is subject to change in the near future. This will likely not be a dramatic change, but it may be worth bearing in mind.","category":"page"},{"location":"tutorials/arbitrary-conditions/#Useful-Functions","page":"Arbitrary Simulation Conditions","title":"Useful Functions","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"Once constructed, ConditionSets can be queried in a number of ways. To fetch any of the profiles within, get_profile can be called:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"get_profile(conditions, :T)","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"To test if a given condition is static or variable, the isstatic and isvariable funcitons can be called:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"println(\"Temperature profile is static: $(isstatic(conditions, :T))\")\nprintln(\"Pressure profile is variable: $(isvariable(conditions, :P))\")","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"To get the final time at which all condition profiles have stopped varying, get_t_final can be called. This returns the maximum value of each condition profile's t_end attribute (see below):","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"get_t_final(conditions)","category":"page"},{"location":"tutorials/arbitrary-conditions/#Condition-Profile-Showcase","page":"Arbitrary Simulation Conditions","title":"Condition Profile Showcase","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"Below are the currently implemented variable condition profiles, along with examples of their shapes. Condition profiles are being added as we need them, so this library is currently quite small. You can help us out by adding new profiles and submitting a pull request (see the Development section on Condition Profiles), or by requesting them to be added on our Issues page!","category":"page"},{"location":"tutorials/arbitrary-conditions/#Directly-Variable-Condition-Profiles","page":"Arbitrary Simulation Conditions","title":"Directly Variable Condition Profiles","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/#[LinearDirectProfile](@ref)","page":"Arbitrary Simulation Conditions","title":"LinearDirectProfile","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"This profile represents a linear change from one value to another. It has a piecewise linear condition function, defined as follows for the arbitrary condition X:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"Xleft( t right) = \n    begincases\n        textttX_start  textif  t leq 00 \n        textttX_start + tleft( textttrate right)  textif  t  00 text and  t leq t_textend \n        textttX_end  textif  t  t_textend \n    endcases","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"where t_textend = left( textttX_end - textttX_start right)  textttrate. For example:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"# This is not being run in an example block with lines hidden because there\n# is seemingly no way of not having any kind of return block, and redefining\n# the functions within profiles prints to stderr, which is returned when the\n# example returns nothing.\ncs = ConditionSet(Dict(\n    :T => LinearDirectProfile(;\n        X_start = 300.0,\n        X_end = 500.0,\n        rate=20.0)\n))\ncspars.tspan = (0.0, get_t_final(cs))\nsolve_variable_conditions!(cs, cspars)\nplot(get_profile(cs, :T).sol, label=\"T\", xlabel=\"t\")\nsavefig(\"../assets/tutorials/arbitrary_conditions/lineardirectprofile.svg\")","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"cs = ConditionSet(Dict(\n    :T => LinearDirectProfile(;\n        X_start = 300.0,\n        X_end = 500.0,\n        rate=20.0)\n))","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"(Image: )","category":"page"},{"location":"tutorials/arbitrary-conditions/#Gradient-Variable-Condition-Profiles","page":"Arbitrary Simulation Conditions","title":"Gradient-Variable Condition Profiles","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/#[LinearGradientProfile](@ref)","page":"Arbitrary Simulation Conditions","title":"LinearGradientProfile","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"The gradient-based implementation of LinearDirectProfile. Either can be used, they should be equally accurate. Mostly serves as an example of how gradient profiles differ in implementation to their directly variable counterparts. It has a piecewise linear gradient function, defined as follows for the arbitrary condition X:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"fracmathrmd Xleft( t right)mathrmdt = \n    begincases\n        00  textif  t leq 00 \n        textttrate  textif  t  00 text and  t leq t_textend \n        00  textif  t  t_textend \n    endcases","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"where t_textend = left( textttX_end - textttX_start right)  textttrate. For example:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"cs = ConditionSet(Dict(\n    :P => LinearGradientProfile(;\n        X_start = 1e5,\n        X_end = 9e4,\n        rate=-50.0)\n))\ncspars.tspan = (0.0, get_t_final(cs))\nsolve_variable_conditions!(cs, cspars)\nplot(get_profile(cs, :P).sol)\nsavefig(\"../assets/tutorials/arbitrary_conditions/lineargradientprofile.svg\")","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"cs = ConditionSet(Dict(\n    :P => LinearGradientProfile(;\n        X_start = 1e5,\n        X_end = 9e4,\n        rate=-50.0)\n))","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"(Image: )","category":"page"},{"location":"tutorials/arbitrary-conditions/#[DoubleRampGradientProfile](@ref)","page":"Arbitrary Simulation Conditions","title":"DoubleRampGradientProfile","text":"","category":"section"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"This profile represents two linear condition ramps, each of which can have either a positive or a negative gradient, separated by a plateau of variable time. The profile also begins and ends with variable-length condition plateaus to enable equilibration at the initial and final values. It has a piecewise linear gradient function, defined as follows for the arbitrary condition X:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"fracmathrmd Xleft( t right)mathrmdt = \n    begincases\n        00  textif  t  t_r1 textstart \n        textttrate1  textif  t_r1 textstart leq t  t_r1 textend \n        00  textif  t_r1 textend leq t  t_r2 textstart \n        textttrate2  textif  t_r2 textstart leq t  t_r2 textend \n        00  textif  t geq t_r2 textend \n    endcases","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"where textttrate1 and textttrate2 are the rates of change of the two linear ramps, and t_r1 textstart, t_r1 textend, t_r2 textstart and t_r2 textend are the respective start- and end-times of the first and second ramps, determined by the lengths of the starting, middle and ending plateaus.","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"The profile features an optional argument t_blend, which can be used to create smooth transitions between the otherwise discontinuous gradient changes through linear interpolation. For example:","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"cs = ConditionSet(Dict(\n    :K => DoubleRampGradientProfile(;\n        X_start = 100.0,\n        t_start_plateau = 3.0,\n        rate1 = 10.0,\n        X_mid = 250.0,\n        t_mid_plateau = 5.0,\n        rate2 = -25.0,\n        X_end = 50.0,\n        t_end_plateau = 10.0,\n        t_blend = 0.5)\n))\ncspars.tspan = (0.0, get_t_final(cs)) # hide\nsolve_variable_conditions!(cs, cspars) # hide\nplot(get_profile(cs, :K).sol) # hide\nsavefig(\"../assets/tutorials/arbitrary_conditions/doublerampgradientprofile.svg\"); nothing # hide","category":"page"},{"location":"tutorials/arbitrary-conditions/","page":"Arbitrary Simulation Conditions","title":"Arbitrary Simulation Conditions","text":"(Image: )","category":"page"},{"location":"api/kinetica/utilities/#Kinetica.jl-API","page":"Utilities","title":"Kinetica.jl API","text":"","category":"section"},{"location":"api/kinetica/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"api/kinetica/utilities/","page":"Utilities","title":"Utilities","text":"tconvert\nKinetica.format_rxn","category":"page"},{"location":"api/kinetica/utilities/#Kinetica.tconvert","page":"Utilities","title":"Kinetica.tconvert","text":"tconvert(t, from_unit, to_unit)\n\nConverts a time from one unit (from_unit) to another (to_unit).\n\nSupported units (with accepted abbreviations) are:\n\npicoseconds (ps)\nnanoseconds (ns)\nmicroseconds (us)\nmilliseconds (ms)\nseconds (s)\nminutes (mins)\nhours (hrs)\ndays\nmonths (mts)\nyears (yrs)\n\nWill throw an error if unsupported units are provided.\n\n\n\n\n\ntconvert(from_unit, to_unit)\n\nReturns tconvert(1.0, from_unit, to_unit).\n\nUseful for just getting a conversion factor between time units,  rather than converting a specific time directly.\n\n\n\n\n\ntconvert(t, from_unit, to_unit)\n\nConverts a vector of times from one unit (from_unit) to another (to_unit).\n\nSupported units (with accepted abbreviations) are:\n\npicoseconds (ps)\nnanoseconds (ns)\nmicroseconds (us)\nmilliseconds (ms)\nseconds (s)\nminutes (mins)\nhours (hrs)\ndays\nmonths (mts)\nyears (yrs)\n\nWill throw an error if unsupported units are provided.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/utilities/#Kinetica.format_rxn","page":"Utilities","title":"Kinetica.format_rxn","text":"rxn_str = format_rxn(sd, rd, rid)\n\nNicely formats a string describing the reaction at rid.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/utilities/#Logging","page":"Utilities","title":"Logging","text":"","category":"section"},{"location":"api/kinetica/utilities/","page":"Utilities","title":"Utilities","text":"start_log\nend_log\nflush_log","category":"page"},{"location":"api/kinetica/utilities/#Kinetica.start_log","page":"Utilities","title":"Kinetica.start_log","text":"logger = start_log(logdir[, label])\n\nCreates a SimpleLogger for logging to a file in logdir.\n\nFilename of the log can be customised using label. All new logfiles will have dates attached.\n\nExample\n\n# Creates a new logfile in `logdir/MyLog_yymmdd-HHMMSS.log`\nlogger = start_log(logdir; label=\"MyLog\")\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/utilities/#Kinetica.end_log","page":"Utilities","title":"Kinetica.end_log","text":"end_log(logger)\n\nCloses the IOStream attached to logger.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/utilities/#Kinetica.flush_log","page":"Utilities","title":"Kinetica.flush_log","text":"flush_log()\n\nFlushes the IOStream attached to the currently scoped logger.\n\n\n\n\n\n","category":"function"},{"location":"api/kinetica/openbabel/#Kinetica.jl-API","page":"Open Babel","title":"Kinetica.jl API","text":"","category":"section"},{"location":"api/kinetica/openbabel/#Open-Babel","page":"Open Babel","title":"Open Babel","text":"","category":"section"},{"location":"api/kinetica/rdkit/#Kinetica.jl-API","page":"RDKit","title":"Kinetica.jl API","text":"","category":"section"},{"location":"api/kinetica/rdkit/#RDKit","page":"RDKit","title":"RDKit","text":"","category":"section"},{"location":"tutorials/iterative-exploration/#Iterative-CRN-Exploration","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"","category":"section"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"The iterative CRN exploration method (IterativeExplore) allows for CRNs to be efficiently explored by only attempting to find reactions involving kinetically viable species. In the vast majority of cases, this produces CRNs with more thoroughly sampled reactions per species than the direct exploration method (DirectExplore, demonstrated in Getting Started).","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"(Image: )","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"The figure above shows the main methodological differences between the direct and iterative exploration methods. In the direct method (a), as many reactions as possible are explored outwards from a starting system of species. This is done by successive iterations of stochastic mechanism generation with CDE's single-ended graph-driven sampling (SE-GDS) method. Each random mechanism is of length n_r, controlled within Kinetica by the radius parameter in a CDE parameter block. ","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"CRNs are built by adding all new reactions from each mechanism to the current SpeciesData and RxData (see CRN Representation for details). Mechanism generation proceeds until a user-defined number of CDE iterations have passed without any new reactions being added to the CRN (controlled by the rxn_convergence_threshold parameter of DirectExplore).","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"The direct method has a number of flaws when applied to large CRNs - it is capable of simulataneously under-exploring reactions between species many reactive steps away from the starting system, and it over-explores species and reactions that may never form/occur due to the kinetics of the CRN as a whole. This is the rationale behind the iterative exploration method.","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"In the iterative method (b), exploration proceeds in levels. Each level consists of the following steps:","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"A system of species is created. CDE requires species to be input within a single XYZ file, so care must be taken to place species in cartesian space such that they are separated (not considered to be bonded to one another). \nThis is performed by optimisation of a spring-particle system that moves species' centres of mass (see Molecule System).\nReactions of species within this system are explored. This is usually set such that only adjacent reactions - those that are a single reaction away from reactants within the given species system - are explored, as this avoids the most unneccessary exploration. \nThis is first done by finding all same-species reactions, both unimolecular and bimolecular, then finding all different-species reactions. This occurs in dedicated subspaces, which are then collated to form the overall level.\nEach subspace is considered to be converged in the same way as a direct method CRN - once a user-defined number of CDE iterations have passed without any new reactions being discovered (controlled by the rxn_convergence_threshold parameter of IterativeExplore).\nA kinetic simulation is run with the full CRN explored so far. This is done to identify species which exist at a high concentration at some point during the time period of interest, as these species are the most likely to react since they are most prevalent in the reaction mixture.\nThese high concentration species are referred to as seed species within Kinetica, as they are used to grow the next level of exploration.\nSpecies are selected as seeds if they have a maximum concentration above the seed_conc parameter of IterativeExplore.\nThe seed species are collated and the next level begins at step 1.","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"The iterative exploration method stops generating new levels of reactions once seed_convergence_threshold levels of exploration have passed without the seed system changing. This indicates that the remaining seeds are the high concentration species that should exist within the full CRN.","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"By only exploring down reactive pathways that are kinetically viable, the iterative exploration method avoids the combinatorial explosion of possible reactions that the direct method faces. This comes with the benefit of avoiding exploration of reactions that cannot occur because their reactants are never formed, speeding up kinetic simulations dramatically.","category":"page"},{"location":"tutorials/iterative-exploration/#Example","page":"Iterative CRN Exploration","title":"Example","text":"","category":"section"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"From a user's perspective, running a CRN exploration with the iterative method is almost identical to running one with the direct method. The simulation conditions, parameters and calculator are all defined in the same way, but an IterativeExplore parameter block is used instead of a DirectExplore block:","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"crn_dir = \"./my_iterative_CRN\"\n\nexploremethod = IterativeExplore(\n    rdir_head = crn_dir,\n    reac_smiles = [\"C\"],\n    rxn_convergence_threshold = 5,\n    seed_convergence_threshold = 3,\n    seed_conc = 0.05,\n    independent_blacklist = [\"[H]\"],\n    cde = CDE(\n        template_dir = \"../../examples/cde_template\",\n        radius = 1\n    )\n)","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"Most of the new parameters here are defined above, with exception of the independent_blacklist parameter. This defines a list of SMILES species names which should not be subjected to same-species reactions within their own subspace. The hydrogen radical is shown here as an example, as it cannot break down any more and the only reactions which consume it are the opposites of those that create it.","category":"page"},{"location":"tutorials/iterative-exploration/#Setting-seed_conc","page":"Iterative CRN Exploration","title":"Setting seed_conc","text":"","category":"section"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"The value of the seed_conc parameter is crucial in iterative explorations, effectively determining the accuracy of the resulting CRN. Set too high, very few species will ever have maximum concentrations above it and CRN levels will not contain many reactions, leading to a CRN that converges very quickly but is not sampled enough to be accurate. If seed_conc is set too low however, too many species will become seeds and individual levels will struggle to converge due to the breadth of reactions that must be sampled.","category":"page"},{"location":"tutorials/iterative-exploration/","page":"Iterative CRN Exploration","title":"Iterative CRN Exploration","text":"Finding the 'correct' value of seed_conc is therefore not a simple task - it is highly dependent on the species being reacted and the conditions and kinetic calculator that the simulations which guide the CRN exploration are using. We therefore recommend that multiple iterative explorations are run with decreasing values of seed_conc until an acceptable CRN accuracy has been found (i.e. the CRN is as complete as it needs to be for your use case). It can help if you have some experimental results for a related initial system under similar conditions to compare against.","category":"page"},{"location":"tutorials/filtering-crns/#Filtering-CRNs","page":"Filtering CRNs","title":"Filtering CRNs","text":"","category":"section"},{"location":"api/kineticakpm/#KineticaKPM.jl-API","page":"KineticaKPM.jl","title":"KineticaKPM.jl API","text":"","category":"section"},{"location":"api/kineticakpm/#KPM-Runner","page":"KineticaKPM.jl","title":"KPM Runner","text":"","category":"section"},{"location":"api/kineticakpm/","page":"KineticaKPM.jl","title":"KineticaKPM.jl","text":"KPMRun","category":"page"},{"location":"api/kineticakpm/#KineticaKPM.KPMRun","page":"KineticaKPM.jl","title":"KineticaKPM.KPMRun","text":"kpm = KPMRun(model_path)\n\nKPM runner for prediction of reaction activation energies.\n\nHandles instantiation of the underlying Scikit-Learn model in Python, and can be called to use this model for predictions.\n\n\n\n\n\n","category":"type"},{"location":"api/kineticakpm/#KPM-Calculators","page":"KineticaKPM.jl","title":"KPM Calculators","text":"","category":"section"},{"location":"api/kineticakpm/","page":"KineticaKPM.jl","title":"KineticaKPM.jl","text":"KPMBasicCalculator\nKPMCollisionCalculator\nKPMCollisionEntropyCalculator","category":"page"},{"location":"api/kineticakpm/#KineticaKPM.KPMBasicCalculator","page":"KineticaKPM.jl","title":"KineticaKPM.KPMBasicCalculator","text":"Basic KPM kinetic calculator for reactions.\n\nKinetic calculator that uses KPM to predict activation energies for reactions and uses these predictions within the Arrhenius equation to calculate rate constants.\n\nBasic calculator uses a flat RT/h Arrhenius prefactor for all reactions. This is usually not accurate enough to enable sensible kinetic simulations.\n\nImplemented conditions:\n\nTemperature (T, unit: K)\n\nRequires:\n\nReaction energies (rd.dH, unit: eV)\nTrained KPM model (kpm.model_path, loaded when KPMRun is instantiated)\n\nHas support for dispatching with/without a maximum rate constant k_max and scaling by time unit t_unit (assuming rates are provided in units of /s).\n\n\n\n\n\n","category":"type"},{"location":"api/kineticakpm/#KineticaKPM.KPMCollisionCalculator","page":"KineticaKPM.jl","title":"KineticaKPM.KPMCollisionCalculator","text":"Collision theory-based KPM kinetic calculator for reactions.\n\nKinetic calculator that uses KPM to predict activation energies for reactions and uses these predictions within the Arrhenius equation to calculate rate constants.\n\nCollision theory-based calculator approximates Arrhenius prefactors on a per-reaction basis with a hard sphere approximation of collision frequency. This is most accurate for small, spherical reactants, and becomes less realistic the further from this ideal the reactants get.\n\nAdditionally, allows for using one of a selection of steric factors for correcting discrepancies between collision theory prefactors and real Arrhenius prefactors.\n\nImplemented conditions:\n\nTemperature (T, unit: K)\n\nRequires:\n\nReaction energies (rd.dH, unit: eV)\nTrained KPM model (kpm.model_path, loaded when KPMRun is instantiated)\n\nHas support for dispatching with/without a maximum rate constant k_max and scaling by time unit t_unit (assuming rates are provided in units of /s).\n\n\n\n\n\n","category":"type"},{"location":"api/kineticakpm/#KineticaKPM.KPMCollisionEntropyCalculator","page":"KineticaKPM.jl","title":"KineticaKPM.KPMCollisionEntropyCalculator","text":"Collision theory-based KPM kinetic calculator for reactions, with translational entropy.\n\nKinetic calculator that uses KPM to predict activation energies for reactions and uses these predictions within the Arrhenius equation to calculate rate constants.\n\nCollision theory-based calculator approximates Arrhenius prefactors on a per-reaction basis with a hard sphere approximation of collision frequency. This is most accurate for small, spherical reactants, and becomes less realistic the further from this ideal the reactants get.\n\nAdditionally, calculates translational entropy change for each reaction to correct for lack of entropic contribution in collision theory prefactors.\n\nImplemented conditions:\n\nTemperature (T, unit: K)\n\nRequires:\n\nReaction energies (rd.dH, unit: eV)\nTrained KPM model (kpm.model_path, loaded when KPMRun is instantiated)\n\nHas support for dispatching with/without a maximum rate constant k_max and scaling by time unit t_unit (assuming rates are provided in units of /s).\n\n\n\n\n\n","category":"type"},{"location":"api/kineticakpm/#Property-Calculation","page":"KineticaKPM.jl","title":"Property Calculation","text":"","category":"section"},{"location":"api/kineticakpm/","page":"KineticaKPM.jl","title":"KineticaKPM.jl","text":"KineticaKPM.calc_collision_params\nKineticaKPM.calc_steric_factors","category":"page"},{"location":"api/kineticakpm/#KineticaKPM.calc_collision_params","page":"KineticaKPM.jl","title":"KineticaKPM.calc_collision_params","text":"μ, σ = calc_collision_params(rd, sd[, easy_units])\n\nCalculates the collision theory parameters for given reactions.\n\nCollision theory requires calculation of a reduced mass μ and a collision cross-section σ for each pair of reactants in a reaction.\n\nCalculates these values, using an 'average collision partner' for unimolecular reactions. Possible to get around this by implementing a non-reactive collision partner with unit concentration to all  unimolecular reactions, effectively making them bimolecular for the purposes of these calculations.\n\nMust be preceded by a call to get_frag_stats!() to populate species weights and radii.\n\n\n\n\n\n","category":"function"},{"location":"api/kineticakpm/#KineticaKPM.calc_steric_factors","page":"KineticaKPM.jl","title":"KineticaKPM.calc_steric_factors","text":"ρ = calc_steric_factors(rd, sd, steric_factor)\n\nCalculates steric factors for all reactions in rd, using the requested steric factor function.\n\nValid steric factors are\n\n:basic - Calculates steric factors as 1/(α_A * α_B), where α_i = n_i² + 5r_i(n_i - 1).\n:exp - Calculates steric factors as 1/(α_A * α_B)^β, where α_i = n_i² + 5r_i(n_i - 1). Requires passing a value of β via params\n:logistic - Calculates steric factors with an adjustable bivariate logistic distribution. Requires passing a value of β via params\n:dlogistic - Calculates steric factors with 2 adjustable bivariate logistic distributions. Requires passing a vector of [βassoc, βdissoc] via params\n:none - Makes all steric factors equal to 1, removing them from the rate equation.\n\n\n\n\n\nρ = calc_steric_factors(rd, sd, Val(:none))\n\nMakes all steric factors equal to 1, removing them from the rate equation.\n\n\n\n\n\nρ = calc_steric_factors(rd, uniq_frags, Val(:basic))\n\nCalculates steric factors as 1/(α_A * α_B), where α_i = n_i + 5r_i(n_i - 1).\n\n\n\n\n\nρ = calc_steric_factors(rd, uniq_frags, Val(:exp), β)\n\nCalculates steric factors as 1/(α_A * α_B)^β, where α_i = n_i² + 5r_i(n_i - 1).\n\n\n\n\n\nρ = calc_steric_factors(rd, uniq_frags, Val(:logistic), β)\n\nCalculates steric factors on an adjustable bivariate logistic distribution.\n\nThe steric factor ρ for a reaction is calculated as\n\nρ = D / ((1+exp(βα_A))(1+exp(βα_B)))\n\nwhere \n\nD = (1+exp(β))^2, \nα_i = n_i + 5r_i(n_i-1),\n\nand A and B are the bimolecular reactants.\n\n\n\n\n\nρ = calc_steric_factors(rd, uniq_frags, Val(:dlogistic), β_assoc, β_dissoc)\n\nCalculates steric factors on 2 adjustable bivariate logistic distributions.\n\nCreates 2 logistic distributions: one for associative reactions, and the other for dissociative reactions. The gradient of each distribution can be tuned with its respective β parameter.\n\nThe steric factor ρ for an associative reaction is calculated as\n\nρ = D_assoc / ((1+exp(β_assoc*α_A))(1+exp(β_assoc*α_B)))\n\nwhile the steric factor for a dissociative reaction is calculated as\n\nρ = D_dissoc / ((1+exp(β_dissoc*α_A))(1+exp(β_dissoc*α_B)))\n\nwhere \n\nD_assoc = (1+exp(β_assoc))^2, \nD_dissoc = (1+exp(β_dissoc))^2,\nα_i = n_i + 5r_i(n_i-1),\n\nand A and B are the bimolecular reactants. Reactions which are neither associative nor dissociative use the associative steric factor by default.\n\n\n\n\n\n","category":"function"},{"location":"#Kinetica.jl-Documentation","page":"Home","title":"Kinetica.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kinetica.jl is a Julia package for performing automated exploration of chemical reaction networks (CRNs) and integrating these networks in time. In particular, it features:","category":"page"},{"location":"#Arbitrary-simulation-conditions","page":"Home","title":"Arbitrary simulation conditions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kinetica.jl is built around giving users complete freedom over kinetic simulations. As such any combination of customisable simulation conditions, static or variable, can be utilised by binding symbolic variable names to flexible parametric condition profiles.","category":"page"},{"location":"#Kinetics-driven-CRN-exploration","page":"Home","title":"Kinetics-driven CRN exploration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Chemical space exploration can be performed with a fully random approach, sampling every reaction within a defined number of intermediates from a starting system. This can be very difficult to sample completely and is often inefficient. We provide a focused kinetics-driven approach that selectively explores reaction space in places relevant to the given simulation conditions.","category":"page"},{"location":"#Flexible-kinetic-simulation","page":"Home","title":"Flexible kinetic simulation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"By leveraging packages from Julia's SciML organization (including DifferentialEquations.jl, ModelingToolkit.jl and Catalyst.jl), users can perform difficult long-timescale integrations of generated CRNs under challenging variable experimental conditions. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We supplement this with a discrete approximation to variable rate constant simulations that greatly improves overall solution efficiency and allows for previously inaccessible levels of theory to be incorporated into variable kinetic calculations.","category":"page"},{"location":"#Modular-kinetic-calculators","page":"Home","title":"Modular kinetic calculators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Extending user control over kinetic simulations, Kinetica.jl makes use of a modular calculator interface for rate constant calculations. This allows for a wide variety of techniques to be utilised within kinetic simulations, ranging from expensive DFT-based approaches to fast ML-based approximations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We currently provide the KineticaKPM.jl package for calculating rate constants from ML-predicted activation energies, and aim to release further calculator packages in the future. However, the calculator interface allows for simple user definition of new methods too.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kinetica.jl can be installed through the Julia package manager by adding the KinetcaRegistry package registry:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.Registry.add(RegistrySpec(url=\"https://github.com/Kinetica-jl/KineticaRegistry\"))\nPkg.add(\"Kinetica\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will fetch the latest version of Kinetica.jl, as well as all of its dependencies.","category":"page"},{"location":"#Other-Kinetica-Packages","page":"Home","title":"Other Kinetica Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This process is the same for other Kinetica extension packages, such as KineticaKPM.jl, which can be installed in the same way, e.g.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"KineticaKPM\")","category":"page"},{"location":"#Python-Dependencies","page":"Home","title":"Python Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kinetica makes use of Python packages such as RDKit and Open Babel internally for extracting information from molecular geometries. Installation of these packages is handled automatically thanks to CondaPkg.jl, which creates a conda environment that is isolated to the current project and the packages within it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This conda environment is composable at runtime, so if you were to have both Kinetica.jl and KineticaKPM.jl in the same Julia project, the Python dependencies of both packages would be automatically assembled into a dedicated conda environment that is then used internally by both packages through PythonCall.jl. ","category":"page"},{"location":"#xTB","page":"Home","title":"xTB","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"While not a direct dependency, some parts of Kinetica's CRN exploration routines (which act through the CDE code) require an electronic structure code to perform geometry optimisations and energy calculations. Since only approximate geometries and energies are required within CDE, we recommend using the GFN2-xTB method within the Extended Tight-Binding (xTB) package by Bannwarth et. al. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"An xTB package is included with Kinetica.jl's Python dependencies and will be installed automatically. A shorthand alias to this package can be created (assuming you are in your Julia project's directory) with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"alias xtb=\"$(julia --project -e 'using CondaPkg; print(CondaPkg.which(\"xtb\"))')\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note for tutorial users\nIf you plan to follow the tutorials in this documentation, the example CDE inputs assume that you have xTB installed and available by calling xtb (either aliased or in your PATH). The above alias is therefore required for the tutorials to function.","category":"page"},{"location":"#Citing-Kinetica","page":"Home","title":"Citing Kinetica","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use any of the Kinetica packages in your work, please cite the following:","category":"page"},{"location":"#Kinetica.jl","page":"Home","title":"Kinetica.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Gilkes, J.; Storr, M.; Maurer, R. J.; Habershon, S. Predicting long timescale kinetics under variable experimental conditions with Kinetica.jl. 2024, arXiv:2403.08657. arXiv.org e-Print archive. https://arxiv.org/abs/2403.08657","category":"page"},{"location":"#KineticaKPM.jl","page":"Home","title":"KineticaKPM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Paper coming soon!","category":"page"},{"location":"api/kinetica/solving/#Kinetica.jl-API","page":"Solving","title":"Kinetica.jl API","text":"","category":"section"},{"location":"api/kinetica/solving/#Simulation-Parameters","page":"Solving","title":"Simulation Parameters","text":"","category":"section"},{"location":"api/kinetica/solving/","page":"Solving","title":"Solving","text":"ODESimulationParams","category":"page"},{"location":"api/kinetica/solving/#Kinetica.ODESimulationParams","page":"Solving","title":"Kinetica.ODESimulationParams","text":"Container for ODE-driven simulation parameters.\n\nContains fields for:\n\nSimulation timespan (must match time unit used in an attached calculator) (tspan)\nInitial concentrations of species, either as a Dict of certain species or a Vector of all species (u0)\nDifferentialEquations ODE solver (solver)\nWhether to use ModelingToolkit to formulate an analytical Jacobian (do_jac=true)\nWhether to use ModelingToolkit to formulate a sparse problem (do_sparse=true)\nAbsolute tolerance of ODE solver (abstol=1e-10)\nRelative tolerance of ODE solver (reltol=1e-8)\nWhether to use adaptive solver tolerance (adaptive_tols=true)\nWhether to update solver tolerances after successful solve with adaptive tolerance (update_tols=false)\nWhether to break solution into chunks of size solve_chunkstep to avoid floating point underflow (solve_chunks=true)\nGlobal timestep at which solution should be reinitialised when solve_chunks=true (solve_chunkstep=1e-3)\nMaximum number of ODE solver iterations (maxiters=1e5)\nWhether to explicitly disallow negative values in the solver (ban_negatives=false)\nWhether to display progress bars - requires TerminalLogger initialisation (progress=false)\nTime interval to interpolate solution data on (save_interval=nothing)\nCutoff below which reactions with low rate constants are removed from the network (low_k_cutoff=:auto)\nWhether to allow a vector u0 to be shorter than the number of species in the network (allow_short_u0=false)\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/solving/#Kinetic-Calculators-(Kinetica.jl)","page":"Solving","title":"Kinetic Calculators (Kinetica.jl)","text":"","category":"section"},{"location":"api/kinetica/solving/","page":"Solving","title":"Solving","text":"PrecalculatedArrheniusCalculator","category":"page"},{"location":"api/kinetica/solving/#Kinetica.PrecalculatedArrheniusCalculator","page":"Solving","title":"Kinetica.PrecalculatedArrheniusCalculator","text":"Arrhenius theory kinetic calculator for precalculated reactions.\n\nKinetic calculator that uses the Arrhenius equation to determine rates of reaction. Requires prior specification of reaction activation energies (Ea) and Arrhenius prefactors (A), will not calculate/predict these internally.\n\nImplemented conditions:\n\nTemperature (T, unit: K)\n\nRequires:\n\nActivation energies (Ea, unit: J/mol)\nArrhenius prefactors (A, unit: mol dm^-3 s^-1 assuming bimolecular reactions)\n\nHas support for dispatching with/without a maximum rate constant k_max and scaling by time unit t_unit (assuming rates are provided in units of /s).\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/solving/#Solvers","page":"Solving","title":"Solvers","text":"","category":"section"},{"location":"api/kinetica/solving/","page":"Solving","title":"Solving","text":"VariableODESolve\nsolve_network","category":"page"},{"location":"api/kinetica/solving/#Kinetica.VariableODESolve","page":"Solving","title":"Kinetica.VariableODESolve","text":"Variable kinetic CRN solver type.\n\nCombines all parameter inputs, conditions, a calculator and a set of reaction finters into a single type to be passed to the solver.\n\nConditions in the provided ConditionSet must be compatible with the calculator and can be a combination of static and  variable. However, this will throw an error if all conditions  are static, as a StaticODESolve should be used instead.\n\nAllows for optional specification of RxFilter. If not defined, creates a filter that allows all reactions.\n\n\n\n\n\n","category":"type"},{"location":"api/kinetica/solving/#Kinetica.solve_network","page":"Solving","title":"Kinetica.solve_network","text":"solve_network(method::StaticODESolve, sd, rd[, copy_network, return_integrator])\n\nSolve a network with static kinetics.\n\nAutomatically dispatches to the correct method based on the value of method.pars.solve_chunks, as chunkwise solution requires a significantly different approach.\n\nSetting copy_network=true generates a deepcopy of the original network in rd and sd and uses these in the solution, to avoid side effects from calculators modifying the original network that is passed in. The copied (modified) network is returned as part of the  resulting ODESolveOutput.\n\nSetting return_integrator=true sets up and returns the underlying integrator without solving (i.e. at  t = method.pars.tspan[1]), allowing for manual stepping through the solution. Note that chunkwise solutions implement many reinitialisations of this integrator, which will have to be mirrored in the calling script to get the same results.\n\n\n\n\n\nsol = solve_network(method::VariableODESolve, sd, rd[, copy_network, return_integrator])\n\nSolve a network with variable kinetics.\n\nAutomatically dispatches to the correct method based on the value of method.pars.solve_chunks, as chunkwise solution requires a significantly different approach.\n\nSetting copy_network=true generates a deepcopy of the original network in rd and sd and uses these in the solution, to avoid side effects from calculators modifying the original network that is passed in. The copied (modified) network is returned as part of the  resulting ODESolveOutput.\n\nSetting return_integrator=true sets up and returns the underlying integrator without solving (i.e. at  t = method.pars.tspan[1]), allowing for manual stepping through the solution. Note that chunkwise solutions implement many reinitialisations of this integrator, which will have to be mirrored in the calling script to get the same results.\n\n\n\n\n\n","category":"function"}]
}
